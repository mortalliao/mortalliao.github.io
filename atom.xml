<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mortalLiao</title>
  <subtitle>Keep learning</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-11-27T06:15:50.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>mortalLiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>04_Docker_容器连接</title>
    <link href="http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/04_Docker_%E5%AE%B9%E5%99%A8%E8%BF%9E%E6%8E%A5/"/>
    <id>http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/04_Docker_容器连接/</id>
    <published>2017-11-27T06:15:50.000Z</published>
    <updated>2017-11-27T06:15:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络端口映射"><a href="#网络端口映射" class="headerlink" title="网络端口映射"></a>网络端口映射</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run -d -P training/webapp python app.py</div><div class="line">fce072cc88cee71b1cdceb57c2821d054a4a59f67da6b416fceb5593f059fc6d</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 5000:5000 training/webapp python app.py</div><div class="line">33e4523d30aaf0258915c368e66e03b49535de0ef20317d3f639d40222ba6bc0</div></pre></td></tr></table></figure>
<ul>
<li>-P :是容器内部端口随机映射到主机的高端口。</li>
<li>-p : 是容器内部端口绑定到指定的主机端口。</li>
</ul>
<p>使用 docker ps 来看到端口5000绑定主机端口32768。</p>
<p>可以指定容器绑定的网络地址，比如绑定127.0.0.1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 127.0.0.1:5001:5002 training/webapp python app.py</div><div class="line">95c6ceef88ca3e71eaf303c2833fd6701d8d1b2572b5613b5a932dfdfe8a857c</div></pre></td></tr></table></figure></p>
<p>默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 /udp。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</div><div class="line">6779686f06f6204579c1d655dd8b2b31e8e809b245a97b2d3a8e35abe9dcd22a</div></pre></td></tr></table></figure></p>
<p><strong>docker port</strong> 命令可以让我们快捷地查看端口的绑定情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker port adoring_stonebraker 5002</div></pre></td></tr></table></figure></p>
<h2 id="Docker容器连接"><a href="#Docker容器连接" class="headerlink" title="Docker容器连接"></a>Docker容器连接</h2><p>端口映射并不是唯一把 docker 连接到另一个容器的方法。<br>docker有一个连接系统允许将多个容器连接在一起，共享连接信息。<br>docker连接会创建一个父子关系，其中父容器可以看到子容器的信息。  </p>
<h3 id="容器命名"><a href="#容器命名" class="headerlink" title="容器命名"></a>容器命名</h3><p>当我们创建一个容器的时候，docker会自动对它进行命名。另外，我们也可以使用–name标识来命名容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run -d -P --name runoob training/webapp python app.py</div><div class="line">43780a6eabaaf14e590b6e849235c75f3012995403f97749775e38436db9a441</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;网络端口映射&quot;&gt;&lt;a href=&quot;#网络端口映射&quot; class=&quot;headerlink&quot; title=&quot;网络端口映射&quot;&gt;&lt;/a&gt;网络端口映射&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
    
    </summary>
    
      <category term="Cloud&amp;BigData" scheme="http://yoursite.com/categories/Cloud-BigData/"/>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Cloud-BigData/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>05_Docker_命令大全</title>
    <link href="http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/05_Docker_%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/05_Docker_命令大全/</id>
    <published>2017-11-27T06:15:50.000Z</published>
    <updated>2017-11-27T06:15:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="info-version"><a href="#info-version" class="headerlink" title="info | version"></a>info | version</h2><h3 id="info"><a href="#info" class="headerlink" title="info"></a>info</h3><p>docker info : 显示 Docker 系统信息，包括镜像和容器数。。  </p>
<h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>docker version :显示 Docker 版本信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker version [OPTIONS]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-f :指定返回值的模板文件。</li>
</ul>
<h2 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h2><h3 id="login-logout"><a href="#login-logout" class="headerlink" title="login/logout"></a>login/logout</h3><p>docker login : 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub<br>docker logout : 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker login [OPTIONS] [SERVER]</div><div class="line">docker logout [OPTIONS] [SERVER]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-u :登陆的用户名</li>
<li>-p :登陆的密码</li>
</ul>
<p>登陆到Docker Hub<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker login -u 用户名 -p 密码</div></pre></td></tr></table></figure></p>
<p>登出Docker Hub<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker logout</div></pre></td></tr></table></figure></p>
<h3 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h3><p>docker pull : 从镜像仓库中拉取或者更新指定镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull [OPTIONS] NAME[:TAG|@DIGEST]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-a :拉取所有 tagged 镜像</li>
<li>–disable-content-trust :忽略镜像的校验,默认开启</li>
</ul>
<p>从Docker Hub下载java最新版镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull java</div></pre></td></tr></table></figure></p>
<p>从Docker Hub下载REPOSITORY为java的所有镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull -a java</div></pre></td></tr></table></figure></p>
<h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p>docker push : 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker push [OPTIONS] NAME[:TAG]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>–disable-content-trust :忽略镜像的校验,默认开启</li>
</ul>
<p>上传本地镜像myapache:v1到镜像仓库中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker push myapache:v1</div></pre></td></tr></table></figure></p>
<h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>docker search : 从Docker Hub查找镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker search [OPTIONS] TERM</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>–automated :只列出 automated build类型的镜像；</li>
<li>–no-trunc :显示完整的镜像描述；</li>
<li>-s :列出收藏数不小于指定值的镜像。</li>
</ul>
<p>从Docker Hub查找所有镜像名包含java，并且收藏数大于10的镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker search -s 10 java</div></pre></td></tr></table></figure></p>
<h2 id="本地镜像管理"><a href="#本地镜像管理" class="headerlink" title="本地镜像管理"></a>本地镜像管理</h2><h3 id="images"><a href="#images" class="headerlink" title="images"></a>images</h3><p>docker images : 列出本地镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker images [OPTIONS] [REPOSITORY[:TAG]]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</li>
<li>–digests :显示镜像的摘要信息；</li>
<li>-f :显示满足条件的镜像；</li>
<li>–format :指定返回值的模板文件；</li>
<li>–no-trunc :显示完整的镜像信息；</li>
<li>-q :只显示镜像ID。</li>
</ul>
<p>列出本地镜像中REPOSITORY为ubuntu的镜像列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker images  ubuntu</div></pre></td></tr></table></figure></p>
<h3 id="rmi"><a href="#rmi" class="headerlink" title="rmi"></a>rmi</h3><p>docker rmi : 删除本地一个或多少镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-f :强制删除；</li>
<li>–no-prune :不移除该镜像的过程镜像，默认移除；</li>
</ul>
<p>强制删除本地镜像runoob/ubuntu:v4。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rmi -f runoob/ubuntu:v4</div></pre></td></tr></table></figure></p>
<h3 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h3><p>docker tag : 标记本地镜像，将其归入某一仓库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]</div></pre></td></tr></table></figure></p>
<p>将镜像ubuntu:15.10标记为 runoob/ubuntu:v3 镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker tag ubuntu:15.10 runoob/ubuntu:v3</div></pre></td></tr></table></figure></p>
<h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>docker build : 使用Dockerfile创建镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build [OPTIONS] PATH | URL | -</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：  </p>
<ul>
<li>–build-arg=[] :设置镜像创建时的变量；</li>
<li>–cpu-shares :设置 cpu 使用权重；</li>
<li>–cpu-period :限制 CPU CFS周期；</li>
<li>–cpu-quota :限制 CPU CFS配额；</li>
<li>–cpuset-cpus :指定使用的CPU id；</li>
<li>–cpuset-mems :指定使用的内存 id；</li>
<li>–disable-content-trust :忽略校验，默认开启；</li>
<li>-f :指定要使用的Dockerfile路径；</li>
<li>–force-rm :设置镜像过程中删除中间容器；</li>
<li>–isolation :使用容器隔离技术；</li>
<li>–label=[] :设置镜像使用的元数据；</li>
<li>-m :设置内存最大值；</li>
<li>–memory-swap :设置Swap的最大值为内存+swap，”-1”表示不限swap；</li>
<li>–no-cache :创建镜像的过程不使用缓存；</li>
<li>–pull :尝试去更新镜像的新版本；</li>
<li>-q :安静模式，成功后只输出镜像ID；</li>
<li>–rm :设置镜像成功后删除中间容器；</li>
<li>–shm-size :设置/dev/shm的大小，默认值是64M；</li>
<li>–ulimit :Ulimit配置。</li>
</ul>
<p>使用当前目录的Dockerfile创建镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build -t runoob/ubuntu:v1 .</div></pre></td></tr></table></figure></p>
<p>使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build github.com/creack/docker-firefox</div></pre></td></tr></table></figure></p>
<h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>docker history : 查看指定镜像的创建历史。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker history [OPTIONS] IMAGE</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：  </p>
<ul>
<li>-H :以可读的格式打印镜像大小和日期，默认为true；</li>
<li>–no-trunc :显示完整的提交记录；</li>
<li>-q :仅列出提交记录ID。</li>
</ul>
<p>查看本地镜像runoob/ubuntu:v3的创建历史。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker history runoob/ubuntu:v3</div></pre></td></tr></table></figure></p>
<h3 id="save"><a href="#save" class="headerlink" title="save"></a>save</h3><p>docker save : 将指定镜像保存成 tar 归档文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker save [OPTIONS] IMAGE [IMAGE...]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-o :输出到的文件。</li>
</ul>
<p>将镜像runoob/ubuntu:v3 生成my_ubuntu_v3.tar文档<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3</div></pre></td></tr></table></figure></p>
<p>docker 容器导入导出有两种方法：  </p>
<p>一种是使用 save 和 load 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker save ubuntu:load&gt;/root/ubuntu.tar</div><div class="line">docker load&lt;ubuntu.tar</div></pre></td></tr></table></figure></p>
<p>一种是使用 export 和 import 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker export 98ca36&gt; ubuntu.tar</div><div class="line">cat ubuntu.tar | sudo docker import - ubuntu:import</div></pre></td></tr></table></figure></p>
<p>注意两种方法不可混用。</p>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>docker import : 从归档文件中创建镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：  </p>
<ul>
<li>-c :应用docker 指令创建镜像；</li>
<li>-m :提交时的说明文字；</li>
</ul>
<p>从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为runoob/ubuntu:v4<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker import  my_ubuntu_v3.tar runoob/ubuntu:v4</div></pre></td></tr></table></figure></p>
<h2 id="容器生命周期管理"><a href="#容器生命周期管理" class="headerlink" title="容器生命周期管理"></a>容器生命周期管理</h2><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>docker run ：创建一个新的容器并运行一个命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</li>
<li>-d: 后台运行容器，并返回容器ID；</li>
<li>-i: 以交互模式运行容器，通常与 -t 同时使用；</li>
<li>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li>
<li>–name=”nginx-lb”: 为容器指定一个名称；</li>
<li>–dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；</li>
<li>–dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；</li>
<li>-h “mars”: 指定容器的hostname；</li>
<li>-e username=”ritchie”: 设置环境变量；</li>
<li>–env-file=[]: 从指定文件读入环境变量；</li>
<li>–cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行；</li>
<li>-m :设置容器使用内存最大值；</li>
<li>–net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</li>
<li>–link=[]: 添加链接到另一个容器；</li>
<li>–expose=[]: 开放一个端口或一组端口；</li>
</ul>
<p>使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --name mynginx -d nginx:latest</div></pre></td></tr></table></figure></p>
<p>使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -P -d nginx:latest</div></pre></td></tr></table></figure></p>
<p>使用镜像nginx:latest以后台模式启动一个容器,将容器的80端口映射到主机的80端口,主机的目录/data映射到容器的/data。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -p 80:80 -v /data:/data -d nginx:latest</div></pre></td></tr></table></figure></p>
<p>使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -it nginx:latest /bin/bash</div></pre></td></tr></table></figure></p>
<h3 id="start-stop-restart"><a href="#start-stop-restart" class="headerlink" title="start/stop/restart"></a>start/stop/restart</h3><p>docker start :启动一个或多少已经被停止的容器<br>docker stop :停止一个运行中的容器<br>docker restart :重启容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker start [OPTIONS] CONTAINER [CONTAINER...]</div><div class="line">docker stop [OPTIONS] CONTAINER [CONTAINER...]</div><div class="line">docker restart [OPTIONS] CONTAINER [CONTAINER...]</div></pre></td></tr></table></figure></p>
<p>启动已被停止的容器myrunoob<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker start myrunoob</div></pre></td></tr></table></figure></p>
<p>停止运行中的容器myrunoob<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker stop myrunoob</div></pre></td></tr></table></figure></p>
<p>重启容器myrunoob<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker restart myrunoob</div></pre></td></tr></table></figure></p>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>docker kill :杀掉一个运行中的容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker kill [OPTIONS] CONTAINER [CONTAINER...]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-s :向容器发送一个信号</li>
</ul>
<p>杀掉运行中的容器mynginx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker kill -s KILL mynginx</div></pre></td></tr></table></figure></p>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>docker rm ：删除一个或多少容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm [OPTIONS] CONTAINER [CONTAINER...]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-f :通过SIGKILL信号强制删除一个运行中的容器</li>
<li>-l :移除容器间的网络连接，而非容器本身</li>
<li>-v :-v 删除与容器关联的卷</li>
</ul>
<p>强制删除容器db01、db02<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm -f db01、db02</div></pre></td></tr></table></figure></p>
<p>移除容器nginx01对容器db01的连接，连接名db<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm -l db</div></pre></td></tr></table></figure></p>
<p>删除容器nginx01,并删除容器挂载的数据卷<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm -v nginx01</div></pre></td></tr></table></figure></p>
<h3 id="pause-unpause"><a href="#pause-unpause" class="headerlink" title="pause/unpause"></a>pause/unpause</h3><p>docker pause :暂停容器中所有的进程。<br>docker unpause :恢复容器中所有的进程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker pause [OPTIONS] CONTAINER [CONTAINER...]</div><div class="line">docker unpause [OPTIONS] CONTAINER [CONTAINER...]</div></pre></td></tr></table></figure></p>
<p>暂停数据库容器db01提供服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pause db01</div></pre></td></tr></table></figure></p>
<p>恢复数据库容器db01提供服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker unpause db01</div></pre></td></tr></table></figure></p>
<h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><p>docker create ：创建一个新的容器但不启动它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</div></pre></td></tr></table></figure></p>
<p>用法同 docker run</p>
<p>使用docker镜像nginx:latest创建一个容器,并将容器命名为myrunoob<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker create  --name myrunoob  nginx:latest</div></pre></td></tr></table></figure></p>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>docker exec ：在运行的容器中执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-d :分离模式: 在后台运行</li>
<li>-i :即使没有附加也保持STDIN 打开</li>
<li>-t :分配一个伪终端</li>
</ul>
<p>在容器mynginx中以交互模式执行容器内/root/runoob.sh脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker exec -it mynginx /bin/sh /root/runoob.sh</div></pre></td></tr></table></figure></p>
<p>在容器mynginx中开启一个交互模式的终端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker exec -i -t  mynginx /bin/bash</div></pre></td></tr></table></figure></p>
<h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>docker ps : 列出容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker ps [OPTIONS]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-a :显示所有的容器，包括未运行的。</li>
<li>-f :根据条件过滤显示的内容。</li>
<li>–format :指定返回值的模板文件。</li>
<li>-l :显示最近创建的容器。</li>
<li>-n :列出最近创建的n个容器。</li>
<li>–no-trunc :不截断输出。</li>
<li>-q :静默模式，只显示容器编号。</li>
<li>-s :显示总的文件大小。</li>
</ul>
<p>列出所有在运行的容器信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker ps</div></pre></td></tr></table></figure></p>
<p>列出最近创建的5个容器信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker ps -n 5</div></pre></td></tr></table></figure></p>
<p>列出所有创建的容器ID。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker ps -a -q</div></pre></td></tr></table></figure></p>
<h3 id="inspect"><a href="#inspect" class="headerlink" title="inspect"></a>inspect</h3><p>docker inspect : 获取容器/镜像的元数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker inspect [OPTIONS] NAME|ID [NAME|ID...]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：  </p>
<ul>
<li>-f :指定返回值的模板文件。</li>
<li>-s :显示总的文件大小。</li>
<li>–type :为指定类型返回JSON。</li>
</ul>
<p>获取镜像mysql:5.6的元信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker inspect mysql:5.6</div></pre></td></tr></table></figure></p>
<p>获取正在运行的容器mymysql的 IP。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker inspect --format=&apos;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&apos; mymysql  </div><div class="line">172.17.0.3</div></pre></td></tr></table></figure></p>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>docker top :查看容器中运行的进程信息，支持 ps 命令参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker top [OPTIONS] CONTAINER [ps OPTIONS]</div></pre></td></tr></table></figure></p>
<p>容器运行时不一定有/bin/bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程。  </p>
<p>查看容器mymysql的进程信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker top mymysql</div></pre></td></tr></table></figure></p>
<p>查看所有运行容器的进程信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for i in  `docker ps |grep Up|awk &apos;&#123;print $1&#125;&apos;`;do echo \ &amp;&amp;docker top $i; done</div></pre></td></tr></table></figure></p>
<h3 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h3><p>docker attach :连接到正在运行中的容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker attach [OPTIONS] CONTAINER</div></pre></td></tr></table></figure></p>
<p>要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。<br>官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上–sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。  </p>
<p>容器mynginx将访问日志指到标准输出，连接到容器查看访问信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker attach --sig-proxy=false mynginx</div></pre></td></tr></table></figure></p>
<h3 id="events"><a href="#events" class="headerlink" title="events"></a>events</h3><p>docker events : 从服务器获取实时事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker events [OPTIONS]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-f ：根据条件过滤事件；</li>
<li>–since ：从指定的时间戳后显示所有事件;</li>
<li>–until ：流水时间显示到指定的时间为止；</li>
</ul>
<p>显示docker 2016年7月1日后的所有事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker events  --since=&quot;1467302400&quot;</div></pre></td></tr></table></figure></p>
<p>显示docker 镜像为mysql:5.6 2016年7月1日后的相关事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker events -f &quot;image&quot;=&quot;mysql:5.6&quot; --since=&quot;1467302400&quot;</div></pre></td></tr></table></figure></p>
<p>如果指定的时间是到秒级的，需要将时间转成时间戳。如果时间为日期的话，可以直接使用，如–since=”2016-07-01”。  </p>
<h3 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h3><p>docker logs : 获取容器的日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker logs [OPTIONS] CONTAINER</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-f : 跟踪日志输出</li>
<li>–since :显示某个开始时间的所有日志</li>
<li>-t : 显示时间戳</li>
<li>–tail :仅列出最新N条容器日志</li>
</ul>
<p>跟踪查看容器mynginx的日志输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker logs -f mynginx</div></pre></td></tr></table></figure></p>
<p>查看容器mynginx从2016年7月1日后的最新10条日志。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker logs --since=&quot;2016-07-01&quot; --tail=10 mynginx</div></pre></td></tr></table></figure></p>
<h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><p>docker wait : 阻塞运行直到容器停止，然后打印出它的退出代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker wait [OPTIONS] CONTAINER [CONTAINER...]</div></pre></td></tr></table></figure></p>
<h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><p>docker export :将文件系统作为一个tar归档文件导出到STDOUT。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker export [OPTIONS] CONTAINER</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-o :将输入内容写到文件。</li>
</ul>
<p>将id为a404c6c174a2的容器按日期保存为tar文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker export -o mysql-`date +%Y%m%d`.tar a404c6c174a2</div></pre></td></tr></table></figure></p>
<h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><p>docker port :列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]]</div></pre></td></tr></table></figure></p>
<p>查看容器mynginx的端口映射情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker port mymysql</div></pre></td></tr></table></figure></p>
<h2 id="容器rootfs命令"><a href="#容器rootfs命令" class="headerlink" title="容器rootfs命令"></a>容器rootfs命令</h2><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><p>docker commit :从容器创建一个新的镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-a :提交的镜像作者；</li>
<li>-c :使用Dockerfile指令来创建镜像；</li>
<li>-m :提交时的说明文字；</li>
<li>-p :在commit时，将容器暂停。</li>
</ul>
<p>将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker commit -a &quot;runoob.com&quot; -m &quot;my apache&quot; a404c6c174a2  mymysql:v1</div></pre></td></tr></table></figure></p>
<h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>docker cp :用于容器与主机之间的数据拷贝。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</div><div class="line">docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-L :保持源目标中的链接</li>
</ul>
<p>将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker cp /www/runoob 96f7f14e99ab:/www/</div></pre></td></tr></table></figure></p>
<p>将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker cp /www/runoob 96f7f14e99ab:/www</div></pre></td></tr></table></figure></p>
<p>将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker cp  96f7f14e99ab:/www /tmp/</div></pre></td></tr></table></figure></p>
<h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>docker diff : 检查容器里文件结构的更改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker diff [OPTIONS] CONTAINER</div></pre></td></tr></table></figure></p>
<p>查看容器mymysql的文件结构更改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker diff mymysql</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;info-version&quot;&gt;&lt;a href=&quot;#info-version&quot; class=&quot;headerlink&quot; title=&quot;info | version&quot;&gt;&lt;/a&gt;info | version&lt;/h2&gt;&lt;h3 id=&quot;info&quot;&gt;&lt;a href=&quot;#info&quot;
    
    </summary>
    
      <category term="Cloud&amp;BigData" scheme="http://yoursite.com/categories/Cloud-BigData/"/>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Cloud-BigData/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>03_Docker_镜像使用</title>
    <link href="http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/03_Docker_%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/03_Docker_镜像使用/</id>
    <published>2017-11-27T06:15:50.000Z</published>
    <updated>2017-11-27T06:15:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-镜像使用"><a href="#Docker-镜像使用" class="headerlink" title="Docker 镜像使用"></a>Docker 镜像使用</h1><p>当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。  </p>
<h2 id="列出镜像列表"><a href="#列出镜像列表" class="headerlink" title="列出镜像列表"></a>列出镜像列表</h2><p>使用 <strong>docker images</strong> 来列出本地主机上的镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker images           </div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div></pre></td></tr></table></figure></p>
<p>各个选项说明:  </p>
<ul>
<li>REPOSTITORY：表示镜像的仓库源</li>
<li>TAG：镜像的标签</li>
<li>IMAGE ID：镜像ID</li>
<li>CREATED：镜像创建时间</li>
<li>SIZE：镜像大小</li>
</ul>
<p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如ubuntu仓库源里，有15.10、14.04等多个不同的版本，我们使用 REPOSTITORY:TAG 来定义不同的镜像。  </p>
<p>如果不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。</p>
<h2 id="获取一个新的镜像"><a href="#获取一个新的镜像" class="headerlink" title="获取一个新的镜像"></a>获取一个新的镜像</h2><p>当在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果想预先下载这个镜像，可以使用 <strong>docker pull</strong> 命令来下载它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Crunoob@runoob:~$ docker pull ubuntu:13.10</div></pre></td></tr></table></figure></p>
<p>下载完成后，可以直接使用这个镜像来运行容器。</p>
<h2 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h2><p>可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： <a href="https://hub.docker.com/" target="_blank" rel="external">https://hub.docker.com/</a><br>也可以使用 <strong>docker search</strong> 命令来搜索镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$  docker search nginx</div></pre></td></tr></table></figure></p>
<ul>
<li>NAME:镜像仓库源的名称</li>
<li>DESCRIPTION:镜像的描述</li>
<li>OFFICIAL:是否docker官方发布</li>
</ul>
<h2 id="拖取镜像"><a href="#拖取镜像" class="headerlink" title="拖取镜像"></a>拖取镜像</h2><p>使用命令 docker pull 来下载镜像。</p>
<h1 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h1><p>当从docker镜像仓库中下载的镜像不能满足需求时，可以通过以下两种方式对镜像进行更改。  </p>
<ol>
<li>从已经创建的容器中更新镜像，并且提交这个镜像  </li>
<li>使用 Dockerfile 指令来创建一个新的镜像  </li>
</ol>
<h2 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h2><p>更新镜像之前，我们需要使用镜像来创建一个容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker run -i -t ubuntu:15.10 /bin/bash</div><div class="line">root@e218edb10161:/#</div></pre></td></tr></table></figure></p>
<p>在运行的容器内使用 apt-get update 命令进行更新。<br>在完成操作之后，输入 exit命令来退出这个容器。  </p>
<p>此时ID为e218edb10161的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit来提交容器副本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2</div><div class="line">sha256:70bf1840fd7c0d2d8ef0a42a817eb29f854c1af8f7c59fc03ac7bdee9545aff8</div></pre></td></tr></table></figure></p>
<p>各个参数说明：  </p>
<ul>
<li>m:提交的描述信息</li>
<li>a:指定镜像作者</li>
<li>e218edb10161：容器ID</li>
<li>runoob/ubuntu:v2:指定要创建的目标镜像名</li>
</ul>
<p>使用 docker images 命令来查看我们的新镜像 runoob/ubuntu:v2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker images</div></pre></td></tr></table></figure></p>
<p>使用新镜像 runoob/ubuntu 来启动一个容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -i -t runoob/ubuntu:v2 /bin/bash</div></pre></td></tr></table></figure></p>
<h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>使用命令 <strong>docker build</strong> ， 从零开始来创建一个新的镜像。为此，需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建新的镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ cat Dockerfile </div><div class="line">FROM    centos:6.7</div><div class="line">MAINTAINER      Fisher &quot;fisher@sudops.com&quot;</div><div class="line"></div><div class="line">RUN     /bin/echo &apos;root:123456&apos; |chpasswd</div><div class="line">RUN     useradd runoob</div><div class="line">RUN     /bin/echo &apos;runoob:123456&apos; |chpasswd</div><div class="line">RUN     /bin/echo -e &quot;LANG=\&quot;en_US.UTF-8\&quot;&quot; &gt;/etc/default/local</div><div class="line">EXPOSE  22</div><div class="line">EXPOSE  80</div><div class="line">CMD     /usr/sbin/sshd -D</div></pre></td></tr></table></figure></p>
<p>每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。<br>第一条FROM，指定使用哪个镜像源<br>RUN 指令告诉docker 在镜像内执行命令，安装了什么。<br>然后，我们使用 Dockerfile 文件，通过 docker build 命令来构建一个镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker build -t runoob/centos:6.7 .</div><div class="line">Sending build context to Docker daemon 17.92 kB</div><div class="line">Step 1 : FROM centos:6.7</div><div class="line"> ---&amp;gt; d95b5ca17cc3</div><div class="line">Step 2 : MAINTAINER Fisher &quot;fisher@sudops.com&quot;</div><div class="line"> ---&amp;gt; Using cache</div><div class="line"> ---&amp;gt; 0c92299c6f03</div><div class="line">Step 3 : RUN /bin/echo &apos;root:123456&apos; |chpasswd</div><div class="line"> ---&amp;gt; Using cache</div><div class="line"> ---&amp;gt; 0397ce2fbd0a</div><div class="line">Step 4 : RUN useradd runoob</div><div class="line">......</div></pre></td></tr></table></figure></p>
<p>参数说明：  </p>
<ul>
<li>t ：指定要创建的目标镜像名  </li>
<li>. ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径  </li>
</ul>
<p>使用docker images 查看创建的镜像已经在列表中存在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker images</div></pre></td></tr></table></figure></p>
<p>可以使用新的镜像来创建容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker run -t -i runoob/centos:6.7  /bin/bash</div><div class="line">[root@41c28d18b5fb /]# id runoob</div><div class="line">uid=500(runoob) gid=500(runoob) groups=500(runoob)</div></pre></td></tr></table></figure></p>
<h2 id="设置镜像标签"><a href="#设置镜像标签" class="headerlink" title="设置镜像标签"></a>设置镜像标签</h2><p>可以使用 <strong>docker tag</strong> 命令，为镜像添加一个新的标签。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker tag 860c279d2fec runoob/centos:dev</div></pre></td></tr></table></figure></p>
<p>docker tag 镜像ID，这里是 860c279d2fec ,用户名称、镜像源名(repository name)和新的标签名(tag)。  </p>
<p>使用 docker images 命令可以看到，ID为860c279d2fec的镜像多一个标签。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker images</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">runoob/centos       6.7                 860c279d2fec        5 hours ago         190.6 MB</div><div class="line">runoob/centos       dev                 860c279d2fec        5 hours ago         190.6 MB</div></pre></td></tr></table></figure></p>
<h2 id="Docker-容器镜像删除"><a href="#Docker-容器镜像删除" class="headerlink" title="Docker 容器镜像删除"></a>Docker 容器镜像删除</h2><h3 id="停止所有的container，这样才能够删除其中的images："><a href="#停止所有的container，这样才能够删除其中的images：" class="headerlink" title="停止所有的container，这样才能够删除其中的images："></a>停止所有的container，这样才能够删除其中的images：</h3><p>docker stop $(docker ps -a -q)</p>
<p>如果想要删除所有container的话再加一个指令：<br>docker rm $(docker ps -a -q)</p>
<h3 id="查看当前有哪些images"><a href="#查看当前有哪些images" class="headerlink" title="查看当前有哪些images"></a>查看当前有哪些images</h3><p>docker images</p>
<h3 id="删除images，通过image的id来指定删除镜像"><a href="#删除images，通过image的id来指定删除镜像" class="headerlink" title="删除images，通过image的id来指定删除镜像"></a>删除images，通过image的id来指定删除镜像</h3><p>docker rmi <image id=""></image></p>
<p>想要删除untagged images，也就是那些id为<none>的image的话可以用<br>docker rmi $(docker images | grep “^<none>“ | awk “{print $3}”)</none></none></p>
<p>要删除全部image的话<br>docker rmi $(docker images -q)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-镜像使用&quot;&gt;&lt;a href=&quot;#Docker-镜像使用&quot; class=&quot;headerlink&quot; title=&quot;Docker 镜像使用&quot;&gt;&lt;/a&gt;Docker 镜像使用&lt;/h1&gt;&lt;p&gt;当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从
    
    </summary>
    
      <category term="Cloud&amp;BigData" scheme="http://yoursite.com/categories/Cloud-BigData/"/>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Cloud-BigData/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>02_Docker_容器使用</title>
    <link href="http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/02_Docker_%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/02_Docker_容器使用/</id>
    <published>2017-11-27T06:15:50.000Z</published>
    <updated>2017-11-27T06:15:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-容器使用"><a href="#Docker-容器使用" class="headerlink" title="Docker 容器使用"></a>Docker 容器使用</h1><h2 id="Docker-客户端"><a href="#Docker-客户端" class="headerlink" title="Docker 客户端"></a>Docker 客户端</h2><p>可以直接输入 docker 命令来查看到 Docker 客户端的所有命令选项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~# docker</div></pre></td></tr></table></figure></p>
<p><img src="https://i.imgur.com/sjan9rZ.png" alt="">  </p>
<p>可以通过命令 <strong>docker command –help</strong> 更深入的了解指定的 Docker 命令使用方法。<br>例如要查看 docker stats 指令的具体使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~# docker stats --help</div></pre></td></tr></table></figure></p>
<p><img src="https://i.imgur.com/BA4GSFY.png" alt="">  </p>
<h2 id="运行一个web应用"><a href="#运行一个web应用" class="headerlink" title="运行一个web应用"></a>运行一个web应用</h2><p>使用 docker 构建一个 web 应用程序。<br>在docker容器中运行一个 Python Flask 应用来运行一个web应用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~# docker run -d -P training/webapp python app.py</div></pre></td></tr></table></figure></p>
<p>参数说明:</p>
<ul>
<li>d:让容器在后台运行。</li>
<li>P:将容器内部使用的网络端口映射到我们使用的主机上。</li>
</ul>
<h2 id="查看-WEB-应用容器"><a href="#查看-WEB-应用容器" class="headerlink" title="查看 WEB 应用容器"></a>查看 WEB 应用容器</h2><p>使用 <strong>docker ps</strong> 来查看我们正在运行的容器<br>使用 <strong>docker inspect</strong> 命令可以查看更详细的关于某一个容器的信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker ps</div></pre></td></tr></table></figure></p>
<p>多了端口信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PORTS</div><div class="line">0.0.0.0:32769-&gt;5000/tcp</div></pre></td></tr></table></figure></p>
<p>Docker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 32769 上。</p>
<p>也可以指定 -p 标识来绑定指定端口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker run -d -p 5000:5000 training/webapp python app.py</div></pre></td></tr></table></figure></p>
<p>docker ps查看正在运行的容器<br>容器内部的 5000 端口映射到我们本地主机的 5000 端口上。  </p>
<h2 id="网络端口的快捷方式"><a href="#网络端口的快捷方式" class="headerlink" title="网络端口的快捷方式"></a>网络端口的快捷方式</h2><p>通过 <strong>docker ps</strong> 命令可以查看到容器的端口映射<br>docker还提供了另一个快捷方式： <strong>docker port</strong> ,使用 docker port 可以查看指定 （ID或者名字）容器的某个确定端口映射到宿主机的端口号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker port 7a38a1ad55c6</div><div class="line">5000/tcp -&gt; 0.0.0.0:5000</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker port determined_swanson</div><div class="line">5000/tcp -&gt; 0.0.0.0:5000</div></pre></td></tr></table></figure></p>
<h2 id="查看WEB应用程序日志"><a href="#查看WEB应用程序日志" class="headerlink" title="查看WEB应用程序日志"></a>查看WEB应用程序日志</h2><p><strong>docker logs [ID或者名字]</strong> 可以查看容器内部的标准输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker logs -f 7a38a1ad55c6</div><div class="line"> * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</div><div class="line">192.168.239.1 - - [09/May/2016 16:30:37] &quot;GET / HTTP/1.1&quot; 200 -</div><div class="line">192.168.239.1 - - [09/May/2016 16:30:37] &quot;GET /favicon.ico HTTP/1.1&quot; 404 -</div></pre></td></tr></table></figure>
<p>-f:让 dokcer logs 像使用 tail -f 一样来输出容器内部的标准输出。<br>从上面，可以看到应用程序使用的是 5000 端口并且能够查看到应用程序的访问日志。  </p>
<h2 id="查看WEB应用程序容器的进程"><a href="#查看WEB应用程序容器的进程" class="headerlink" title="查看WEB应用程序容器的进程"></a>查看WEB应用程序容器的进程</h2><p>使用 <strong>docker top</strong> 来查看容器内部运行的进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker top determined_swanson</div></pre></td></tr></table></figure></p>
<h2 id="检查WEB应用程序"><a href="#检查WEB应用程序" class="headerlink" title="检查WEB应用程序"></a>检查WEB应用程序</h2><p>使用 <strong>docker inspect</strong> 来查看Docker的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker inspect determined_swanson</div><div class="line">[</div><div class="line">    &#123;</div><div class="line">        &quot;Id&quot;: &quot;7a38a1ad55c6914b360b565819604733db751d86afd2575236a70a2519527361&quot;,</div><div class="line">        &quot;Created&quot;: &quot;2016-05-09T16:20:45.427996598Z&quot;,</div><div class="line">        &quot;Path&quot;: &quot;python&quot;,</div><div class="line">        &quot;Args&quot;: [</div><div class="line">            &quot;app.py&quot;</div><div class="line">        ],</div><div class="line">        &quot;State&quot;: &#123;</div><div class="line">            &quot;Status&quot;: &quot;running&quot;,</div><div class="line">......</div></pre></td></tr></table></figure></p>
<h2 id="停止WEB应用容器"><a href="#停止WEB应用容器" class="headerlink" title="停止WEB应用容器"></a>停止WEB应用容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker stop determined_swanson   </div><div class="line">determined_swanson</div></pre></td></tr></table></figure>
<h2 id="重启WEB应用容器"><a href="#重启WEB应用容器" class="headerlink" title="重启WEB应用容器"></a>重启WEB应用容器</h2><p>已经停止的容器，可以使用命令 docker start 来启动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker start determined_swanson</div><div class="line">determined_swanson</div></pre></td></tr></table></figure></p>
<p>docker ps -l 查询最后一次创建的容器  </p>
<p>正在运行的容器，我们可以使用 docker restart 命令来重启  </p>
<h2 id="移除WEB应用容器"><a href="#移除WEB应用容器" class="headerlink" title="移除WEB应用容器"></a>移除WEB应用容器</h2><p>可以使用 <strong>docker rm</strong> 命令来删除不需要的容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker rm determined_swanson  </div><div class="line">determined_swanson</div></pre></td></tr></table></figure></p>
<p>删除容器时，容器必须是停止状态，否则会报如下错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker rm determined_swanson</div><div class="line">Error response from daemon: You cannot remove a running container 7a38a1ad55c6914b360b565819604733db751d86afd2575236a70a2519527361. Stop the container before attempting removal or use -f</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-容器使用&quot;&gt;&lt;a href=&quot;#Docker-容器使用&quot; class=&quot;headerlink&quot; title=&quot;Docker 容器使用&quot;&gt;&lt;/a&gt;Docker 容器使用&lt;/h1&gt;&lt;h2 id=&quot;Docker-客户端&quot;&gt;&lt;a href=&quot;#Docker-
    
    </summary>
    
      <category term="Cloud&amp;BigData" scheme="http://yoursite.com/categories/Cloud-BigData/"/>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Cloud-BigData/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>01_Docker_Hello_World</title>
    <link href="http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/01_Docker_Hello_World/"/>
    <id>http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/01_Docker_Hello_World/</id>
    <published>2017-11-27T06:15:50.000Z</published>
    <updated>2017-11-27T06:15:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-Hello-World"><a href="#Docker-Hello-World" class="headerlink" title="Docker Hello World"></a>Docker Hello World</h1><p>Docker 允许你在容器内运行应用程序， 使用 docker run 命令来在容器内运行一个应用程序。<br>输出Hello world</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker run ubuntu:15.10 /bin/echo &quot;Hello world&quot;</div><div class="line">Hello world</div></pre></td></tr></table></figure>
<p>各个参数解析：</p>
<ul>
<li>docker: Docker 的二进制执行文件。</li>
<li>run:与前面的 docker 组合来运行一个容器。</li>
<li>ubuntu:15.10指定要运行的镜像，Docker首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。</li>
<li>/bin/echo “Hello world”: 在启动的容器里执行的命令</li>
</ul>
<h1 id="运行交互式的容器"><a href="#运行交互式的容器" class="headerlink" title="运行交互式的容器"></a>运行交互式的容器</h1><p>通过docker的两个参数 -i -t，让docker运行的容器实现”对话”的能力</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker run -i -t ubuntu:15.10 /bin/bash</div><div class="line">root@dc0050c79503:/#</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run –i -t –-name nginx_test[这个名字可以随便起] 904d6c400333[IMAGE ID] /bin/bash</div></pre></td></tr></table></figure>
<p>各个参数解析：</p>
<ul>
<li>t:在新容器内指定一个伪终端或终端。</li>
<li>i:允许你对容器内的标准输入 (STDIN) 进行交互。</li>
</ul>
<p>此时已进入一个 ubuntu15.10系统的容器<br>尝试在容器中运行命令 cat /proc/version和ls分别查看当前系统的版本信息和当前目录下的文件列表<br><img src="https://i.imgur.com/oiv1hkR.png" alt=""><br>可以通过运行exit命令或者使用CTRL+D来退出容器。</p>
<h1 id="启动容器（后台模式）"><a href="#启动容器（后台模式）" class="headerlink" title="启动容器（后台模式）"></a>启动容器（后台模式）</h1><p>使用以下命令创建一个以进程方式运行的容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker run -d ubuntu:15.10 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</div><div class="line">2b1b7a428627c51ab8810d541d759f072b4fc75487eed05812646b8534a2fe63</div></pre></td></tr></table></figure></p>
<p>在输出中，我们没有看到期望的”hello world”，而是一串长字符<br>2b1b7a428627c51ab8810d541d759f072b4fc75487eed05812646b8534a2fe63<br>这个长字符串叫做容器ID，对每个容器来说都是唯一的，我们可以通过容器ID来查看对应的容器发生了什么。<br>首先，我们需要确认容器有在运行，可以通过 <strong>docker ps</strong> 来查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker ps</div></pre></td></tr></table></figure></p>
<p>CONTAINER ID:容器ID<br>NAMES:自动分配的容器名称</p>
<p>在容器内使用 <strong>docker logs</strong> 命令，查看容器内的标准输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker logs 2b1b7a428627</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker logs amazing_cori</div></pre></td></tr></table></figure></p>
<h1 id="git-bash连接"><a href="#git-bash连接" class="headerlink" title="git-bash连接"></a>git-bash连接</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine ssh default</div></pre></td></tr></table></figure>
<h1 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h1><p>使用 <strong>docker stop</strong> 命令来停止容器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker stop 2b1b7a428627</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker logs amazing_cori</div></pre></td></tr></table></figure></p>
<p>通过docker ps查看，容器已经停止工作:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker ps</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-Hello-World&quot;&gt;&lt;a href=&quot;#Docker-Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Docker Hello World&quot;&gt;&lt;/a&gt;Docker Hello World&lt;/h1&gt;&lt;p&gt;Docker
    
    </summary>
    
      <category term="Cloud&amp;BigData" scheme="http://yoursite.com/categories/Cloud-BigData/"/>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Cloud-BigData/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>04_Java并发篇_死锁</title>
    <link href="http://yoursite.com/2017/07/29/Backend/Java/concurrence/04_Java%E5%B9%B6%E5%8F%91%E7%AF%87_%E6%AD%BB%E9%94%81/"/>
    <id>http://yoursite.com/2017/07/29/Backend/Java/concurrence/04_Java并发篇_死锁/</id>
    <published>2017-07-29T12:57:13.000Z</published>
    <updated>2017-07-29T12:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>死锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。  </p>
<p>例如：<br>如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这时死锁就发生了。<br>线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。  </p>
<h1 id="数据库的死锁"><a href="#数据库的死锁" class="headerlink" title="数据库的死锁"></a>数据库的死锁</h1><p>更加复杂的死锁场景发生在数据库事务中。一个数据库事务可能由多条SQL更新请求组成。<br><strong>当在一个事务中更新一条记录，这条记录就会被锁住避免其他事务的更新请求，直到第一个事务结束。</strong><br>同一个事务中每一个更新请求都可能会锁住一些记录。  </p>
<p>当多个事务同时需要对一些相同的记录做更新操作时，就很有可能发生死锁，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Transaction 1, request 1, locks record 1 for update</div><div class="line">Transaction 2, request 1, locks record 2 for update</div><div class="line">Transaction 1, request 2, tries to lock record 2 for update.</div><div class="line">Transaction 2, request 2, tries to lock record 1 for update.</div></pre></td></tr></table></figure></p>
<p>因为锁发生在不同的请求中，并且对于一个事务来说不可能提前知道所有它需要的锁，因此很难检测和避免数据库事务中的死锁。  </p>
<h1 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h1><p>在有些情况下死锁是可以避免的。  </p>
<ol>
<li>加锁顺序</li>
<li>加锁时限</li>
<li>死锁检测</li>
</ol>
<h2 id="加锁顺序"><a href="#加锁顺序" class="headerlink" title="加锁顺序"></a>加锁顺序</h2><p>当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。  </p>
<p>如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Thread 1:</div><div class="line">  lock A </div><div class="line">  lock B</div><div class="line">  </div><div class="line">Thread 2:</div><div class="line">   wait for A</div><div class="line">   lock C (when A locked)</div><div class="line">  </div><div class="line">Thread 3:</div><div class="line">   wait for A</div><div class="line">   wait for B</div><div class="line">   wait for C</div></pre></td></tr></table></figure></p>
<p>按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁(译者注：并对这些锁做适当的排序)，但总有些时候是无法预知的。  </p>
<h2 id="加锁时限"><a href="#加锁时限" class="headerlink" title="加锁时限"></a>加锁时限</h2><p>另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。<br>若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。  </p>
<p>这段随机的等待时间让其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行(注：加锁超时后可以先继续运行干点其它事情，再回头来重复之前加锁的逻辑)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Thread 1 locks A</div><div class="line">Thread 2 locks B</div><div class="line">  </div><div class="line">Thread 1 attempts to lock B but is blocked</div><div class="line">Thread 2 attempts to lock A but is blocked</div><div class="line">  </div><div class="line">Thread 1&apos;s lock attempt on B times out</div><div class="line">Thread 1 backs up and releases A as well</div><div class="line">Thread 1 waits randomly (e.g. 257 millis) before retrying.</div><div class="line">  </div><div class="line">Thread 2&apos;s lock attempt on A times out</div><div class="line">Thread 2 backs up and releases B as well</div><div class="line">Thread 2 waits randomly (e.g. 43 millis) before retrying.</div></pre></td></tr></table></figure></p>
<p>需要注意的是，由于存在锁的超时，所以我们不能认为这种场景就一定是出现了死锁。也可能是因为获得了锁的线程（导致其它线程超时）需要很长的时间去完成它的任务。  </p>
<p>此外，如果有非常多的线程同一时间去竞争同一批资源，就算有超时和回退机制，还是可能会导致这些线程重复地尝试但却始终得不到锁。如果只有两个线程，并且重试的超时时间设定为0到500毫秒之间，这种现象可能不会发生，但是如果是10个或20个线程情况就不同了。因为这些线程等待相等的重试时间的概率就高的多（或者非常接近以至于会出现问题）。  </p>
<h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><p>死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。  </p>
<p>每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。  </p>
<p>当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。例如，线程A请求锁7，但是锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前所持有的锁。如果线程B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线程B拥有锁7，请求锁1）。  </p>
<p>当然，死锁一般要比两个线程互相持有对方的锁这种情况要复杂的多。线程A等待线程B，线程B等待线程C，线程C等待线程D，线程D又在等待线程A。线程A为了检测死锁，它需要递进地检测所有被B请求的锁。从线程B所请求的锁开始，线程A找到了线程C，然后又找到了线程D，发现线程D请求的锁被线程A自己持有着。这是它就知道发生了死锁。  </p>
<p>可以被用来检测死锁的数据结构。<br><img src="http://i.imgur.com/wW4vN5G.png" alt="">  </p>
<p>那么当检测出死锁时，这些线程该做些什么呢？  </p>
<p>一个可行的做法是释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁（编者注：原因同超时类似，不能从根本上减轻竞争）。  </p>
<p>一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁&quot;&gt;&lt;/a&gt;死锁&lt;/h1&gt;&lt;p&gt;死锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。  &lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/"/>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>01_Java并发篇_前言</title>
    <link href="http://yoursite.com/2017/07/29/Backend/Java/concurrence/01_Java%E5%B9%B6%E5%8F%91%E7%AF%87_%E5%89%8D%E8%A8%80/"/>
    <id>http://yoursite.com/2017/07/29/Backend/Java/concurrence/01_Java并发篇_前言/</id>
    <published>2017-07-29T12:57:13.000Z</published>
    <updated>2017-07-29T12:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>并发很重要的，前言中记录事件与体会</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并发很重要的，前言中记录事件与体会&lt;/p&gt;

    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/"/>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>02_Java并发篇_线程状态_Java内存模型</title>
    <link href="http://yoursite.com/2017/07/29/Backend/Java/concurrence/02_Java%E5%B9%B6%E5%8F%91%E7%AF%87_%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81_Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2017/07/29/Backend/Java/concurrence/02_Java并发篇_线程状态_Java内存模型/</id>
    <published>2017-07-29T12:57:13.000Z</published>
    <updated>2017-07-29T12:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><p>Java中，线程的状态有以下6类：NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED。  </p>
<p><img src="http://i.imgur.com/6UG5qH5.png" alt="">  </p>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>Java内存模型把Java虚拟机内部划分为线程栈和堆。  </p>
<p>每一个运行在Java虚拟机里的线程都拥有自己的线程栈。  </p>
<p>一个线程仅能访问自己的线程栈。一个线程创建的本地变量对其它线程不可见，仅自己可见。  </p>
<p>即使两个线程执行同样的代码，这两个线程任然在在自己的线程栈中的代码来创建本地变量。因此，每个线程拥有每个本地变量的独有版本。  </p>
<p>所有原始类型的本地变量都存放在线程栈上，因此对其它线程不可见。一个线程可能向另一个线程传递一个原始类型变量的拷贝，但是它不能共享这个原始类型变量自身。  </p>
<p>堆上包含在Java程序中创建的所有对象，无论是哪一个对象创建的。这包括原始类型的对象版本。如果一个对象被创建然后赋值给一个局部变量，或者用来作为另一个对象的成员变量，这个对象任然是存放在堆上。  </p>
<p><img src="http://i.imgur.com/KkNgaH3.png" alt="">  </p>
<p>一个本地变量可能是原始类型，在这种情况下，它总是“呆在”线程栈上。  </p>
<p>一个本地变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。  </p>
<p>一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量任然存放在线程栈上，即使这些方法所属的对象存放在堆上。  </p>
<p><strong>一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。</strong>  </p>
<p><strong>静态成员变量跟随着类定义一起也存放在堆上。</strong></p>
<p>存放在堆上的对象可以被所有持有对这个对象引用的线程访问。<br>当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。<br>如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个本地变量的私有拷贝。<br><img src="http://i.imgur.com/P8Qadbg.png" alt="">  </p>
<h1 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a>硬件内存架构</h1><p><img src="http://i.imgur.com/N1SOkpH.png" alt="">  </p>
<p>每个CPU都包含一系列的寄存器，它们是CPU内内存的基础。CPU在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为CPU访问寄存器的速度远大于主存。  </p>
<p>每个CPU可能还有一个CPU缓存层。实际上，绝大多数的现代CPU都有一定大小的缓存层。  </p>
<p>共享对象被初始化在主存中。跑在CPU上的一个线程将这个共享对象读到CPU缓存中。然后修改了这个对象。只要CPU缓存没有被刷新会主存，对象修改后的版本对跑在其它CPU上的线程都是不可见的。这种方式可能导致每个线程拥有这个共享对象的私有拷贝，每个拷贝停留在不同的CPU缓存中。  </p>
<p>跑在左边CPU的线程拷贝这个共享对象到它的CPU缓存中，然后将count变量的值修改为2。这个修改对跑在右边CPU上的其它线程是不可见的，因为修改后的count的值还没有被刷新回主存中去。<br><img src="http://i.imgur.com/aIckfGe.png" alt=""><br>解决这个问题你可以使用Java中的volatile关键字。volatile关键字可以保证直接从主存中读取一个变量，如果这个变量被修改后，总是会被写回到主存中去。  </p>
<h2 id="Race-Conditions"><a href="#Race-Conditions" class="headerlink" title="Race Conditions"></a>Race Conditions</h2><p>如果两个或者更多的线程共享一个对象，多个线程在这个共享对象上更新变量，就有可能发生race conditions。</p>
<p>如果线程A读一个共享对象的变量count到它的CPU缓存中。线程B也做了同样的事情，但是往一个不同的CPU缓存中。现在线程A将count加1，线程B也做了同样的事情。现在count已经被增在了两个，每个CPU缓存中一次。</p>
<p>如果这些增加操作被顺序的执行，变量count应该被增加两次，然后原值+2被写回到主存中去。</p>
<p>然而，两次增加都是在没有适当的同步下并发执行的。无论是线程A还是线程B将count修改后的版本写回到主存中取，修改后的值仅会被原值大1，尽管增加了两次。</p>
<p><img src="http://i.imgur.com/zfLpW4r.png" alt="">  </p>
<p>解决这个问题可以使用Java同步块。<br><strong>一个同步块可以保证在同一时刻仅有一个线程可以进入代码的临界区。</strong><br>同步块还可以保证代码块中所有被访问的变量将会从主存中读入，当线程退出同步代码块时，所有被更新的变量都会被刷新回主存中去，不管这个变量是否被声明为volatile。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线程的状态&quot;&gt;&lt;a href=&quot;#线程的状态&quot; class=&quot;headerlink&quot; title=&quot;线程的状态&quot;&gt;&lt;/a&gt;线程的状态&lt;/h1&gt;&lt;p&gt;Java中，线程的状态有以下6类：NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WA
    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/"/>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>03_Java并发篇_Java同步块</title>
    <link href="http://yoursite.com/2017/07/29/Backend/Java/concurrence/03_Java%E5%B9%B6%E5%8F%91%E7%AF%87_Java%E5%90%8C%E6%AD%A5%E5%9D%97/"/>
    <id>http://yoursite.com/2017/07/29/Backend/Java/concurrence/03_Java并发篇_Java同步块/</id>
    <published>2017-07-29T12:57:13.000Z</published>
    <updated>2017-07-29T12:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-同步关键字（synchronized）"><a href="#Java-同步关键字（synchronized）" class="headerlink" title="Java 同步关键字（synchronized）"></a>Java 同步关键字（synchronized）</h1><p>Java中的同步块用synchronized标记。同步块在Java中是同步在某个对象上。所有同步在一个对象上的同步块在同时只能被一个线程进入并执行操作。所有其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出。  </p>
<p>有四种不同的同步块：  </p>
<ol>
<li>实例方法</li>
<li>静态方法</li>
<li>实例方法中的同步块</li>
<li>静态方法中的同步块</li>
</ol>
<h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><p>1、通过共享对象通信</p>
<p>2、忙等待</p>
<p>3、wait(),notify()和notifyAll()</p>
<p>4、丢失的信号</p>
<p>5、不要对常量字符串或全局对象调用wait()</p>
<h2 id="通过共享对象通信"><a href="#通过共享对象通信" class="headerlink" title="通过共享对象通信"></a>通过共享对象通信</h2><p>线程间发送信号的一个简单方式是在共享对象的变量里设置信号值。线程A在一个同步块里设置boolean型成员变量hasDataToProcess为true，线程B也在同步块里读取hasDataToProcess这个成员变量。这个简单的例子使用了一个持有信号的对象，并提供了set和check方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class MySignal&#123;</div><div class="line">  </div><div class="line">  protected boolean hasDataToProcess = false;</div><div class="line">  </div><div class="line">  public synchronized boolean hasDataToProcess()&#123;</div><div class="line">    return this.hasDataToProcess;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  public synchronized void setHasDataToProcess(boolean hasData)&#123;</div><div class="line">    this.hasDataToProcess = hasData;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>线程A和B必须获得指向一个MySignal共享实例的引用，以便进行通信。如果它们持有的引用指向不同的MySingal实例，那么彼此将不能检测到对方的信号。需要处理的数据可以存放在一个共享缓存区里，它和MySignal实例是分开存放的。</p>
<h2 id="忙等待-Busy-Wait"><a href="#忙等待-Busy-Wait" class="headerlink" title="忙等待(Busy Wait)"></a>忙等待(Busy Wait)</h2><p>准备处理数据的线程B正在等待数据变为可用。换句话说，它在等待线程A的一个信号，这个信号使hasDataToProcess()返回true。线程B运行在一个循环里，以等待这个信号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">protected MySignal sharedSignal = ...</div><div class="line">...</div><div class="line">while(!sharedSignal.hasDataToProcess())&#123;</div><div class="line">  //do nothing... busy waiting</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="wait-notify-和notifyAll"><a href="#wait-notify-和notifyAll" class="headerlink" title="wait(),notify()和notifyAll()"></a>wait(),notify()和notifyAll()</h2><p>忙等待没有对运行等待线程的CPU进行有效的利用。否则，让等待线程进入睡眠或者非运行状态更为明智，直到它接收到它等待的信号。</p>
<p>忙等待没有对运行等待线程的CPU进行有效的利用，除非平均等待时间非常短。否则，让等待线程进入睡眠或者非运行状态更为明智，直到它接收到它等待的信号。  </p>
<p>Java有一个内建的等待机制来允许线程在等待信号的时候变为非运行状态。java.lang.Object 类定义了三个方法，wait()、notify()和notifyAll()来实现这个等待机制。  </p>
<p>一个线程一旦调用了任意对象的wait()方法，就会变为非运行状态，直到另一个线程调用了同一个对象的notify()方法。为了调用wait()或者notify()，线程必须先获得那个对象的锁。也就是说，线程必须在同步块里调用wait()或者notify()。  </p>
<p>当一个线程调用一个对象的notify()方法，正在等待该对象的所有线程中将有一个线程被唤醒并允许执行（校注：这个将被唤醒的线程是随机的，不可以指定唤醒哪个线程）。同时也提供了一个notifyAll()方法来唤醒正在等待一个给定对象的所有线程。  </p>
<blockquote>
<p>JVM是这么实现的，当你调用wait时候它首先要检查下当前线程是否是锁的拥有者，不是则抛出IllegalMonitorStateExcept，参考JVM源码的 1422行。  </p>
</blockquote>
<p>一旦一个线程被唤醒，不能立刻就退出wait()的方法调用，直到调用notify()的线程退出了它自己的同步块。换句话说：被唤醒的线程必须重新获得监视器对象的锁，才可以退出wait()的方法调用，因为wait方法调用运行在同步块里面。如果多个线程被notifyAll()唤醒，那么在同一时刻将只有一个线程可以退出wait()方法，因为每个线程在退出wait()前必须获得监视器对象的锁。  </p>
<h2 id="丢失的信号（Missed-Signals）"><a href="#丢失的信号（Missed-Signals）" class="headerlink" title="丢失的信号（Missed Signals）"></a>丢失的信号（Missed Signals）</h2><p>notify()和notifyAll()方法不会保存调用它们的方法，因为当这两个方法被调用时，有可能没有线程处于等待状态。通知信号过后便丢弃了。因此，如果一个线程先于被通知线程调用wait()前调用了notify()，等待的线程将错过这个信号。这可能是也可能不是个问题。不过，在某些情况下，这可能使等待线程永远在等待，不再醒来，因为线程错过了唤醒信号。<br>为了避免丢失信号，必须把它们保存在信号类里。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class MyWaitNotify2&#123;</div><div class="line">  </div><div class="line">  MonitorObject myMonitorObject = new MonitorObject();</div><div class="line">  boolean wasSignalled = false;</div><div class="line">  </div><div class="line">  public void doWait()&#123;</div><div class="line">    synchronized(myMonitorObject)&#123;</div><div class="line">      if(!wasSignalled)&#123;</div><div class="line">        try&#123;</div><div class="line">          myMonitorObject.wait();</div><div class="line">         &#125; catch(InterruptedException e)&#123;...&#125;</div><div class="line">      &#125;</div><div class="line">      //clear signal and continue running.</div><div class="line">      wasSignalled = false;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  public void doNotify()&#123;</div><div class="line">    synchronized(myMonitorObject)&#123;</div><div class="line">      wasSignalled = true;</div><div class="line">      myMonitorObject.notify();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>留意doNotify()方法在调用notify()前把wasSignalled变量设为true。同时，留意doWait()方法在调用wait()前会检查wasSignalled变量。事实上，如果没有信号在前一次doWait()调用和这次doWait()调用之间的时间段里被接收到，它将只调用wait()。  </p>
<p>（为了避免信号丢失， 用一个变量来保存是否被通知过。在notify前，设置自己已经被通知过。在wait后，设置自己没有被通知过，需要等待通知。）  </p>
<h2 id="不要在字符串常量或全局对象中调用wait"><a href="#不要在字符串常量或全局对象中调用wait" class="headerlink" title="不要在字符串常量或全局对象中调用wait()"></a>不要在字符串常量或全局对象中调用wait()</h2><p>JVM/编译器内部会把常量字符串转换成同一个对象。这意味着，即使你有2个不同的MyWaitNotify实例，它们都引用了相同的空字符串实例。  </p>
<p>在wait()/notify()机制中，不要使用全局对象，字符串常量等。应该使用对应唯一的对象。  </p>
<p>管程 (Monitors，也称为监视器) 是对多个工作线程实现互斥访问共享资源的对象或模块。这些共享资源一般是硬件设备或一群变量。管程实现了在一个时间点，最多只有一个线程在执行它的某个子程序。与那些通过修改数据结构实现互斥访问的并发程序设计相比，管程很大程度上简化了程序设计。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-同步关键字（synchronized）&quot;&gt;&lt;a href=&quot;#Java-同步关键字（synchronized）&quot; class=&quot;headerlink&quot; title=&quot;Java 同步关键字（synchronized）&quot;&gt;&lt;/a&gt;Java 同步关键字（syn
    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/"/>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>05_Java并发篇_饥饿与公平</title>
    <link href="http://yoursite.com/2017/07/29/Backend/Java/concurrence/05_Java%E5%B9%B6%E5%8F%91%E7%AF%87_%E9%A5%A5%E9%A5%BF%E4%B8%8E%E5%85%AC%E5%B9%B3/"/>
    <id>http://yoursite.com/2017/07/29/Backend/Java/concurrence/05_Java并发篇_饥饿与公平/</id>
    <published>2017-07-29T12:57:13.000Z</published>
    <updated>2017-07-29T12:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="饥饿和公平"><a href="#饥饿和公平" class="headerlink" title="饥饿和公平"></a>饥饿和公平</h1><p>如果一个线程因为CPU时间全部被其他线程抢走而得不到CPU运行时间，这种状态被称之为“饥饿”。<br>而该线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。<br>解决饥饿的方案被称之为“公平性” – 即所有线程均能公平地获得运行机会。  </p>
<h2 id="Java中导致饥饿的原因："><a href="#Java中导致饥饿的原因：" class="headerlink" title="Java中导致饥饿的原因："></a>Java中导致饥饿的原因：</h2><ol>
<li><p>高优先级线程吞噬所有的低优先级线程的CPU时间。  </p>
</li>
<li><p>线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。  </p>
</li>
<li><p>线程在等待一个本身(在其上调用wait())也处于永久等待完成的对象，因为其他线程总是被持续地获得唤醒。  </p>
</li>
</ol>
<p>如果多个线程处在wait()方法执行上，而对其调用notify()不会保证哪一个线程会获得唤醒，任何线程都有可能处于继续等待的状态。因此存在这样一个风险：一个等待线程从来得不到唤醒，因为其他等待线程总是能被获得唤醒。</p>
<h3 id="高优先级线程吞噬所有的低优先级线程的CPU时间"><a href="#高优先级线程吞噬所有的低优先级线程的CPU时间" class="headerlink" title="高优先级线程吞噬所有的低优先级线程的CPU时间"></a>高优先级线程吞噬所有的低优先级线程的CPU时间</h3><p>你能为每个线程设置独自的线程优先级，优先级越高的线程获得的CPU时间越多，线程优先级值设置在1到10之间，而这些优先级值所表示行为的准确解释则依赖于你的应用运行平台。对大多数应用来说，你最好是不要改变其优先级值。  </p>
<h3 id="线程被永久堵塞在一个等待进入同步块的状态"><a href="#线程被永久堵塞在一个等待进入同步块的状态" class="headerlink" title="线程被永久堵塞在一个等待进入同步块的状态"></a>线程被永久堵塞在一个等待进入同步块的状态</h3><p>Java的同步代码区也是一个导致饥饿的因素。Java的同步代码区对哪个线程允许进入的次序没有任何保障。这就意味着理论上存在一个试图进入该同步区的线程处于被永久堵塞的风险，因为其他线程总是能持续地先于它获得访问，这即是“饥饿”问题，而一个线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。  </p>
<h3 id="线程在等待一个本身-在其上调用wait-也处于永久等待完成的对象"><a href="#线程在等待一个本身-在其上调用wait-也处于永久等待完成的对象" class="headerlink" title="线程在等待一个本身(在其上调用wait())也处于永久等待完成的对象"></a>线程在等待一个本身(在其上调用wait())也处于永久等待完成的对象</h3><p>如果多个线程处在wait()方法执行上，而对其调用notify()不会保证哪一个线程会获得唤醒，任何线程都有可能处于继续等待的状态。因此存在这样一个风险：一个等待线程从来得不到唤醒，因为其他等待线程总是能被获得唤醒。  </p>
<h2 id="在Java中实现公平性方案"><a href="#在Java中实现公平性方案" class="headerlink" title="在Java中实现公平性方案"></a>在Java中实现公平性方案</h2><ol>
<li>使用锁，而不是同步块。</li>
<li>公平锁。</li>
<li>注意性能方面。</li>
</ol>
<p>Java不可能实现100%的公平性，我们依然可以通过同步结构在线程间实现公平性的提高。</p>
<h3 id="同步态代码"><a href="#同步态代码" class="headerlink" title="同步态代码"></a>同步态代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class Synchronizer&#123;</div><div class="line">  </div><div class="line">    public synchronized void doSynchronized()&#123;</div><div class="line">        //do a lot of work which takes a long time</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果有一个以上的线程调用doSynchronized()方法，在第一个获得访问的线程未完成前，其他线程将一直处于阻塞状态，而且在这种多线程被阻塞的场景下，接下来将是哪个线程获得访问是没有保障的。  </p>
<h3 id="使用锁方式替代同步块"><a href="#使用锁方式替代同步块" class="headerlink" title="使用锁方式替代同步块"></a>使用锁方式替代同步块</h3><p>为了提高等待线程的公平性，使用锁方式来替代同步块。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Synchronizer&#123;</div><div class="line">    Lock lock = new Lock();</div><div class="line">    public void doSynchronized() throws InterruptedException&#123;</div><div class="line">        this.lock.lock();</div><div class="line">        //critical section, do a lot of work which takes a long time</div><div class="line">        this.lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>doSynchronized()不再声明为synchronized，而是用lock.lock()和lock.unlock()来替代。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class Lock&#123;</div><div class="line">  </div><div class="line">    private boolean isLocked      = false;</div><div class="line">    private Thread lockingThread = null;</div><div class="line">  </div><div class="line">    public synchronized void lock() throws InterruptedException&#123;</div><div class="line">  </div><div class="line">        while(isLocked)&#123;</div><div class="line">            wait();</div><div class="line">        &#125;</div><div class="line">  </div><div class="line">        isLocked = true;</div><div class="line">        lockingThread = Thread.currentThread();</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    public synchronized void unlock()&#123;</div><div class="line">  </div><div class="line">        if(this.lockingThread != Thread.currentThread())&#123;</div><div class="line">  </div><div class="line">             throw new IllegalMonitorStateException(</div><div class="line">                  &quot;Calling thread has not locked this lock&quot;);</div><div class="line">             &#125;</div><div class="line">  </div><div class="line">        isLocked = false;</div><div class="line">        lockingThread = null;</div><div class="line">        notify();</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果存在多线程并发访问lock()，这些线程将阻塞在对lock()方法的访问上。另外，如果锁已经锁上（校对注：这里指的是isLocked等于true时），这些线程将阻塞在while(isLocked)循环的wait()调用里面。要记住的是，当线程正在等待进入lock() 时，可以调用wait()释放其锁实例对应的同步锁，使得其他多个线程可以进入lock()方法，并调用wait()方法。  </p>
<p>在lock()和unlock()之间：在这两个调用之间的代码将运行很长一段时间。进一步设想，这段代码将长时间运行，和进入lock()并调用wait()来比较的话。这意味着大部分时间用在等待进入锁和进入临界区的过程是用在wait()的等待中，而不是被阻塞在试图进入lock()方法中。  </p>
<p>同步块不会对等待进入的多个线程谁能获得访问做任何保障，同样当调用notify()时，也不会做保障一定能唤醒线程。因此这个的Lock类和doSynchronized()那个就保障公平性而言，没有任何区别。</p>
<p>但是，如果每个线程在不同的对象上调用wait()，那么只有一个线程会在该对象上调用wait()，Lock类可以决定哪个对象能对其调用notify()，因此能做到有效的选择唤醒哪个线程。</p>
<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>每一个调用lock()的线程都会进入一个队列，当解锁后，只有队列里的第一个线程被允许锁住Farlock实例，所有其它的线程都将处于等待状态，直到他们处于队列头部。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public class FairLock &#123;</div><div class="line">    private boolean           isLocked       = false;</div><div class="line">    private Thread            lockingThread  = null;</div><div class="line">    private List&lt;QueueObject&gt; waitingThreads = new ArrayList&lt;QueueObject&gt;();</div><div class="line"></div><div class="line">  public void lock() throws InterruptedException&#123;</div><div class="line">    QueueObject queueObject = new QueueObject();</div><div class="line">    boolean isLockedForThisThread = true;</div><div class="line">    synchronized(this)&#123;</div><div class="line">        waitingThreads.add(queueObject);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    while(isLockedForThisThread)&#123;</div><div class="line">      synchronized(this)&#123;</div><div class="line">        isLockedForThisThread =</div><div class="line">            isLocked || waitingThreads.get(0) != queueObject;</div><div class="line">        if(!isLockedForThisThread)&#123;</div><div class="line">          isLocked = true;</div><div class="line">           waitingThreads.remove(queueObject);</div><div class="line">           lockingThread = Thread.currentThread();</div><div class="line">           return;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      try&#123;</div><div class="line">        queueObject.doWait();</div><div class="line">      &#125;catch(InterruptedException e)&#123;</div><div class="line">        synchronized(this) &#123; waitingThreads.remove(queueObject); &#125;</div><div class="line">        throw e;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  public synchronized void unlock()&#123;</div><div class="line">    if(this.lockingThread != Thread.currentThread())&#123;</div><div class="line">      throw new IllegalMonitorStateException(</div><div class="line">        &quot;Calling thread has not locked this lock&quot;);</div><div class="line">    &#125;</div><div class="line">    isLocked      = false;</div><div class="line">    lockingThread = null;</div><div class="line">    if(waitingThreads.size() &gt; 0)&#123;</div><div class="line">      waitingThreads.get(0).doNotify();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class QueueObject &#123;</div><div class="line">  </div><div class="line">    private boolean isNotified = false;</div><div class="line">  </div><div class="line">    public synchronized void doWait() throws InterruptedException &#123;</div><div class="line"></div><div class="line">        while(!isNotified)&#123;</div><div class="line">            this.wait();</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        this.isNotified = false;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    public synchronized void doNotify() &#123;</div><div class="line">        this.isNotified = true;</div><div class="line">        this.notify();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public boolean equals(Object o) &#123;</div><div class="line">        return this == o;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>lock()方法不在声明为synchronized，取而代之的是对必需同步的代码，在synchronized中进行嵌套。  </p>
<p>FairLock新创建了一个QueueObject的实例，并对每个调用lock()的线程进行入队列。调用unlock()的线程将从队列头部获取QueueObject，并对其调用doNotify()，以唤醒在该对象上等待的线程。通过这种方式，在同一时间仅有一个等待线程获得唤醒，而不是所有的等待线程。这也是实现FairLock公平性的核心所在。  </p>
<p>请注意，在同一个同步块中，锁状态依然被检查和设置，以避免出现滑漏条件。  </p>
<p>还需注意到，QueueObject实际是一个semaphore。doWait()和doNotify()方法在QueueObject中保存着信号。这样做以避免一个线程在调用queueObject.doWait()之前被另一个调用unlock()并随之调用queueObject.doNotify()的线程重入，从而导致信号丢失。queueObject.doWait()调用放置在synchronized(this)块之外，以避免被monitor嵌套锁死，所以另外的线程可以解锁，只要当没有线程在lock方法的synchronized(this)块中执行即可。  </p>
<p>最后，注意到queueObject.doWait()在try – catch块中是怎样调用的。在InterruptedException抛出的情况下，线程得以离开lock()，并需让它从队列中移除。  </p>
<h3 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h3><p>如果比较Lock和FairLock类，你会注意到在FairLock类中lock()和unlock()还有更多需要深入的地方。这些额外的代码会导致FairLock的同步机制实现比Lock要稍微慢些。究竟存在多少影响，还依赖于应用在FairLock临界区执行的时长。执行时长越大，FairLock带来的负担影响就越小，当然这也和代码执行的频繁度相关。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;饥饿和公平&quot;&gt;&lt;a href=&quot;#饥饿和公平&quot; class=&quot;headerlink&quot; title=&quot;饥饿和公平&quot;&gt;&lt;/a&gt;饥饿和公平&lt;/h1&gt;&lt;p&gt;如果一个线程因为CPU时间全部被其他线程抢走而得不到CPU运行时间，这种状态被称之为“饥饿”。&lt;br&gt;而该线程被“饥
    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/"/>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>01_Java容器篇_前言</title>
    <link href="http://yoursite.com/2017/07/29/Backend/Java/container/01_Java%E5%AE%B9%E5%99%A8%E7%AF%87_%E5%89%8D%E8%A8%80/"/>
    <id>http://yoursite.com/2017/07/29/Backend/Java/container/01_Java容器篇_前言/</id>
    <published>2017-07-29T12:57:13.000Z</published>
    <updated>2017-07-29T12:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>这几天一直在面试，跟一个面试官聊了挺多，其中有一点感悟特别深，也提点了我。</p>
<p>是啊，有些知识点可能永远也用不上，像ArrayList和LinkedList，源码这辈子不知道都没关系，可惜，用不到不能够是偷懒就不学的理由，积少成多才能质变。</p>
<p>所以从现在必须花时间看源码上。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天一直在面试，跟一个面试官聊了挺多，其中有一点感悟特别深，也提点了我。&lt;/p&gt;
&lt;p&gt;是啊，有些知识点可能永远也用不上，像ArrayList和LinkedList，源码这辈子不知道都没关系，可惜，用不到不能够是偷懒就不学的理由，积少成多才能质变。&lt;/p&gt;
&lt;p&gt;所以从现
    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/"/>
    
      <category term="容器" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="Java容器" scheme="http://yoursite.com/tags/Java%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>02_Java容器篇_ThreadLocal</title>
    <link href="http://yoursite.com/2017/07/29/Backend/Java/container/02_Java%E5%AE%B9%E5%99%A8%E7%AF%87_ThreadLocal/"/>
    <id>http://yoursite.com/2017/07/29/Backend/Java/container/02_Java容器篇_ThreadLocal/</id>
    <published>2017-07-29T12:57:13.000Z</published>
    <updated>2017-07-29T12:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p>
<h1 id="ThreadLocal类提供的方法："><a href="#ThreadLocal类提供的方法：" class="headerlink" title="ThreadLocal类提供的方法："></a>ThreadLocal类提供的方法：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public T get() &#123; &#125;</div><div class="line">public void set(T value) &#123; &#125;</div><div class="line">public void remove() &#123; &#125;</div><div class="line">protected T initialValue() &#123; &#125;</div></pre></td></tr></table></figure>
<p>get()方法是用来获取ThreadLocal在当前线程中保存的变量副本，<br>set()用来设置当前线程中变量的副本，<br>remove()用来移除当前线程中变量的副本，<br>initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法  </p>
<h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><p><img src="http://i.imgur.com/A9nfw1e.jpg" alt="">  </p>
<p>第一句是取得当前线程，然后通过getMap(t)方法获取到一个map，map的类型为ThreadLocalMap。然后接着下面获取到<key,value>键值对，注意这里获取键值对传进去的是  this，而不是当前线程t。  </key,value></p>
<p>如果获取成功，则返回value值。  </p>
<p>如果map为空，则调用setInitialValue方法返回value。  </p>
<p>getMap()<br><img src="http://i.imgur.com/OyctcgA.jpg" alt="">  </p>
<p>在getMap中，是调用当期线程t，返回当前线程t中的一个成员变量threadLocals。<br><img src="http://i.imgur.com/qPnpfOa.jpg" alt="">  </p>
<p>实际上就是一个ThreadLocalMap，这个类型是ThreadLocal类的一个内部类:<br><img src="http://i.imgur.com/2g2gaS2.jpg" alt=""><br>ThreadLocalMap的Entry继承了WeakReference，并且使用ThreadLocal作为键值。  </p>
<h2 id="setInitialValue"><a href="#setInitialValue" class="headerlink" title="setInitialValue()"></a>setInitialValue()</h2><p><img src="http://i.imgur.com/6ROXpdf.jpg" alt=""><br>如果map不为空，就设置键值对，为空，再创建Map<br><img src="http://i.imgur.com/gf3RhcN.jpg" alt="">  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。  </p>
<p>初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。  </p>
<p>然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。  </p>
<p>1）实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的；</p>
<p>2）为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个类型不同的threadLocal变量；</p>
<p>3）在进行get之前，必须先set，否则会报空指针异常；  </p>
<p>如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法。  </p>
<p>如果没有先set的话，即在map中查找不到对应的存储，则会通过调用setInitialValue方法返回i，而在setInitialValue方法中，有一个语句是T value = initialValue()， 而默认情况下，initialValue方法返回的是null</p>
<p><img src="http://i.imgur.com/7QdrQ0S.jpg" alt="">  </p>
<h1 id="ThreadLocal的应用场景"><a href="#ThreadLocal的应用场景" class="headerlink" title="ThreadLocal的应用场景"></a>ThreadLocal的应用场景</h1><p>最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ThreadLocal&quot;&gt;&lt;a href=&quot;#ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal&quot;&gt;&lt;/a&gt;ThreadLocal&lt;/h1&gt;&lt;p&gt;ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线
    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/"/>
    
      <category term="容器" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="Java容器" scheme="http://yoursite.com/tags/Java%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>01_Python基础</title>
    <link href="http://yoursite.com/2017/07/16/Backend/Python/Base/01_Python%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2017/07/16/Backend/Python/Base/01_Python基础/</id>
    <published>2017-07-16T07:23:07.000Z</published>
    <updated>2017-07-16T07:23:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python介绍"><a href="#Python介绍" class="headerlink" title="Python介绍"></a>Python介绍</h1><ul>
<li><p>Python适合的领域<br>Web网站和各种网络服务<br>系统工具和脚本<br>作为“胶水”语言把其它语言开发和模块包装起来方便使用  </p>
</li>
<li><p>Python不适合的领域<br>贴近硬件的代码（首选C）<br>移动开发：iOS/Android有各自的开发语言（ObjC,Swift/Java）<br>游戏开发：C/C++</p>
</li>
<li><p>Python和其它语言对比<br>|      |   类型   |   运行速度   |   代码量   |<br>| —- | —- | —- | —- |<br>|   C   |   编译为机器码   |   非常快   |   非常多   |<br>|   Java   |   编译为字节码   |   快   |   多   |<br>|   Python   |   解释执行       |   慢   |   少   |</p>
</li>
</ul>
<ul>
<li>Python源码不能加密  </li>
</ul>
<h1 id="Python文件类型"><a href="#Python文件类型" class="headerlink" title="Python文件类型"></a>Python文件类型</h1><p>Hello.py -&gt; python解释器 -&gt; 字节码文件 -&gt; python解释器 -&gt; 二进制文件 -&gt; 内存、运行 -&gt; 打印结果  </p>
<p>字节码文件：<br>.pyc<br>.pyo  </p>
<p>python -V  </p>
<p>生成pyc文件<br>python -m py_compile hello.py  </p>
<p>python hello.pyc  </p>
<p>生成pyo文件<br>python -o -m py_compile hello.py  </p>
<p>python hello.pyo  </p>
<p>ord(‘A’)<br>65  </p>
<p>chr(66)<br>‘B’  </p>
<p>‘ABC’.encode(‘ascii’)<br>b’ABC’  </p>
<p> b’ABC’.decode(‘ascii’)<br>‘ABC’  </p>
<p>len(‘ABC’)  </p>
<p>float(String)<br>int(String)<br>str(integer)<br>str(float)  </p>
<p>type(var)  </p>
<p><code># -*- coding: utf-8 -*-</code>  </p>
<h1 id="str"><a href="#str" class="headerlink" title="str"></a>str</h1><p>想要分几行输入字符串，并且希望行尾的换行符自动包含到字符串当中，可以使用三对引号：”””…””” 或 ‘’’…’’’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print(&quot;&quot;&quot;\</div><div class="line">... Usage: thingy [OPTIONS]</div><div class="line">...      -h                        Display this usage message</div><div class="line">...      -H hostname               Hostname to connect to</div><div class="line">... &quot;&quot;&quot;)</div><div class="line">Usage: thingy [OPTIONS]</div><div class="line">     -h                        Display this usage message</div><div class="line">     -H hostname               Hostname to connect to</div></pre></td></tr></table></figure></p>
<p>方法 title() 返回字符串的标题版本，即单词首字母大写其余字母小写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;shi yan lou&quot;</div><div class="line">&gt;&gt;&gt; s.title()</div><div class="line">&apos;Shi Yan Lou&apos;</div></pre></td></tr></table></figure></p>
<p>方法 upper() 返回字符串全部大写的版本，反之 lower() 返回字符串的全部小写版本。<br>方法 swapcase() 返回字符串大小写交换后的版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;I am A pRoGraMMer&quot;</div><div class="line">&gt;&gt; s.swapcase()</div><div class="line">&apos;i AM a PrOgRAmmER&apos;</div></pre></td></tr></table></figure></p>
<p>方法 isalnum() 检查所有字符是否为字母数字，字符串 s 中包含空格字符，所以返回 False。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;jdwb 2323bjb&quot;</div><div class="line">&gt;&gt;&gt; s.isalnum()</div><div class="line">False</div><div class="line">&gt;&gt;&gt; s = &quot;jdwb2323bjb&quot;</div><div class="line">&gt;&gt;&gt; s.isalnum()</div><div class="line">True</div></pre></td></tr></table></figure></p>
<p>方法 isalpha() 检查字符串之中是否只有字母。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;SankarshanSir&quot;</div><div class="line">&gt;&gt;&gt; s.isalpha()</div><div class="line">True</div><div class="line">&gt;&gt;&gt; s = &quot;Sankarshan Sir&quot;</div><div class="line">&gt;&gt;&gt; s.isalpha()</div><div class="line">False</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;1234&quot;</div><div class="line">&gt;&gt;&gt; s.isdigit() # 检查字符串是否所有字符为数字</div><div class="line">True</div><div class="line">&gt;&gt;&gt; s = &quot;ShiYanLou is coming&quot;</div><div class="line">&gt;&gt;&gt; s.islower() # 检查字符串是否所有字符为小写</div><div class="line">False</div><div class="line">&gt;&gt;&gt; s = &quot;Shiyanlou Is Coming&quot;</div><div class="line">&gt;&gt;&gt; s.istitle() # To 检查字符串是否为标题样式</div><div class="line">True</div><div class="line">&gt;&gt;&gt; s = &quot;CHINA&quot;</div><div class="line">&gt;&gt;&gt; s.isupper() # 检查字符串是否所有字符为大写</div><div class="line">True</div></pre></td></tr></table></figure>
<p>使用 split() 分割任意字符串，split() 允许有一个参数，用来指定字符串以什么字符分隔（默认为 “ “），它返回一个包含所有分割后的字符串的列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;We all love Python&quot;</div><div class="line">&gt;&gt;&gt; s.split()</div><div class="line">[&apos;We&apos;, &apos;all&apos;, &apos;love&apos;, &apos;Python&apos;]</div><div class="line">&gt;&gt;&gt; x = &quot;shiyanlou:is:waiting&quot;</div><div class="line">&gt;&gt;&gt; x.split(&apos;:&apos;)</div><div class="line">[&apos;shiyanlou&apos;, &apos;is&apos;, &apos;waiting&apos;]</div></pre></td></tr></table></figure></p>
<p>方法 join() 使用指定字符连接多个字符串，它需要一个包含字符串元素的列表作为输入然后连接列表内的字符串元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; &quot;-&quot;.join(&quot;GNU/Linux is great&quot;.split())</div><div class="line">&apos;GNU/Linux-is-great&apos;</div></pre></td></tr></table></figure></p>
<p>strip(chars)，用来剥离字符串首尾中指定的字符，它允许有一个字符串参数，这个参数为剥离哪些字符提供依据。不指定参数则默认剥离掉首尾的空格和换行符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;  a bc\n &quot;</div><div class="line">&gt;&gt;&gt; s.strip()</div><div class="line">&apos;a bc&apos;</div></pre></td></tr></table></figure></p>
<p>使用 lstrip(chars) 或 rstrip(chars) 只对字符串左或右剥离。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;www.foss.in&quot; </div><div class="line">&gt;&gt;&gt; s.lstrip(&quot;cwsd.&quot;) #删除在字符串左边出现的&apos;c&apos;,&apos;w&apos;,&apos;s&apos;,&apos;d&apos;,&apos;.&apos;字符</div><div class="line">&apos;foss.in&apos;</div><div class="line">&gt;&gt;&gt; s.rstrip(&quot;cnwdi.&quot;) #删除在字符串右边出现的&apos;c&apos;,&apos;n&apos;,&apos;w&apos;,&apos;d&apos;,&apos;i&apos;,&apos;.&apos;字符</div><div class="line">&apos;www.foss&apos;</div></pre></td></tr></table></figure></p>
<p>文本搜索<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;faulty for a reason&quot;</div><div class="line">&gt;&gt;&gt; s.find(&quot;for&quot;)</div><div class="line">7</div><div class="line">&gt;&gt;&gt; s.find(&quot;fora&quot;)</div><div class="line">-1</div><div class="line">&gt;&gt;&gt; s.startswith(&quot;fa&quot;) # 检查字符串是否以 fa 开头</div><div class="line">True</div><div class="line">&gt;&gt;&gt; s.endswith(&quot;reason&quot;) # 检查字符串是否以 reason 结尾</div><div class="line">True</div></pre></td></tr></table></figure></p>
<p>回文是一种无论从左还是从右读都一样的字符序列。比如 “madam”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python3</div><div class="line">s = input(&quot;Please enter a string: &quot;)</div><div class="line">z = s[::-1]</div><div class="line">if s == z:</div><div class="line">    print(&quot;The string is a palindrome&quot;)</div><div class="line">else:</div><div class="line">    print(&quot;The string is not a palindrome&quot;)</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python3</div><div class="line">s = input(&quot;Enter a line: &quot;)</div><div class="line">print(&quot;The number of words in the line are %d&quot; % (len(s.split(&quot; &quot;))))</div></pre></td></tr></table></figure>
<p>%d    整数<br>%f    浮点数<br>%s    字符串<br>%x    十六进制整数  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; &apos;Hello, %s&apos; % &apos;world&apos;</div><div class="line">&apos;Hello, world&apos;</div><div class="line">&gt;&gt;&gt; &apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000)</div><div class="line">&apos;Hi, Michael, you have $1000000.&apos;</div><div class="line"></div><div class="line">&gt;&gt;&gt; &apos;%2d-%02d&apos; % (3, 1)</div><div class="line">&apos; 3-01&apos;</div><div class="line">&gt;&gt;&gt; &apos;%.2f&apos; % 3.1415926</div><div class="line">&apos;3.14&apos;</div><div class="line"></div><div class="line">&gt;&gt;&gt; &apos;Age: %s. Gender: %s&apos; % (25, True)</div><div class="line">&apos;Age: 25. Gender: True&apos;</div><div class="line"></div><div class="line">&gt;&gt;&gt; &apos;growth rate: %d %%&apos; % 7</div><div class="line">&apos;growth rate: 7 %&apos;</div></pre></td></tr></table></figure>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; classmates = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</div><div class="line">&gt;&gt;&gt; classmates</div><div class="line">[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</div><div class="line"></div><div class="line">&gt;&gt;&gt; classmates[0]</div><div class="line">&apos;Michael&apos;</div><div class="line">&gt;&gt;&gt; classmates[1]</div><div class="line">&apos;Bob&apos;</div></pre></td></tr></table></figure>
<p>len(list)  </p>
<p>list.append(‘ABC’)</p>
<p>list.insert(0, 111)<br>在列表索引 0 位置添加元素 111  </p>
<p>list.pop()<br>list.pop(i)  </p>
<p>list.count(‘ABC’)<br>列表方法 count(s) 会返回列表元素中 s 的数量。  </p>
<p>list.remove(‘ABC’)<br>在列表中移除任意指定值  </p>
<p>del a[-1]<br>也能使用 del 关键字删除指定位置的列表元素。</p>
<p>list.reverse()<br>反转整个列表  </p>
<p>b=[45, 56, 90]<br>list.extend(b)<br>将一个列表的所有元素添加到另一个列表的末尾  </p>
<p>a.sort()<br>给列表排序，排序的前提是列表的元素是可比较的  </p>
<p>squares = list(map(lambda x: x<strong>2, range(10)))<br>等价于下面的列表推导式。<br>squares = [x</strong>2 for x in range(10)]  </p>
<p>列表推导式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]</div><div class="line">[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]</div></pre></td></tr></table></figure></p>
<h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>元组是由数个逗号分割的值组成。  </p>
<p>tuple一旦初始化就不能修改  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; classmates = (&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;)</div><div class="line">&gt;&gt;&gt; t = (1, 2)</div><div class="line">&gt;&gt;&gt; t</div><div class="line">(1, 2)</div></pre></td></tr></table></figure>
<p>定义一个空的tuple<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; t = ()</div><div class="line">&gt;&gt;&gt; t</div><div class="line">()</div></pre></td></tr></table></figure></p>
<p>定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。</p>
<p>所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; t = (1,)</div><div class="line">&gt;&gt;&gt; t</div><div class="line">(1,)</div><div class="line">```</div></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>t = (‘a’, ‘b’, [‘A’, ‘B’])<br>t[2][0] = ‘X’<br>t[2][1] = ‘Y’<br>t<br>(‘a’, ‘b’, [‘X’, ‘Y’])<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## if</div></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
</blockquote>
<p>if &lt;条件判断1&gt;:<br>    &lt;执行1&gt;<br>elif &lt;条件判断2&gt;:<br>    &lt;执行2&gt;<br>elif &lt;条件判断3&gt;:<br>    &lt;执行3&gt;<br>else:<br>    &lt;执行4&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">int(str) 字符串转数字  </div><div class="line"></div><div class="line">replace</div></pre></td></tr></table></figure></p>
<blockquote>
<blockquote>
<blockquote>
<p>a = ‘abc’<br>b = a.replace(‘a’, ‘A’)<br>b<br>‘Abc’<br>a<br>‘abc’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## for</div></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
</blockquote>
<p>names = [‘Michael’, ‘Bob’, ‘Tracy’]<br>for name in names:<br>    print(name)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">range()函数，可以生成一个整数序列，再通过list()函数可以转换为list</div></pre></td></tr></table></figure></p>
<blockquote>
<blockquote>
<blockquote>
<p>list(range(5))<br>[0, 1, 2, 3, 4]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## while</div></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
</blockquote>
<p>sum = 0<br>n = 99<br>while n &gt; 0:<br>    sum = sum + n<br>    n = n - 2<br>print(sum)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">break  </div><div class="line"></div><div class="line">continue  </div><div class="line"></div><div class="line"></div><div class="line">## dict</div><div class="line">无序的键值对（key:value）集合，同一个字典内的键必须是互不相同的。  </div><div class="line"></div><div class="line">一对大括号 &#123;&#125; 创建一个空字典。</div></pre></td></tr></table></figure></p>
<blockquote>
<blockquote>
<blockquote>
<p>d = {‘Michael’: 95, ‘Bob’: 75, ‘Tracy’: 85}<br>d[‘Michael’]<br>95<br>d[‘test’]=’50’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">dict() 可以从包含键值对的元组中创建字典。</div></pre></td></tr></table></figure></p>
<p>dict(((‘Indian’,’Delhi’),(‘Bangladesh’,’Dhaka’)))<br>{‘Indian’: ‘Delhi’, ‘Bangladesh’: ‘Dhaka’}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">如果你想要遍历一个字典，使用字典的 items() 方法。</div></pre></td></tr></table></figure></p>
<p>data = {‘kushal’:’Fedora’, ‘kart<em>‘:’Debian’, ‘Jace’:’Mac’}<br>for x, y in data.items():<br>…     print(“{} uses {}”.format(x, y))<br>…<br>Kushal uses Fedora<br>Jace uses Mac<br>kart</em> uses Debian<br>parthan uses Ubuntu<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">如果key不存在，dict就会报错：</div><div class="line"></div><div class="line"></div><div class="line">要避免key不存在的错误，有两种办法：</div><div class="line"></div><div class="line">一是通过in判断key是否存在：</div><div class="line">in</div></pre></td></tr></table></figure></p>
<p>‘Thomas’ in d<br>False<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">二是通过dict提供的get方法，如果key不存在，可以返回None，或者自己指定的value：</div><div class="line">get</div></pre></td></tr></table></figure></p>
<p>d.get(‘Thomas’)<br>d.get(‘Thomas’, -1)<br>-1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">pop</div></pre></td></tr></table></figure></p>
<p>d.pop(‘Bob’)<br>75<br>d<br>{‘Michael’: 95, ‘Tracy’: 85}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">使用 del 关键字删除任意指定的键值对：</div></pre></td></tr></table></figure></p>
<p>del d[‘test’]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">必须知道的是，字典中的键必须是不可变类型，比如你不能使用列表作为键。  </div><div class="line"></div><div class="line">dict.setdefault(key, default)  </div><div class="line">往字典中的元素添加数据，我们首先要判断这个元素是否存在，不存在则创建一个默认值。</div></pre></td></tr></table></figure></p>
<p>data = {}<br>data.setdefault(‘names’, []).append(‘Ruby’)<br>data<br>{‘names’: [‘Ruby’]}<br>data.setdefault(‘names’, []).append(‘Python’)<br>data<br>{‘names’: [‘Ruby’, ‘Python’]}<br>data.setdefault(‘names’, []).append(‘C’)<br>data<br>{‘names’: [‘Ruby’, ‘Python’, ‘C’]}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">试图索引一个不存在的键将会抛出一个 keyError 错误。我们可以使用 dict.get(key, default) 来索引键，如果键不存在，那么返回指定的 default 值。</div></pre></td></tr></table></figure></p>
<p>data[‘foo’]<br>Traceback (most recent call last):<br>File “<stdin>“, line 1, in <module><br>KeyError: ‘foo’<br>data.get(‘foo’, 0)<br>0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在遍历列表（或任何序列类型）的同时获得元素索引值，你可以使用 enumerate()。</div></pre></td></tr></table></figure></module></stdin></p>
<p>for i, j in enumerate([‘a’, ‘b’, ‘c’]):<br>…     print(i, j)<br>…<br>0 a<br>1 b<br>2 c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">同时遍历两个序列类型，可以使用 zip() 函数。</div></pre></td></tr></table></figure></p>
<p>a = [‘Pradeepto’, ‘Kushal’]<br>b = [‘OpenSUSE’, ‘Fedora’]<br>for x, y in zip(a, b):<br>…     print(“{} uses {}”.format(x, y))<br>…<br>Pradeepto uses OpenSUSE<br>Kushal uses Fedora<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## set</div><div class="line">set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。  </div><div class="line"></div><div class="line">大括号或 set() 函数可以用来创建集合。注意：想要创建空集合，你必须使用 set() 而不是 &#123;&#125;。  </div><div class="line">  </div><div class="line">要创建一个set，需要提供一个list作为输入集合：</div></pre></td></tr></table></figure></p>
<p>s = set([1, 1, 2, 2, 3, 3])<br>s<br>{1, 2, 3}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">add</div></pre></td></tr></table></figure></p>
<p>s.add(4)<br>s<br>{1, 2, 3, 4}<br>s.add(4)<br>s<br>{1, 2, 3, 4}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">pop</div></pre></td></tr></table></figure></p>
<p>s.pop()<br>1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">remove</div></pre></td></tr></table></figure></p>
<p>s.remove(4)<br>s<br>{1, 2, 3}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">&amp;   |</div></pre></td></tr></table></figure></p>
<p>s1 = set([1, 2, 3])<br>s2 = set([2, 3, 4])<br>s1 &amp; s2<br>{2, 3}<br>s1 | s2<br>{1, 2, 3, 4}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">演示对两个单词中的字母进行集合操作</div></pre></td></tr></table></figure></p>
<p>a = set(‘abracadabra’)<br>b = set(‘alacazam’)<br>a                                  # a 去重后的字母<br>{‘a’, ‘r’, ‘b’, ‘c’, ‘d’}<br>a - b                              # a 有而 b 没有的字母<br>{‘r’, ‘d’, ‘b’}<br>a | b                              # 存在于 a 或 b 的字母<br>{‘a’, ‘c’, ‘r’, ‘d’, ‘b’, ‘m’, ‘z’, ‘l’}<br>a &amp; b                              # a 和 b 都有的字母<br>{‘a’, ‘c’}<br>a ^ b                              # 存在于 a 或 b 但不同时存在的字母<br>{‘r’, ‘d’, ‘b’, ‘m’, ‘z’, ‘l’}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">in</div></pre></td></tr></table></figure></p>
<p>basket = {‘apple’, ‘orange’, ‘apple’, ‘pear’, ‘orange’, ‘banana’}<br>print(basket)                      # 你可以看到重复的元素被去除<br>{‘orange’, ‘banana’, ‘pear’, ‘apple’}<br>‘orange’ in basket<br>True<br>‘crabgrass’ in basket<br>False<br>```</p>
</blockquote>
</blockquote>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python介绍&quot;&gt;&lt;a href=&quot;#Python介绍&quot; class=&quot;headerlink&quot; title=&quot;Python介绍&quot;&gt;&lt;/a&gt;Python介绍&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Python适合的领域&lt;br&gt;Web网站和各种网络服务&lt;br&gt;系统工具和脚
    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Python/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Python/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>02_Python函数</title>
    <link href="http://yoursite.com/2017/07/16/Backend/Python/Base/02_%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2017/07/16/Backend/Python/Base/02_函数/</id>
    <published>2017-07-16T07:23:07.000Z</published>
    <updated>2017-07-16T07:23:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python内置函数"><a href="#Python内置函数" class="headerlink" title="Python内置函数"></a>Python内置函数</h1><p><a href="http://docs.python.org/3/library/functions.html#abs" target="_blank" rel="external">http://docs.python.org/3/library/functions.html#abs</a>  </p>
<p>以在交互式命令行通过help(abs)查看abs函数的帮助信息。  </p>
<p>abs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; abs(100)</div><div class="line">100</div><div class="line">&gt;&gt;&gt; abs(-20)</div><div class="line">20</div><div class="line">&gt;&gt;&gt; abs(12.34)</div><div class="line">12.34</div></pre></td></tr></table></figure></p>
<p>max<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; max(1, 2)</div><div class="line">2</div><div class="line">&gt;&gt;&gt; max(2, 3, 1, -5)</div><div class="line">3</div></pre></td></tr></table></figure></p>
<h1 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; int(&apos;123&apos;)</div><div class="line">123</div><div class="line">&gt;&gt;&gt; int(12.34)</div><div class="line">12</div><div class="line">&gt;&gt;&gt; float(&apos;12.34&apos;)</div><div class="line">12.34</div><div class="line">&gt;&gt;&gt; str(1.23)</div><div class="line">&apos;1.23&apos;</div><div class="line">&gt;&gt;&gt; str(100)</div><div class="line">&apos;100&apos;</div><div class="line">&gt;&gt;&gt; bool(1)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; bool(&apos;&apos;)</div><div class="line">False</div></pre></td></tr></table></figure>
<p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = abs # 变量a指向abs函数</div><div class="line">&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数</div><div class="line">1</div></pre></td></tr></table></figure></p>
<h1 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h1><p>在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def my_abs(x):</div><div class="line">    if x &gt;= 0:</div><div class="line">        return x</div><div class="line">    else:</div><div class="line">        return -x</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。  </p>
</blockquote>
<p>如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。  </p>
<p>return None可以简写为return  </p>
<p>如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python解释器，用from abstest import my_abs来导入my_abs()函数，注意abstest是文件名（不含.py扩展名）：</p>
<h1 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h1><p>如果想定义一个什么事也不做的空函数，可以用pass语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def nop():</div><div class="line">    pass</div></pre></td></tr></table></figure></p>
<p>实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。</p>
<p>pass还可以用在其他语句里，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if age &gt;= 18:</div><div class="line">    pass</div></pre></td></tr></table></figure></p>
<p>缺少了pass，代码运行就会有语法错误。</p>
<h1 id="参数检查"><a href="#参数检查" class="headerlink" title="参数检查"></a>参数检查</h1><p>调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError：</p>
<p>如果参数类型不对，Python解释器就无法帮我们检查。试试my_abs和内置函数abs的差别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; my_abs(&apos;A&apos;)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 2, in my_abs</div><div class="line">TypeError: unorderable types: str() &gt;= int()</div><div class="line">&gt;&gt;&gt; abs(&apos;A&apos;)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">TypeError: bad operand type for abs(): &apos;str&apos;</div></pre></td></tr></table></figure></p>
<p>数据类型检查可以用内置函数isinstance()实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def my_abs(x):</div><div class="line">    if not isinstance(x, (int, float)):</div><div class="line">        raise TypeError(&apos;bad operand type&apos;)</div><div class="line">    if x &gt;= 0:</div><div class="line">        return x</div><div class="line">    else:</div><div class="line">        return -x</div></pre></td></tr></table></figure></p>
<p>如果传入错误的参数类型，函数就可以抛出一个错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; my_abs(&apos;A&apos;)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 3, in my_abs</div><div class="line">TypeError: bad operand type</div></pre></td></tr></table></figure></p>
<h1 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import math</div><div class="line"></div><div class="line">def move(x, y, step, angle=0):</div><div class="line">    nx = x + step * math.cos(angle)</div><div class="line">    ny = y - step * math.sin(angle)</div><div class="line">    return nx, ny</div></pre></td></tr></table></figure>
<p>import math语句表示导入math包，并允许后续代码引用math包里的sin、cos等函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)</div><div class="line">&gt;&gt;&gt; print(x, y)</div><div class="line">151.96152422706632 70.0</div></pre></td></tr></table></figure>
<p>Python函数返回的仍然是单一值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)</div><div class="line">&gt;&gt;&gt; print(r)</div><div class="line">(151.96152422706632, 70.0)</div></pre></td></tr></table></figure></p>
<p>返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。  </p>
<h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def power(x, n=2):</div><div class="line">    s = 1</div><div class="line">    while n &gt; 0:</div><div class="line">        n = n - 1</div><div class="line">        s = s * x</div><div class="line">    return s</div></pre></td></tr></table></figure>
<p>设置默认参数时，有几点要注意：</p>
<ol>
<li><p>必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；  </p>
</li>
<li><p>如何设置默认参数。<br>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</p>
</li>
</ol>
<p>默认参数很有用，但使用不当，也会掉坑里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">def add_end(L=[]):</div><div class="line">    L.append(&apos;END&apos;)</div><div class="line">    return L</div><div class="line">  </div><div class="line">&gt;&gt;&gt; add_end([1, 2, 3])</div><div class="line">[1, 2, 3, &apos;END&apos;]</div><div class="line">&gt;&gt;&gt; add_end([&apos;x&apos;, &apos;y&apos;, &apos;z&apos;])</div><div class="line">[&apos;x&apos;, &apos;y&apos;, &apos;z&apos;, &apos;END&apos;]</div><div class="line">  </div><div class="line">&gt;&gt;&gt; add_end()</div><div class="line">[&apos;END&apos;]</div><div class="line">  </div><div class="line">&gt;&gt;&gt; add_end()</div><div class="line">[&apos;END&apos;, &apos;END&apos;]</div><div class="line">&gt;&gt;&gt; add_end()</div><div class="line">[&apos;END&apos;, &apos;END&apos;, &apos;END&apos;]</div></pre></td></tr></table></figure></p>
<p>原因解释如下：  </p>
<p>Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。  </p>
<p>所以，定义默认参数要牢记一点：默认参数必须指向不变对象！  </p>
<p>可以用None这个不变对象来实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def add_end(L=None):</div><div class="line">    if L is None:</div><div class="line">        L = []</div><div class="line">    L.append(&apos;END&apos;)</div><div class="line">    return L</div></pre></td></tr></table></figure></p>
<h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><p>参数个数可变  </p>
<p>组装出一个list或tuple：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">def calc(numbers):</div><div class="line">    sum = 0</div><div class="line">    for n in numbers:</div><div class="line">        sum = sum + n * n</div><div class="line">    return sum</div><div class="line">  </div><div class="line">&gt;&gt;&gt; calc([1, 2, 3])</div><div class="line">14</div><div class="line">&gt;&gt;&gt; calc((1, 3, 5, 7))</div><div class="line">84</div></pre></td></tr></table></figure></p>
<p>可变参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def calc(*numbers):</div><div class="line">    sum = 0</div><div class="line">    for n in numbers:</div><div class="line">        sum = sum + n * n</div><div class="line">    return sum</div></pre></td></tr></table></figure></p>
<p>定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：  </p>
<p>如果已经有一个list或者tuple，要调用一个可变参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; nums = [1, 2, 3]</div><div class="line">&gt;&gt;&gt; calc(nums[0], nums[1], nums[2])</div><div class="line">14</div></pre></td></tr></table></figure></p>
<p>Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; nums = [1, 2, 3]</div><div class="line">&gt;&gt;&gt; calc(*nums)</div><div class="line">14</div></pre></td></tr></table></figure></p>
<h1 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h1><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">def person(name, age, **kw):</div><div class="line">    print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw)</div><div class="line">  </div><div class="line">&gt;&gt;&gt; person(&apos;Michael&apos;, 30)</div><div class="line">name: Michael age: 30 other: &#123;&#125;</div><div class="line">  </div><div class="line">&gt;&gt;&gt; person(&apos;Bob&apos;, 35, city=&apos;Beijing&apos;)</div><div class="line">name: Bob age: 35 other: &#123;&apos;city&apos;: &apos;Beijing&apos;&#125;</div><div class="line">&gt;&gt;&gt; person(&apos;Adam&apos;, 45, gender=&apos;M&apos;, job=&apos;Engineer&apos;)</div><div class="line">name: Adam age: 45 other: &#123;&apos;gender&apos;: &apos;M&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</div><div class="line">  </div><div class="line">&gt;&gt;&gt; extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</div><div class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, city=extra[&apos;city&apos;], job=extra[&apos;job&apos;])</div><div class="line">name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</div><div class="line">  </div><div class="line">&gt;&gt;&gt; extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</div><div class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, **extra)</div><div class="line">name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</div></pre></td></tr></table></figure>
<p><code>**extra</code>表示把extra这个dict的所有key-value用关键字参数传入到函数的<code>**kw</code>参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。</p>
<h1 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h1><p>如果要限制关键字参数的名字，就可以用命名关键字参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def person(name, age, *, city, job):</div><div class="line">    print(name, age, city, job)</div><div class="line">  </div><div class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, city=&apos;Beijing&apos;, job=&apos;Engineer&apos;)</div><div class="line">Jack 24 Beijing Engineer</div></pre></td></tr></table></figure></p>
<p>和关键字参数<em>*kw不同，命名关键字参数需要一个特殊分隔符</em>，*后面的参数被视为命名关键字参数。  </p>
<p>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：  </p>
<p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def person(name, age, *args, city, job):</div><div class="line">    print(name, age, args, city, job)</div></pre></td></tr></table></figure></p>
<p>命名关键字参数可以有缺省值，从而简化调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def person(name, age, *, city=&apos;Beijing&apos;, job):</div><div class="line">    print(name, age, city, job)</div><div class="line">  </div><div class="line"># 命名关键字参数city具有默认值，调用时，可不传入city参数  </div><div class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, job=&apos;Engineer&apos;)</div><div class="line">Jack 24 Beijing Engineer</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def person(name, age, city, job):</div><div class="line">    # 缺少 *，city和job被视为位置参数</div><div class="line">    pass</div></pre></td></tr></table></figure>
<h1 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h1><p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。  </p>
<p>但是请注意，参数定义的顺序必须是：<br><strong>必选参数、默认参数、可变参数、命名关键字参数和关键字参数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def f1(a, b, c=0, *args, **kw):</div><div class="line">    print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;args =&apos;, args, &apos;kw =&apos;, kw)</div><div class="line"></div><div class="line">def f2(a, b, c=0, *, d, **kw):</div><div class="line">    print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;d =&apos;, d, &apos;kw =&apos;, kw)</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; f1(1, 2)</div><div class="line">a = 1 b = 2 c = 0 args = () kw = &#123;&#125;</div><div class="line">&gt;&gt;&gt; f1(1, 2, c=3)</div><div class="line">a = 1 b = 2 c = 3 args = () kw = &#123;&#125;</div><div class="line">&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;)</div><div class="line">a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = &#123;&#125;</div><div class="line">&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;, x=99)</div><div class="line">a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = &#123;&apos;x&apos;: 99&#125;</div><div class="line">&gt;&gt;&gt; f2(1, 2, d=99, ext=None)</div><div class="line">a = 1 b = 2 c = 0 d = 99 kw = &#123;&apos;ext&apos;: None&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; args = (1, 2, 3, 4)</div><div class="line">&gt;&gt;&gt; kw = &#123;&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;&#125;</div><div class="line">&gt;&gt;&gt; f1(*args, **kw)</div><div class="line">a = 1 b = 2 c = 3 args = (4,) kw = &#123;&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;&#125;</div><div class="line">&gt;&gt;&gt; args = (1, 2, 3)</div><div class="line">&gt;&gt;&gt; kw = &#123;&apos;d&apos;: 88, &apos;x&apos;: &apos;#&apos;&#125;</div><div class="line">&gt;&gt;&gt; f2(*args, **kw)</div><div class="line">a = 1 b = 2 c = 3 d = 88 kw = &#123;&apos;x&apos;: &apos;#&apos;&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python内置函数&quot;&gt;&lt;a href=&quot;#Python内置函数&quot; class=&quot;headerlink&quot; title=&quot;Python内置函数&quot;&gt;&lt;/a&gt;Python内置函数&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://docs.python.org/3/libr
    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Python/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Python/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>05_Linux 文件系统操作与磁盘管理</title>
    <link href="http://yoursite.com/2017/07/07/Linux/Base/05_%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86(df,du,dd,mkfs,mount,fdisk,losetup)/"/>
    <id>http://yoursite.com/2017/07/07/Linux/Base/05_文件系统操作与磁盘管理(df,du,dd,mkfs,mount,fdisk,losetup)/</id>
    <published>2017-07-07T12:59:47.000Z</published>
    <updated>2017-07-07T12:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件系统操作与磁盘管理"><a href="#文件系统操作与磁盘管理" class="headerlink" title="文件系统操作与磁盘管理"></a>文件系统操作与磁盘管理</h1><p>使用 df 命令查看磁盘的容量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ df</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/X0x1TgN.png" alt="">  </p>
<p>一般使用情况下，更多只是关心第一行的内容也就是环境中的rootfs或者物理主机上的/dev/sda2  </p>
<blockquote>
<p>“rootfs” : （Root File System）它是 Ramfs（Ramfs 是一个非常简单的 Linux 文件系统用于实现磁盘缓存机制作为动态可调整大小的基于 ram 的文件系统）或者 tmpfs 的一个特殊实例，它作为系统启动时内核载入内存之后，在挂载真正的磁盘之前的一个临时文件系统。通常的主机会在系统启动后用磁盘上的文件系统替换，只是在一些嵌入式系统中会只存在一个 rootfs ，或者像我们目前遇到的情况运行在虚拟环境中共享主机资源的系统也可能会采用这种方式。</p>
</blockquote>
<p>物理主机上的 /dev/sda2 是对应着主机硬盘的分区，后面的数字表示分区号，数字前面的字母 a 表示第几块硬盘（也可能是可移动磁盘），如果主机上有多块硬盘则可能还会出现 /dev/sdb，/dev/sdc 这些磁盘设备都会在 /dev 目录下以文件的存在形式。  </p>
<p>接着你还会看到”1k-blocks”这个陌生的东西，它表示以磁盘块大小的方式显示容量，后面为相应的以块大小表示的已用和可用容量，在你了解 Linux 的文件系统之前这个就先不管吧，我们以一种你应该看得懂的方式展示：  </p>
<p><img src="http://i.imgur.com/5AppTUt.png" alt="">  </p>
<p><strong>使用 du 命令查看目录的容量</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 默认同样以 blocks 的大小展示</div><div class="line">$ du </div><div class="line"># 加上`-h`参数，以更易读的方式展示</div><div class="line">$ du -h</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/GF4b7xu.png" alt="">  </p>
<p>-d参数指定查看目录的深度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 只查看1级目录的信息</div><div class="line">$ du -h -d 0 ~</div><div class="line"># 查看2级</div><div class="line">$ du -h -d 1 ~</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/fcrXD2q.png" alt="">  </p>
<p>常用参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">du -h #同--human-readable 以K，M，G为单位，提高信息的可读性。</div><div class="line">du -a #同--all 显示目录中所有文件的大小。</div><div class="line">du -s #同--summarize 仅显示总计，只列出最后加总的值。</div></pre></td></tr></table></figure></p>
<p>du（estimate file space usage）命令与df（report file system disk space usage）只用一字只差，首先就希望注意不要弄混淆了,以可以像我这样从man手册中获取命令的完整描述，记全称就不会搞混了。</p>
<h1 id="简单的磁盘管理"><a href="#简单的磁盘管理" class="headerlink" title="简单的磁盘管理"></a>简单的磁盘管理</h1><h2 id="创建虚拟磁盘"><a href="#创建虚拟磁盘" class="headerlink" title="创建虚拟磁盘"></a>创建虚拟磁盘</h2><p>dd 命令简介  </p>
<p>dd命令用于转换和复制文件，不过它的复制不同于cp。之前提到过关于 Linux 的很重要的一点，一切即文件，在 Linux 上，硬件的设备驱动（如硬盘）和特殊设备文件（如/dev/zero和/dev/random）都像普通文件一样，只要在各自的驱动程序中实现了对应的功能，dd 也可以读取自和/或写入到这些文件。这样，dd也可以用在备份硬件的引导扇区、获取一定数量的随机数据或者空数据等任务中。dd程序也可以在复制时处理数据，例如转换字节序、或在 ASCII 与 EBCDIC 编码间互换。  </p>
<p>dd的命令行语句与其他的 Linux 程序不同，因为它的命令行选项格式为选项=值，而不是更标准的–选项 值或-选项=值。dd默认从标准输入中读取，并写入到标准输出中，但可以用选项if（input file，输入文件）和of（output file，输出文件）改变。  </p>
<p>我们先来试试用dd命令从标准输入读入用户输入到标准输出或者一个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 输出到文件</div><div class="line">$ dd of=test bs=10 count=1 # 或者 dd if=/dev/stdin of=test bs=10 count=1</div><div class="line"># 输出到标准输出</div><div class="line">$ dd if=/dev/stdin of=/dev/stdout bs=10 count=1</div><div class="line"># 注</div><div class="line">在打完了这个命令后，继续在终端打字，作为你的输入</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/i6QnyRg.png" alt="">  </p>
<p>上述命令从标准输入设备读入用户输入（缺省值，所以可省略）然后输出到 test 文件，bs（block size）用于指定块大小（缺省单位为 Byte，也可为其指定如’K’，’M’，’G’等单位），count用于指定块数量。如上图所示，我指定只读取总共 10 个字节的数据，当我输入了“hello shiyanlou”之后加上空格回车总共 16 个字节（一个英文字符占一个字节）内容，显然超过了设定大小。使用和du和cat命令看到的写入完成文件实际内容确实只有 10 个字节（那个黑底百分号表示这里没有换行符）,而其他的多余输入将被截取并保留在标准输入。  </p>
<p>前面说到dd在拷贝的同时还可以实现数据转换，那下面就举一个简单的例子：将输出的英文字符转换为大写再写入文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ dd if=/dev/stdin of=test bs=10 count=1 conv=ucase</div></pre></td></tr></table></figure></p>
<h2 id="使用-dd-命令创建虚拟镜像文件"><a href="#使用-dd-命令创建虚拟镜像文件" class="headerlink" title="使用 dd 命令创建虚拟镜像文件"></a>使用 dd 命令创建虚拟镜像文件</h2><p>从/dev/zero设备创建一个容量为 256M 的空文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ dd if=/dev/zero of=virtual.img bs=1M count=256</div><div class="line">$ du -h virtual.img</div></pre></td></tr></table></figure></p>
<p>然后要将这个文件格式化（写入文件系统）</p>
<h2 id="使用-mkfs-命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）"><a href="#使用-mkfs-命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）" class="headerlink" title="使用 mkfs 命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）"></a>使用 mkfs 命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）</h2><p>你可以在命令行输入 sudo mkfs 然后按下Tab键，你可以看到很多个以 mkfs 为前缀的命令，这些不同的后缀其实就是表示着不同的文件系统，可以用 mkfs 格式化成的文件系统。  </p>
<p>我们可以简单的使用下面的命令来将我们的虚拟磁盘镜像格式化为ext4文件系统：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo mkfs.ext4 virtual.img</div></pre></td></tr></table></figure></p>
<h2 id="使用-mount-命令挂载磁盘到目录树"><a href="#使用-mount-命令挂载磁盘到目录树" class="headerlink" title="使用 mount 命令挂载磁盘到目录树"></a>使用 mount 命令挂载磁盘到目录树</h2><p>用户在 Linux/UNIX 的机器上打开一个文件以前，包含该文件的文件系统必须先进行挂载的动作，此时用户要对该文件系统执行 mount 的指令以进行挂载。通常是使用在 USB 或其他可移除存储设备上，而根目录则需要始终保持挂载的状态。又因为 Linux/UNIX 文件系统可以对应一个文件而不一定要是硬件设备，所以可以挂载一个包含文件系统的文件到目录树。  </p>
<p>Linux/UNIX 命令行的 mount 指令是告诉操作系统，对应的文件系统已经准备好，可以使用了，而该文件系统会对应到一个特定的点（称为挂载点）。挂载好的文件、目录、设备以及特殊文件即可提供用户使用。  </p>
<p>我们先来使用mount来查看下主机已经挂载的文件系统：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo mount</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/rWkGbGM.png" alt="">  </p>
<p>输出的结果中每一行表示一个设备或虚拟设备,每一行最前面是设备名，然后是 on 后面是挂载点，type 后面表示文件系统类型，再后面是挂载选项（比如可以在挂载时设定以只读方式挂载等等）。  </p>
<p>那么如何挂载真正的磁盘到目录树呢，mount命令的一般格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mount [options] [source] [directory]</div></pre></td></tr></table></figure></p>
<p>一些常用操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mount [-o [操作选项]] [-t 文件系统类型] [-w|--rw|--ro] [文件系统源] [挂载点]</div></pre></td></tr></table></figure></p>
<p>现在直接来挂载我们创建的虚拟磁盘镜像到/mnt目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ mount -o loop -t ext4 virtual.img /mnt </div><div class="line"># 也可以省略挂载类型，很多时候 mount 会自动识别</div><div class="line">  </div><div class="line"># 以只读方式挂载</div><div class="line">$ mount -o loop --ro virtual.img /mnt</div><div class="line"># 或者mount -o loop,ro virtual.img /mnt</div></pre></td></tr></table></figure></p>
<p>使用 umount 命令卸载已挂载磁盘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 命令格式 sudo umount 已挂载设备名或者挂载点，如：</div><div class="line">$ sudo umount /mnt</div></pre></td></tr></table></figure></p>
<p>不过遗憾的是，由于我们环境的问题（环境中使用的 Linux 内核在编译时没有添加对 Loop device的支持），所以你将无法挂载成功：</p>
<h2 id="使用-fdisk-为磁盘分区"><a href="#使用-fdisk-为磁盘分区" class="headerlink" title="使用 fdisk 为磁盘分区"></a>使用 fdisk 为磁盘分区</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 查看硬盘分区表信息</div><div class="line">$ sudo fdisk -l</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/c5XPoFW.png" alt="">  </p>
<p>输出结果中开头显示了主机上的磁盘的一些信息，包括容量扇区数，扇区大小，I/O 大小等信息。  </p>
<p>重点看一下中间的分区信息，/dev/sda1，/dev/sda2 为主分区分别安装了 Windows 和 Linux 操作系统，/dev/sda3 为交换分区（可以理解为虚拟内存），/dev/sda4 为扩展分区其中包含 /dev/sda5，/dev/sda6，/dev/sda7，/dev/sda8 四个逻辑分区，因为主机上有几个分区之间有空隙，没有对齐边界扇区,所以分区之间的不是完全连续的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 进入磁盘分区模式</div><div class="line">$ sudo fdisk virtual.img</div></pre></td></tr></table></figure></p>
<h2 id="使用-losetup-命令建立镜像与回环设备的关联"><a href="#使用-losetup-命令建立镜像与回环设备的关联" class="headerlink" title="使用 losetup 命令建立镜像与回环设备的关联"></a>使用 losetup 命令建立镜像与回环设备的关联</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ sudo losetup /dev/loop0 virtual.img</div><div class="line"># 如果提示设备忙你也可以使用其它的回环设备，&quot;ls /dev/loop*&quot;参看所有回环设备</div><div class="line">  </div><div class="line"># 解除设备关联</div><div class="line">$ sudo losetup -d /dev/loop0</div></pre></td></tr></table></figure>
<p>然后再使用mkfs格式化各分区（前面我们是格式化整个虚拟磁盘镜像文件或磁盘），不过格式化之前，我们还要为各分区建立虚拟设备的映射，用到kpartx工具，需要先安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install kpartx</div><div class="line">$ sudo kpartx -av /dev/loop0</div><div class="line">  </div><div class="line"># 取消映射</div><div class="line">$ sudo kpartx -dv /dev/loop0</div></pre></td></tr></table></figure></p>
<p>接着再是格式化，我们将其全部格式化为 ext4：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo mkfs.ext4 -q /dev/mapper/loop0p1</div><div class="line">$ sudo mkfs.ext4 -q /dev/mapper/loop0p5</div><div class="line">$ sudo mkfs.ext4 -q /dev/mapper/loop0p6</div></pre></td></tr></table></figure></p>
<p>格式化完成后在/media目录下新建四个空目录用于挂载虚拟磁盘：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ mkdir -p /media/virtualdisk_&#123;1..3&#125;</div><div class="line"># 挂载磁盘分区</div><div class="line">$ sudo mount /dev/mapper/loop0p1 /media/virtualdisk_1</div><div class="line">$ sudo mount /dev/mapper/loop0p5 /media/virtualdisk_2</div><div class="line">$ sudo mount /dev/mapper/loop0p6 /media/virtualdisk_3</div><div class="line">  </div><div class="line"># 卸载磁盘分区</div><div class="line">$ sudo umount /dev/mapper/loop0p1</div><div class="line">$ sudo umount /dev/mapper/loop0p5</div><div class="line">$ sudo umount /dev/mapper/loop0p6</div></pre></td></tr></table></figure></p>
<p>然后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ df -h</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;文件系统操作与磁盘管理&quot;&gt;&lt;a href=&quot;#文件系统操作与磁盘管理&quot; class=&quot;headerlink&quot; title=&quot;文件系统操作与磁盘管理&quot;&gt;&lt;/a&gt;文件系统操作与磁盘管理&lt;/h1&gt;&lt;p&gt;使用 df 命令查看磁盘的容量&lt;br&gt;&lt;figure class=&quot;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Linux/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux基础" scheme="http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>08_Linux 命令执行顺序的控制</title>
    <link href="http://yoursite.com/2017/07/07/Linux/Base/08_%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%AE%A1%E9%81%93(cut,grep,wc,sort,uniq)/"/>
    <id>http://yoursite.com/2017/07/07/Linux/Base/08_命令执行顺序控制与管道(cut,grep,wc,sort,uniq)/</id>
    <published>2017-07-07T12:59:47.000Z</published>
    <updated>2017-07-07T12:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命令执行顺序的控制"><a href="#命令执行顺序的控制" class="headerlink" title="命令执行顺序的控制"></a>命令执行顺序的控制</h1><h2 id="顺序执行多条命令"><a href="#顺序执行多条命令" class="headerlink" title="顺序执行多条命令"></a>顺序执行多条命令</h2><p>使用场景：我需要使用apt-get安装一个软件，然后安装完成后立即运行安装的软件（或命令工具），又恰巧你的主机才更换的软件源还没有更新软件列表（比如之前我们的环境中，每次重新开始实验就得sudo apt-get update，现在已经没有这个问题了）,那么你可能会有如下一系列操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get update</div><div class="line"># 等待——————————然后输入下面的命令</div><div class="line">$ sudo apt-get install some-tool</div><div class="line"># 等待——————————然后输入下面的命令</div><div class="line">$ some-tool</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get update;sudo apt-get install some-tool;some-tool</div><div class="line"># 让它自己运行</div></pre></td></tr></table></figure>
<h2 id="有选择的执行命令"><a href="#有选择的执行命令" class="headerlink" title="有选择的执行命令"></a>有选择的执行命令</h2><p>关于上面的操作，不知你有没有思考过一个问题，如果我们在让它自动顺序执行命令时，前面的命令执行不成功，而后面的命令又依赖与上一条命令的结果，那么就会造成花了时间，最终却得到一个错误的结果，而且有时候直观的看你还无法判断结果是否正确。那么我们需要能够有选择性的来执行命令，比如上一条命令执行成功才继续下一条，或者不成功又该做出其它什么处理,比如我们使用which来查找是否安装某个命令，如果找到就执行该命令，否则什么也不做（虽然这个操作没有什么实际意义，但可帮你更好的理解一些概念）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ which cowsay&gt;/dev/null &amp;&amp; cowsay -f head-in ohch~</div></pre></td></tr></table></figure></p>
<p>你如果没有安装cowsay，你可以先执行一次上述命令，你会发现什么也没发生，你再安装好之后你再执行一次上述命令，你也会发现一些惊喜。</p>
<p>上面的&amp;&amp;就是用来实现选择性执行的，它表示如果前面的命令执行结果（不是表示终端输出的内容，而是表示命令执行状态的结果）返回0则执行后面的，否则不执行，你可以从$?环境变量获取上一次命令的返回结果：</p>
<p><img src="http://i.imgur.com/CwynQOp.png" alt="">  </p>
<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p>管道是什么,管道是一种通信机制，通常用于进程间的通信（也可通过socket进行网络通信），它表现出来的形式就是将前面每一个进程的输出(stdout)直接作为下一个进程的输入(stdin)。</p>
<p>管道又分为匿名管道和具名管道。我们在使用一些过滤程序时经常会用到的就是匿名管道，在命令行中由|分隔符表示，|在前面的内容中我们已经多次使用到了。具名管道简单的说就是有名字的管道，通常只会在源程序中用到具名管道。</p>
<h2 id="试用"><a href="#试用" class="headerlink" title="试用"></a>试用</h2><p>先试用一下管道，比如查看/etc目录下有哪些文件和目录，使用ls命令来查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ls -al /etc</div></pre></td></tr></table></figure></p>
<p>有太多内容，屏幕不能完全显示，这时候可以使用滚动条或快捷键滚动窗口来查看。不过这时候可以使用管道：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -al /etc | less</div></pre></td></tr></table></figure></p>
<p>通过管道将前一个命令(ls)的输出作为下一个命令(less)的输入，然后就可以一行一行地看。  </p>
<h2 id="cut-命令，打印每一行的某一字段"><a href="#cut-命令，打印每一行的某一字段" class="headerlink" title="cut 命令，打印每一行的某一字段"></a>cut 命令，打印每一行的某一字段</h2><p>打印/etc/passwd文件中以:为分隔符的第1个字段和第6个字段分别表示用户名和其家目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cut /etc/passwd -d &apos;:&apos; -f 1,6</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/xnc0fAH.png" alt="">  </p>
<p>打印/etc/passwd文件中每一行的前N个字符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 前五个（包含第五个）</div><div class="line">$ cut /etc/passwd -c -5</div><div class="line"># 前五个之后的（包含第五个）</div><div class="line">$ cut /etc/passwd -c 5-</div><div class="line"># 第五个</div><div class="line">$ cut /etc/passwd -c 5</div><div class="line"># 2到5之间的（包含第五个）</div><div class="line">$ cut /etc/passwd -c 2-5</div></pre></td></tr></table></figure></p>
<h2 id="grep-命令，在文本中或-stdin-中查找匹配字符串"><a href="#grep-命令，在文本中或-stdin-中查找匹配字符串" class="headerlink" title="grep 命令，在文本中或 stdin 中查找匹配字符串"></a>grep 命令，在文本中或 stdin 中查找匹配字符串</h2><p>grep命令是很强大的，也是相当常用的一个命令，它结合正则表达式可以实现很复杂却很高效的匹配和查找。</p>
<p>grep命令的一般形式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep [命令选项]... 用于匹配的表达式 [文件]...</div></pre></td></tr></table></figure></p>
<p>搜索/home/shiyanlou目录下所有包含”shiyanlou”的所有文本文件，并显示出现在文本中的行号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ grep -rnI &quot;shiyanlou&quot; ~</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/94MMo9r.png" alt="">  </p>
<p>-r 参数表示递归搜索子目录中的文件,-n表示打印匹配项行号，-I表示忽略二进制文件。这个操作实际没有多大意义，但可以感受到grep命令的强大与实用。</p>
<p>当然也可以在匹配字段中使用正则表达式，下面简单的演示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 查看环境变量中以&quot;yanlou&quot;结尾的字符串</div><div class="line">$ export | grep &quot;.*yanlou$&quot;</div></pre></td></tr></table></figure></p>
<h2 id="wc-命令，简单小巧的计数工具"><a href="#wc-命令，简单小巧的计数工具" class="headerlink" title="wc 命令，简单小巧的计数工具"></a>wc 命令，简单小巧的计数工具</h2><p>wc 命令用于统计并输出一个文件中行、单词和字节的数目，比如输出/etc/passwd文件的统计信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wc /etc/passwd</div></pre></td></tr></table></figure></p>
<p>分别只输出行数、单词数、字节数、字符数和输入文本中最长一行的字节数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># 行数</div><div class="line">$ wc -l /etc/passwd</div><div class="line"># 单词数</div><div class="line">$ wc -w /etc/passwd</div><div class="line"># 字节数</div><div class="line">$ wc -c /etc/passwd</div><div class="line"># 字符数</div><div class="line">$ wc -m /etc/passwd</div><div class="line"># 最长行字节数</div><div class="line">$ wc -L /etc/passwd</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：对于西文字符来说，一个字符就是一个字节，但对于中文字符一个汉字是大于2个字节的，具体数目是由字符编码决定的  </p>
</blockquote>
<p><img src="http://i.imgur.com/psXz5S2.png" alt="">  </p>
<p>再来结合管道来操作一下，下面统计 /etc 下面所有目录数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ls -dl /etc/*/ | wc -l</div></pre></td></tr></table></figure></p>
<h1 id="sort-排序命令"><a href="#sort-排序命令" class="headerlink" title="sort 排序命令"></a>sort 排序命令</h1><p>功能很简单就是将输入按照一定方式排序，然后再输出,它支持的排序有按字典排序,数字排序，按月份排序，随机排序，反转排序，指定特定字段进行排序等等。</p>
<p>默认为字典排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat /etc/passswd | sort</div></pre></td></tr></table></figure></p>
<p>反转排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat /etc/passwd | sort -r</div></pre></td></tr></table></figure></p>
<p>按特定字段排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat /etc/passwd | sort -t&apos;:&apos; -k 3</div></pre></td></tr></table></figure></p>
<p>上面的-t参数用于指定字段的分隔符，这里是以”:”作为分隔符；-k 字段号用于指定对哪一个字段进行排序。这里/etc/passwd文件的第三个字段为数字，默认情况下是以字典序排序的，如果要按照数字排序就要加上-n参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat /etc/passwd | sort -t&apos;:&apos; -k 3 -n</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/pQsr7fv.png" alt="">  </p>
<h2 id="uniq-去重命令"><a href="#uniq-去重命令" class="headerlink" title="uniq 去重命令"></a>uniq 去重命令</h2><p>uniq命令可以用于过滤或者输出重复行。  </p>
<p>过滤重复行<br>我们可以使用history命令查看最近执行过的命令（实际为读取${SHELL}_history文件,如我们环境中的~/.zsh_history文件），不过你可能只想查看使用了那个命令而不需要知道具体干了什么，那么你可能就会要想去掉命令后面的参数然后去掉重复的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | uniq</div></pre></td></tr></table></figure></p>
<p>然后经过层层过滤，你会发现确是只输出了执行的命令那一列，不过去重效果好像不明显，仔细看你会发现它确实去重了，只是不那么明显，之所以不明显是因为uniq命令只能去连续重复的行，不是全文去重，所以要达到预期效果，我们先排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort | uniq</div><div class="line"># 或者$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort -u</div></pre></td></tr></table></figure></p>
<p>输出重复行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 输出重复过的行（重复的只输出一个）及重复次数</div><div class="line">$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort | uniq -dc</div><div class="line"># 输出所有重复的行</div><div class="line">$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort | uniq -D</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;命令执行顺序的控制&quot;&gt;&lt;a href=&quot;#命令执行顺序的控制&quot; class=&quot;headerlink&quot; title=&quot;命令执行顺序的控制&quot;&gt;&lt;/a&gt;命令执行顺序的控制&lt;/h1&gt;&lt;h2 id=&quot;顺序执行多条命令&quot;&gt;&lt;a href=&quot;#顺序执行多条命令&quot; class=&quot;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Linux/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux基础" scheme="http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>15_Linux 日志系统</title>
    <link href="http://yoursite.com/2017/07/07/Linux/Base/15_Linux%20%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2017/07/07/Linux/Base/15_Linux 日志系统/</id>
    <published>2017-07-07T12:59:47.000Z</published>
    <updated>2017-07-07T12:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见的日志"><a href="#常见的日志" class="headerlink" title="常见的日志"></a>常见的日志</h1><p>在 Linux 中大部分的发行版都内置使用 syslog 系统日志，常见的日志一般存放在 /var/log 中，我们来看看其中有哪些日志</p>
<p><img src="http://i.imgur.com/8nYxtpg.png" alt="">  </p>
<p>根据服务对象粗略的将日志分为两类</p>
<ul>
<li>系统日志</li>
<li>应用日志</li>
</ul>
<p>系统日志主要是存放系统内置程序或系统内核之类的日志信息如 alternatives.log 、btmp 等等，应用日志主要是我们装的第三方应用所产生的日志如 tomcat7 、apache2 等等。  </p>
<p>常见的系统日志</p>
<table>
<thead>
<tr>
<th>日志名称</th>
<th>记录信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>alternatives.log</td>
<td>系统的一些更新替代信息记录</td>
</tr>
<tr>
<td>apport.log</td>
<td>应用程序崩溃信息记录</td>
</tr>
<tr>
<td>apt/history.log</td>
<td>使用 apt-get 安装卸载软件的信息记录</td>
</tr>
<tr>
<td>apt/term.log</td>
<td>使用 apt-get 时的具体操作，如 package 的下载、打开等</td>
</tr>
<tr>
<td>auth.log</td>
<td>登录认证的信息记录</td>
</tr>
<tr>
<td>boot.log</td>
<td>系统启动时的程序服务的日志信息</td>
</tr>
<tr>
<td>btmp</td>
<td>错误登陆的信息记录</td>
</tr>
<tr>
<td>Consolekit/history</td>
<td>控制台的信息记录</td>
</tr>
<tr>
<td>dist-upgrade</td>
<td>dist-upgrade这种更新方式的信息记录</td>
</tr>
<tr>
<td>dmesg</td>
<td>启动时，显示屏幕上内核缓冲信息,与硬件有关的信息</td>
</tr>
<tr>
<td>dpkg.log    dpkg</td>
<td>命令管理包的日志。</td>
</tr>
<tr>
<td>faillog</td>
<td>用户登录失败详细信息记录</td>
</tr>
<tr>
<td>fontconfig.log</td>
<td>与字体配置有关的信息记录</td>
</tr>
<tr>
<td>kern.log</td>
<td>内核产生的信息记录，在自己修改内核时有很大帮助</td>
</tr>
<tr>
<td>lastlog</td>
<td>用户的最近信息记录</td>
</tr>
<tr>
<td>wtmp</td>
<td>登录信息的记录。wtmp可以找出谁正在登陆进入系统，谁使用命令显示这个文件或信息等</td>
</tr>
<tr>
<td>syslog</td>
<td>系统信息记录</td>
</tr>
</tbody>
</table>
<p>来看 alternatives.log 中的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">update-alternatives 2016-07-02 13:36:16: run with --install /usr/bin/x-www-browser x-www-browser /usr/bin/google-chrome-stable 200</div><div class="line">update-alternatives 2016-07-02 13:36:16: run with --install /usr/bin/gnome-www-browser gnome-www-browser /usr/bin/google-chrome-stable 200</div><div class="line">update-alternatives 2016-07-02 13:36:16: run with --install /usr/bin/google-chrome google-chrome /usr/bin/google-chrome-stable 200</div></pre></td></tr></table></figure></p>
<p>从中得到信息有程序作用，日期，命令，成功与否的返回码</p>
<p>来看看 auth.log 中的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">less auth.log</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/hBaYC0S.png" alt="">  </p>
<p>从中得到的信息有日期与 ip 地址的来源以及登陆的用户与工具</p>
<p>在 apt 文件夹中的日志信息，其中有两个日志文件 history.log 与 term.log，两个日志文件的区别在于 history.log 主要记录了进行了那个操作，相关的依赖有哪些，而 term.log 则是较为具体的一些操作，主要就是下载包，打开包，安装包等等的细节操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">less /var/log/apt/history.log</div><div class="line">  </div><div class="line">less /var/log/apt/term.log</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/whmmuPD.png" alt="">  </p>
<h1 id="配置的日志"><a href="#配置的日志" class="headerlink" title="配置的日志"></a>配置的日志</h1><p>可以通过两种方式：  </p>
<ul>
<li>一种是由软件开发商自己来自定义日志格式然后指定输出日志位置；  </li>
<li>一种方式就是 Linux 提供的日志服务程序，而我们这里系统日志是通过 syslog 来实现，提供日志管理服务。  </li>
</ul>
<p>syslog 是一个系统日志记录程序，在早期的大部分 Linux 发行版都是内置 syslog，让其作为系统的默认日志收集工具，虽然时代的进步与发展，syslog 已经年老体衰跟不上时代的需求，所以他被 rsyslog 所代替了，较新的 Ubuntu、Fedora 等等都是默认使用 rsyslog 作为系统的日志收集工具  </p>
<p>rsyslog的全称是 rocket-fast system for log，它提供了高性能，高安全功能和模块化设计。rsyslog 能够接受从各种各样的来源，将其输入，输出的结果到不同的目的地。rsyslog 可以提供超过每秒一百万条消息给目标文件。  </p>
<p>这样能实时收集日志信息的程序是有其守护进程的，如 rsyslog 的守护进程便是 rsyslogd  </p>
<p>可以手动开启这项服务，然后来查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo service rsyslog start</div><div class="line">  </div><div class="line">ps aux | grep syslog</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/U8FBXoO.png" alt="">  </p>
<p>既然它是一个服务，那么它便是可以配置，为我们提供一些我们自定义的服务  </p>
<p>首先我们来看 rsyslog 的配置文件是什么样子的，而 rsyslog 的配置文件有两个，  </p>
<ul>
<li>一个是 /etc/rsyslog.conf</li>
<li>一个是 /etc/rsyslog.d/50-default.conf。</li>
</ul>
<p>第一个主要是配置的环境，也就是 rsyslog 的加载什么模块，文件的所属者等；而第二个主要是配置的 Filter Conditions<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vim /etc/rsyslog.conf </div><div class="line">  </div><div class="line">vim /etc/rsyslog.d/50-default.conf</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#首先将syslog启动起来</div><div class="line">sudo service rsyslog start</div><div class="line"></div><div class="line">#向 syslog 写入数据</div><div class="line">ping 127.0.0.1 | logger -it logger_test -p local3.notice &amp;</div><div class="line"></div><div class="line">#查看是否有数据写入</div><div class="line">tail -f /var/log/syslog</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常见的日志&quot;&gt;&lt;a href=&quot;#常见的日志&quot; class=&quot;headerlink&quot; title=&quot;常见的日志&quot;&gt;&lt;/a&gt;常见的日志&lt;/h1&gt;&lt;p&gt;在 Linux 中大部分的发行版都内置使用 syslog 系统日志，常见的日志一般存放在 /var/log 中，我们
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Linux/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux基础" scheme="http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>14_Linux 进程的查看</title>
    <link href="http://yoursite.com/2017/07/07/Linux/Base/14_Linux%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86(top,ps,pstree)/"/>
    <id>http://yoursite.com/2017/07/07/Linux/Base/14_Linux 进程管理(top,ps,pstree)/</id>
    <published>2017-07-07T12:59:47.000Z</published>
    <updated>2017-07-07T12:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程的查看"><a href="#进程的查看" class="headerlink" title="进程的查看"></a>进程的查看</h1><p>可以通过 top 实时得查看进程的状态，以及系统的一些信息（如 CPU、内存信息等），我们还可以通过 ps 来静态查看当前的进程信息，同时我们还可以使用 pstree 来查看当前活跃进程的树形结构。</p>
<h2 id="top-工具的使用"><a href="#top-工具的使用" class="headerlink" title="top 工具的使用"></a>top 工具的使用</h2><p>top 工具是我们常用的一个查看工具，能实时的查看我们系统的一些关键信息的变化:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">top</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/zUBIXpi.png" alt="">  </p>
<p>top 是一个在前台执行的程序，所以执行后便进入到这样的一个交互界面，正是因为交互界面我们才可以实时的获取到系统与进程的信息。在交互界面中我们可以通过一些指令来操作和筛选。在此之前我们先来了解显示了哪些信息。  </p>
<p>我们看到 top 显示的第一排，</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>top</td>
<td>表示当前程序的名称</td>
</tr>
<tr>
<td>11:05:18</td>
<td>表示当前的系统的时间</td>
</tr>
<tr>
<td>up 8 days,17:12</td>
<td>表示该机器已经启动了多长时间</td>
</tr>
<tr>
<td>1 user</td>
<td>表示当前系统中只有一个用户</td>
</tr>
<tr>
<td>load average: 0.29,0.20,0.25</td>
<td>分别对应1、5、15分钟内cpu的平均负载</td>
</tr>
</tbody>
</table>
<p>load average 在 wikipedia 中的解释是 the system load is a measure of the amount of work that a computer system is doing 也就是对当前 CPU 工作量的度量，具体来说也就是指运行队列的平均长度，也就是等待 CPU 的平均进程数相关的一个计算值。  </p>
<p>我们该如何看待这个load average 数据呢？  </p>
<p>假设我们的系统是单 CPU、单内核的，把它比喻成是一条单向的桥，把CPU任务比作汽车。  </p>
<ul>
<li>load = 0 的时候意味着这个桥上并没有车，cpu 没有任何任务；</li>
<li>load &lt; 1 的时候意味着桥上的车并不多，一切都还是很流畅的，cpu 的任务并不多，资源还很充足；</li>
<li>load = 1 的时候就意味着桥已经被车给沾满了，没有一点空隙，cpu 的已经在全力工作了，所有的资源都被用完了，当然还好，这还在能力范围之内，只是有点慢而已；</li>
<li>load &gt; 1 的时候就意味着不仅仅是桥上已经被车占满了，就连桥外都被占满了，cpu 已经在全力的工作了，系统资源的用完了，但是还是有大量的进程在请求，在等待。若是这个值大于２，大于３，超过 CPU 工作能力的 2，３。而若是这个值 &gt; 5 说明系统已经在超负荷运作了。【注释1】</li>
</ul>
<p>这是单个 CPU 单核的情况，而实际生活中我们需要将得到的这个值除以我们的核数来看。我们可以通过一下的命令来查看 CPU 的个数与核心数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#查看物理CPU的个数</div><div class="line">#cat /proc/cpuinfo |grep &quot;physical id&quot;|sort |uniq|wc -l</div><div class="line"></div><div class="line">#每个cpu的核心数</div><div class="line">cat /proc/cpuinfo |grep &quot;physical id&quot;|grep &quot;0&quot;|wc -l</div></pre></td></tr></table></figure></p>
<p>通过上面的指数我们可以得知 load 的临界值为 1 ，但是在实际生活中，比较有经验的运维或者系统管理员会将临界值定为0.7。这里的指数都是除以核心数以后的值，不要混淆了</p>
<ul>
<li>若是 load &lt; 0.7 并不会去关注他；</li>
<li>若是 0.7&lt; load &lt; 1 的时候我们就需要稍微关注一下了，虽然还可以应付但是这个值已经离临界不远了；</li>
<li>若是 load = 1 的时候我们就需要警惕了，因为这个时候已经没有更多的资源的了，已经在全力以赴了；</li>
<li>若是 load &gt; 5 的时候系统已经快不行了，这个时候你需要加班解决问题了</li>
</ul>
<p>通常我们都会先看 15 分钟的值来看这个大体的趋势，然后再看 5 分钟的值对比来看是否有下降的趋势。</p>
<p>查看 busybox 的代码可以知道，数据是每 5 秒钟就检查一次活跃的进程数，然后计算出该值，然后 load 从 /proc/loadavg 中读取的。而这个 load 的值是如何计算的呢，这是 load 的计算的源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#define FSHIFT      11          /* nr of bits of precision */</div><div class="line">#define FIXED_1     (1&lt;&lt;FSHIFT) /* 1.0 as fixed-point(定点) */</div><div class="line">#define LOAD_FREQ   (5*HZ)      /* 5 sec intervals，每隔5秒计算一次平均负载值 */</div><div class="line">#define CALC_LOAD(load, exp, n)     \</div><div class="line">         load *= exp;               \</div><div class="line">         load += n*(FIXED_1 - exp); \</div><div class="line">         load &gt;&gt;= FSHIFT;</div><div class="line"></div><div class="line">unsigned long avenrun[3];</div><div class="line"></div><div class="line">EXPORT_SYMBOL(avenrun);</div><div class="line"></div><div class="line">/*</div><div class="line">* calc_load - given tick count, update the avenrun load estimates.</div><div class="line">* This is called while holding a write_lock on xtime_lock.</div><div class="line">*/</div><div class="line">static inline void calc_load(unsigned long ticks)</div><div class="line">&#123;</div><div class="line">        unsigned long active_tasks; /* fixed-point */</div><div class="line">        static int count = LOAD_FREQ;</div><div class="line">        count -= ticks;</div><div class="line">        if (count &lt; 0) &#123;</div><div class="line">                count += LOAD_FREQ;</div><div class="line">                active_tasks = count_active_tasks();</div><div class="line">                CALC_LOAD(avenrun[0], EXP_1, active_tasks);</div><div class="line">                CALC_LOAD(avenrun[1], EXP_5, active_tasks);</div><div class="line">                CALC_LOAD(avenrun[2], EXP_15, active_tasks);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>来看 top 的第二行数据，基本上第二行是进程的一个情况统计</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tasks: 26 total</td>
<td>进程总数</td>
</tr>
<tr>
<td>1 running</td>
<td>1个正在运行的进程数</td>
</tr>
<tr>
<td>25 sleeping</td>
<td>25个睡眠的进程数</td>
</tr>
<tr>
<td>0 stopped</td>
<td>没有停止的进程数</td>
</tr>
<tr>
<td>0 zombie</td>
<td>没有僵尸进程数</td>
</tr>
</tbody>
</table>
<p>来看 top 的第三行数据，这一行基本上是 CPU 的一个使用情况的统计了</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cpu(s): 1.0%us</td>
<td>用户空间进程占用CPU百分比</td>
</tr>
<tr>
<td>1.0% sy</td>
<td>内核空间运行占用CPU百分比</td>
</tr>
<tr>
<td>0.0%ni</td>
<td>用户进程空间内改变过优先级的进程占用CPU百分比</td>
</tr>
<tr>
<td>97.9%id</td>
<td>空闲CPU百分比</td>
</tr>
<tr>
<td>0.0%wa</td>
<td>等待输入输出的CPU时间百分比</td>
</tr>
<tr>
<td>0.1%hi</td>
<td>硬中断(Hardware IRQ)占用CPU的百分比</td>
</tr>
<tr>
<td>0.0%si</td>
<td>软中断(Software IRQ)占用CPU的百分比</td>
</tr>
<tr>
<td>0.0%st</td>
<td>(Steal time) 是 hypervisor 等虚拟服务中，虚拟 CPU 等待实际 CPU 的时间的百分比</td>
</tr>
</tbody>
</table>
<p>CPU 利用率是对一个时间段内 CPU 使用状况的统计，通过这个指标可以看出在某一个时间段内 CPU 被占用的情况，而 Load Average 是 CPU 的 Load，它所包含的信息不是 CPU 的使用率状况，而是在一段时间内 CPU 正在处理以及等待 CPU 处理的进程数情况统计信息，这两个指标并不一样。  </p>
<p>来看 top 的第四行数据，这一行基本上是内存的一个使用情况的统计了：</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>8176740 total</td>
<td>物理内存总量</td>
</tr>
<tr>
<td>8032104 used</td>
<td>使用的物理内存总量</td>
</tr>
<tr>
<td>144636 free</td>
<td>空闲内存总量</td>
</tr>
<tr>
<td>313088 buffers</td>
<td>用作内核缓存的内存量</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意<br>系统的中可用的物理内存最大值并不是 free 这个单一的值，而是 free + buffers + swap 中的 cached 的和</p>
</blockquote>
<p>来看 top 的第五行数据，这一行基本上是交换区的一个使用情况的统计了</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>total</td>
<td>交换区总量</td>
</tr>
<tr>
<td>used</td>
<td>使用的交换区总量</td>
</tr>
<tr>
<td>free</td>
<td>空闲交换区总量</td>
</tr>
<tr>
<td>cached</td>
<td>缓冲的交换区总量,内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>在下面就是进程的一个情况了</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>PID</td>
<td>进程id</td>
</tr>
<tr>
<td>USER</td>
<td>该进程的所属用户</td>
</tr>
<tr>
<td>PR</td>
<td>该进程执行的优先级 priority 值</td>
</tr>
<tr>
<td>NI</td>
<td>该进程的 nice 值</td>
</tr>
<tr>
<td>VIRT</td>
<td>该进程任务所使用的虚拟内存的总数</td>
</tr>
<tr>
<td>RES</td>
<td>该进程所使用的物理内存数，也称之为驻留内存数</td>
</tr>
<tr>
<td>SHR</td>
<td>该进程共享内存的大小</td>
</tr>
<tr>
<td>S</td>
<td>该进程进程的状态: S=sleep R=running Z=zombie</td>
</tr>
<tr>
<td>%CPU</td>
<td>该进程CPU的利用率</td>
</tr>
<tr>
<td>%MEM</td>
<td>该进程内存的利用率</td>
</tr>
<tr>
<td>TIME+</td>
<td>该进程活跃的总时间</td>
</tr>
<tr>
<td>COMMAND</td>
<td>该进程运行的名字</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意</p>
<p>NICE 值叫做静态优先级，是用户空间的一个优先级值，其取值范围是-20至19。这个值越小，表示进程”优先级”越高，而值越大“优先级”越低。nice值中的 -20 到 19，中 -20 优先级最高， 0 是默认的值，而 19 优先级最低</p>
<p>PR 值表示 Priority 值叫动态优先级，是进程在内核中实际的优先级值，进程优先级的取值范围是通过一个宏定义的，这个宏的名称是 MAX_PRIO，它的值为 140。Linux 实际上实现了 140 个优先级范围，取值范围是从 0-139，这个值越小，优先级越高。而这其中的 0 - 99 是实时进程的值，而 100 - 139 是给用户的。</p>
<p>其中 PR 中的 100 to 139 值部分有这么一个对应 PR = 20 + (-20 to +19)，这里的 -20 to +19 便是nice值，所以说两个虽然都是优先级，而且有千丝万缕的关系，但是他们的值，他们的作用范围并不相同</p>
<p>VIRT 任务所使用的虚拟内存的总数，其中包含所有的代码，数据，共享库和被换出 swap空间的页面等所占据空间的总数</p>
</blockquote>
<p>在上文我们曾经说过 top 是一个前台程序，所以是一个可以交互的</p>
<table>
<thead>
<tr>
<th>常用交互命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>q</td>
<td>退出程序</td>
</tr>
<tr>
<td>I</td>
<td>切换显示平均负载和启动时间的信息</td>
</tr>
<tr>
<td>P</td>
<td>根据CPU使用百分比大小进行排序</td>
</tr>
<tr>
<td>M</td>
<td>根据驻留内存大小进行排序</td>
</tr>
<tr>
<td>i</td>
<td>忽略闲置和僵死的进程，这是一个开关式命令</td>
</tr>
<tr>
<td>k</td>
<td>终止一个进程，系统提示输入 PID 及发送的信号值。一般终止进程用 15 信号，不能正常结束则使用 9 信号。安全模式下该命令被屏蔽。</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h2 id="ps-工具的使用"><a href="#ps-工具的使用" class="headerlink" title="ps 工具的使用"></a>ps 工具的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps aux</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/uS7vjWp.png" alt="">  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps axjf</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/x9j1F7j.png" alt="">  </p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>F</td>
<td>进程的标志（process flags），当 flags 值为 1 则表示此子程序只是 fork 但没有执行 exec，为 4 表示此程序使用超级管理员 root 权限</td>
</tr>
<tr>
<td>USER</td>
<td>进程的拥有用户</td>
</tr>
<tr>
<td>PID</td>
<td>进程的 ID</td>
</tr>
<tr>
<td>PPID</td>
<td>其父进程的 PID</td>
</tr>
<tr>
<td>SID</td>
<td>session 的 ID</td>
</tr>
<tr>
<td>TPGID</td>
<td>前台进程组的 ID</td>
</tr>
<tr>
<td>%CPU</td>
<td>进程占用的 CPU 百分比</td>
</tr>
<tr>
<td>%MEM</td>
<td>占用内存的百分比</td>
</tr>
<tr>
<td>NI</td>
<td>进程的 NICE 值</td>
</tr>
<tr>
<td>VSZ</td>
<td>进程使用虚拟内存大小</td>
</tr>
<tr>
<td>RSS</td>
<td>驻留内存中页的大小</td>
</tr>
<tr>
<td>TTY</td>
<td>终端 ID</td>
</tr>
<tr>
<td>S or STAT</td>
<td>进程状态</td>
</tr>
<tr>
<td>WCHAN</td>
<td>正在等待的进程资源</td>
</tr>
<tr>
<td>START</td>
<td>启动进程的时间</td>
</tr>
<tr>
<td>TIME</td>
<td>进程消耗CPU的时间</td>
</tr>
<tr>
<td>COMMAND</td>
<td>命令的名称和参数　</td>
</tr>
</tbody>
</table>
<blockquote>
<p>TPGID栏写着-1的都是没有控制终端的进程，也就是守护进程</p>
</blockquote>
<p>STAT表示进程的状态，而进程的状态有很多，如下表所示</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>R</td>
<td>Running.运行中</td>
</tr>
<tr>
<td>S</td>
<td>Interruptible Sleep.等待调用</td>
</tr>
<tr>
<td>D</td>
<td>Uninterruptible Sleep.不可中断睡眠</td>
</tr>
<tr>
<td>T</td>
<td>Stoped.暂停或者跟踪状态</td>
</tr>
<tr>
<td>X</td>
<td>Dead.即将被撤销</td>
</tr>
<tr>
<td>Z</td>
<td>Zombie.僵尸进程</td>
</tr>
<tr>
<td>W</td>
<td>Paging.内存交换</td>
</tr>
<tr>
<td>N</td>
<td>优先级低的进程</td>
</tr>
<tr>
<td>&lt;</td>
<td>优先级高的进程</td>
</tr>
<tr>
<td>s</td>
<td>进程的领导者</td>
</tr>
<tr>
<td>L</td>
<td>锁定状态</td>
</tr>
<tr>
<td>l</td>
<td>多线程状态</td>
</tr>
<tr>
<td>+</td>
<td>前台进程</td>
</tr>
</tbody>
</table>
<blockquote>
<p>其中的 D 是不能被中断睡眠的状态，处在这种状态的进程不接受外来的任何 signal，所以无法使用 kill 命令杀掉处于D状态的进程，无论是 kill，kill -9 还是 kill -15，一般处于这种状态可能是进程 I/O 的时候出问题了。</p>
</blockquote>
<ul>
<li>使用 -l 参数可以显示自己这次登陆的 bash 相关的进程信息罗列出来<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -l</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://i.imgur.com/hxy6SN8.png" alt="">  </p>
<ul>
<li>罗列出所有的进程信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps aux</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://i.imgur.com/Ka02pI8.png" alt="">  </p>
<ul>
<li>若是查找其中的某个进程的话，还可以配合着 grep 和正则表达式一起使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps aux | grep zsh</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://i.imgur.com/nvI05AN.png" alt="">  </p>
<ul>
<li>查看时，将连同部分的进程呈树状显示出来<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps axjf</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://i.imgur.com/2KYIPZf.png" alt="">  </p>
<h2 id="pstree-工具的使用"><a href="#pstree-工具的使用" class="headerlink" title="pstree 工具的使用"></a>pstree 工具的使用</h2><p>通过 pstree 可以很直接的看到相同的进程数量，最主要的还是我们可以看到所有进程的之间的相关性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pstree</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/FhiQitW.png" alt="">  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">pstree -up</div><div class="line"></div><div class="line">#参数选择：</div><div class="line">#-A  ：各程序树之间以 ASCII 字元來連接；</div><div class="line">#-p  ：同时列出每个 process 的 PID；</div><div class="line">#-u  ：同时列出每个 process 的所屬账户名称。</div></pre></td></tr></table></figure>
<h1 id="进程的管理"><a href="#进程的管理" class="headerlink" title="进程的管理"></a>进程的管理</h1><h2 id="kill-命令的掌握"><a href="#kill-命令的掌握" class="headerlink" title="kill 命令的掌握"></a>kill 命令的掌握</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#首先我们使用图形界面打开了 gedit、gvim，用 ps 可以查看到</div><div class="line">ps aux</div><div class="line">  </div><div class="line">#使用9这个信号强制结束 gedit 进程</div><div class="line">kill -9 1608</div><div class="line">  </div><div class="line">#我们在查找这个进程的时候就找不到了</div><div class="line">ps aux | grep gedit</div></pre></td></tr></table></figure>
<h1 id="进程的执行顺序"><a href="#进程的执行顺序" class="headerlink" title="进程的执行顺序"></a>进程的执行顺序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#打开一个程序放在后台，或者用图形界面打开</div><div class="line">nice -n -5 vim &amp;</div><div class="line"></div><div class="line">#用 ps 查看其优先级</div><div class="line">ps -afxo user,ppid,pid,stat,pri,ni,time,command | grep vim</div></pre></td></tr></table></figure>
<p>还可以用 renice 来修改已经存在的进程的优先级，同样因为权限的原因在实验环境中无法尝试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">renice -5 pid</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;进程的查看&quot;&gt;&lt;a href=&quot;#进程的查看&quot; class=&quot;headerlink&quot; title=&quot;进程的查看&quot;&gt;&lt;/a&gt;进程的查看&lt;/h1&gt;&lt;p&gt;可以通过 top 实时得查看进程的状态，以及系统的一些信息（如 CPU、内存信息等），我们还可以通过 ps 来静态查
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Linux/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux基础" scheme="http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>13_Linux 进程与程序</title>
    <link href="http://yoursite.com/2017/07/07/Linux/Base/13_Linux%20%E8%BF%9B%E7%A8%8B(pstree,&amp;,jobs,fg,bg,kill)/"/>
    <id>http://yoursite.com/2017/07/07/Linux/Base/13_Linux 进程(pstree,&amp;,jobs,fg,bg,kill)/</id>
    <published>2017-07-07T12:59:47.000Z</published>
    <updated>2017-07-07T12:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程与程序"><a href="#进程与程序" class="headerlink" title="进程与程序"></a>进程与程序</h1><blockquote>
<p>程序（procedure）：不太精确地说，程序就是执行一系列有逻辑、有顺序结构的指令，帮我们达成某个结果。就如我们去餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，最后我们得到了这么一盘牛肉盖浇饭。它需要去执行，不然它就像一本武功秘籍，放在那里等人翻看。  </p>
<p>进程（process）：进程是程序在一个数据集合上的一次执行过程，在早期的UNIX、Linux 2.4及更早的版本中，它是系统进行资源分配和调度的独立基本单位。同上一个例子，就如我们去了餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，而里面做饭的是一个进程，做牛肉汤汁的是一个进程，把牛肉汤汁与饭混合在一起的是一个进程，把饭端上桌的是一个进程。它就像是我们在看武功秘籍这么一个过程，然后一个篇章一个篇章地去练。  </p>
</blockquote>
<p>程序只是一些列指令的集合，是一个静止的实体，而进程不同，进程有以下的特性：  </p>
<ul>
<li>动态性：进程的实质是一次程序执行的过程，有创建、撤销等状态的变化。而程序是一个静态的实体。</li>
<li>并发性：进程可以做到在一个时间段内，有多个程序在运行中。程序只是静态的实体，所以不存在并发性。</li>
<li>独立性：进程可以独立分配资源，独立接受调度，独立地运行。</li>
<li>异步性：进程以不可预知的速度向前推进。</li>
<li>结构性：进程拥有代码段、数据段、PCB（进程控制块，进程存在的唯一标志）。也正是因为有结构性，进程才可以做到独立地运行。</li>
</ul>
<blockquote>
<p>并发：在一个时间段内，宏观来看有多个程序都在活动，有条不紊的执行（每一瞬间只有一个在执行，只是在一段时间有多个程序都执行过）</p>
<p>并行：在每一个瞬间，都有多个程序都在同时执行，这个必须有多个 CPU 才行</p>
</blockquote>
<p>引入进程是因为传统意义上的程序已经不足以描述 OS 中各种活动之间的动态性、并发性、独立性还有相互制约性。程序就像一个公司，只是一些证书，文件的堆积（静态实体）。而当公司运作起来就有各个部门的区分，财务部，技术部，销售部等等，就像各个进程，各个部门之间可以独立运做，也可以有交互（独立性、并发性）。  </p>
<p>而随着程序的发展越做越大，又会继续细分，从而引入了线程的概念，当代多数操作系统、Linux 2.6及更新的版本中，进程本身不是基本运行单位，而是线程的容器。就像上述所说的，每个部门又会细分为各个工作小组（线程），而工作小组需要的资源需要向上级（进程）申请。  </p>
<blockquote>
<p>线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。因为线程中几乎不包含系统资源，所以执行更快、更有效率。</p>
</blockquote>
<p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p>
<p><img src="http://i.imgur.com/srhDdXb.png" alt=""></p>
<h1 id="进程的属性"><a href="#进程的属性" class="headerlink" title="进程的属性"></a>进程的属性</h1><h2 id="进程的分类"><a href="#进程的分类" class="headerlink" title="进程的分类"></a>进程的分类</h2><p>大概明白进程是个什么样的存在后，我们需要进一步了解的就是进程分类。可以从两个角度来分：</p>
<ul>
<li>以进程的功能与服务的对象来分；</li>
<li>以应用程序的服务类型来分；</li>
</ul>
<p>第一个角度来看，我们可以分为用户进程与系统进程：</p>
<ul>
<li>用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。</li>
<li>系统进程：通过执行系统内核程序而产生的进程，比如可以执行内存资源分配和进程切换等相对底层的工作；而且该进程的运行不受用户的干预，即使是 root 用户也不能干预系统进程的运行。</li>
</ul>
<p>第二角度来看，我们可以将进程分为交互进程、批处理进程、守护进程</p>
<ul>
<li>交互进程：由一个 shell 终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。</li>
<li>批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。</li>
<li>守护进程：守护进程是一直运行的一种进程，在 Linux 系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如 httpd 进程，一直处于运行状态，等待用户的访问。还有经常用的 cron（在 centOS 系列为 crond）进程，这个进程为 crontab 的守护进程，可以周期性的执行用户设定的某些任务。</li>
</ul>
<h2 id="进程的衍生"><a href="#进程的衍生" class="headerlink" title="进程的衍生"></a>进程的衍生</h2><p>比如我们启动了终端，就是启动了一个 bash 进程，我们可以在 bash 中再输入 bash 则会再启动一个 bash 的进程，此时第二个 bash 进程就是由第一个 bash 进程创建出来的，他们直接又是个什么关系？  </p>
<p>我们一般称呼第一个 bash 进程是第二 bash 进程的父进程，第二 bash 进程是第一个 bash 进程的子进程，这层关系是如何得来的呢？  </p>
<p>关于父进程与子进程便会提及这两个系统调用 fork() 与 exec()  </p>
<blockquote>
<p>fork-exec是由 Dennis M. Ritchie 创造的</p>
<p>fork() 是一个系统调用（system call），它的主要作用就是为当前的进程创建一个新的进程，这个新的进程就是它的子进程，这个子进程除了父进程的返回值和 PID 以外其他的都一模一样，如进程的执行代码段，内存信息，文件描述，寄存器状态等等</p>
<p>exec() 也是系统调用，作用是切换子进程中的执行程序也就是替换其从父进程复制过来的代码段与数据段</p>
</blockquote>
<p>子进程就是父进程通过系统调用 fork() 而产生的复制品，fork() 就是把父进程的 PCB 等进程的数据结构信息直接复制过来，只是修改了 PID，所以一模一样，只有在执行 exec() 之后才会不同，而早先的 fork() 比较消耗资源后来进化成 vfork(),效率高了不少。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">pid_t p;</div><div class="line">  </div><div class="line">p = fork();</div><div class="line">if (p == (pid_t) -1)</div><div class="line">        /* ERROR */</div><div class="line">else if (p == 0)</div><div class="line">        /* CHILD */</div><div class="line">else</div><div class="line">        /* PARENT */</div></pre></td></tr></table></figure>
<p>既然子进程是通过父进程而衍生出来的，那么子进程的退出与资源的回收定然与父进程有很大的相关性。当一个子进程要正常的终止运行时，或者该进程结束时它的主函数 main() 会执行 exit(n); 或者 return n，这里的返回值 n 是一个信号，系统会把这个 SIGCHLD 信号传给其父进程，当然若是异常终止也往往是因为这个信号。  </p>
<p>在将要结束时的子进程代码执行部分已经结束执行了，系统的资源也基本归还给系统了，但若是其进程的进程控制块（PCB）仍驻留在内存中，而它的 PCB 还在，代表这个进程还存在（因为 PCB 就是进程存在的唯一标志，里面有 PID 等消息），并没有消亡，这样的进程称之为僵尸进程（Zombie）。  </p>
<p>如图中第四列标题是 S，S 表示的是进程的状态，而在下属的第三行的 Z 表示的是 Zombie 的意思。（ ps 命令将在后续详解）  </p>
<p><img src="http://i.imgur.com/fwSfuhx.png" alt="">  </p>
<p>正常情况下，父进程会收到两个返回值：exit code（SIGCHLD 信号）与 reason for termination 。之后，父进程会使用 wait(&amp;status) 系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的 PCB；而如若父进程没有这么做的话，子进程的 PCB 就会一直驻留在内存中，一直留在系统中成为僵尸进程（Zombie）。  </p>
<p>虽然僵尸进程是已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，在进程列表中保留一个位置，记载该进程的退出状态等信息供其父进程收集，从而释放它。但是 Linux 系统中能使用的 PID 是有限的，如果系统中存在有大量的僵尸进程，系统将会因为没有可用的 PID 从而导致不能产生新的进程。  </p>
<p>另外如果父进程结束（非正常的结束），未能及时收回子进程，子进程仍在运行，这样的子进程称之为孤儿进程。在 Linux 系统中，孤儿进程一般会被 init 进程所“收养”，成为 init 的子进程。由 init 来做善后处理，所以它并不至于像僵尸进程那样无人问津，不管不顾，大量存在会有危害。  </p>
<p>进程 0 是系统引导时创建的一个特殊进程，也称之为内核初始化，其最后一个动作就是调用 fork() 创建出一个子进程运行 /sbin/init 可执行文件,而该进程就是 PID=1 的进程 1，而进程 0 就转为交换进程（也被称为空闲进程），进程 1 （init 进程）是第一个用户态的进程，再由它不断调用 fork() 来创建系统里其他的进程，所以它是所有进程的父进程或者祖先进程。同时它是一个守护程序，直到计算机关机才会停止。  </p>
<p>通过以下的命令我们可以很明显的看到这样的结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pstree</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/4Y1j8Bn.png" alt="">  </p>
<p>或者从此图可以更加形象的看清子父进程的关系</p>
<p><img src="http://i.imgur.com/AR8rlHI.png" alt="">  </p>
<p>通过以上的显示结果我们可以看的很清楚，init 为所有进程的父进程或者说是祖先进程  </p>
<p>我们还可以使用这样一个命令来看，其中 pid 就是该进程的一个唯一编号，ppid 就是该进程的父进程的 pid，command 表示的是该进程通过执行什么样的命令或者脚本而产生的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps －fxo user,ppid,pid,pgid,command</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/kYJ2idS.png" alt="">  </p>
<p>可以在图中看见我们执行的 ps 就是由 zsh 通过 fork-exec 创建的子进程而执行的</p>
<p>使用这样的一个命令我们也能清楚的看见 init 如上文所说是由进程 0 这个初始化进程来创建而出的子进程,而其他的进程基本是由 init 创建的子进程，或者是由它的子进程创建出来的子进程。所以 init 是用户进程的第一个进程也是所有用户进程的父进程或者祖先进程。（ps 命令将在后续课程详解）</p>
<p>就像一个树状图，而 init 进程就是这棵树的根，其他进程由根不断的发散，开枝散叶</p>
<h2 id="进程组与-Sessions"><a href="#进程组与-Sessions" class="headerlink" title="进程组与 Sessions"></a>进程组与 Sessions</h2><p>每一个进程都会是一个进程组的成员，而且这个进程组是唯一存在的，他们是依靠 PGID（process group ID）来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。  </p>
<p>一般情况，进程组的 PGID 等同于进程组的第一个成员的 PID，并且这样的进程称为该进程组的领导者,也就是领导进程，进程一般通过使用 getpgrp() 系统调用来寻找其所在组的 PGID，领导进程可以先终结，此时进程组依然存在，并持有相同的PGID，直到进程组中最后一个进程终结。  </p>
<p>与进程组类似，每当一个进程被创建的时候，它便会成为其父进程所在 Session 中的一员，每一个进程组都会在一个 Session 中，并且这个 Session 是唯一存在的，  </p>
<p>Session 主要是针对一个 tty 建立，Session 中的每个进程都称为一个工作(job)。每个会话可以连接一个终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。Session 意义在于将多个 jobs 囊括在一个终端，并取其中的一个 job 作为前台，来直接接收该终端的输入输出以及终端信号。 其他 jobs 在后台运行。  </p>
<blockquote>
<p>前台（foreground）就是在终端中运行，能与你有交互的</p>
<p>后台（background）就是在终端中运行，但是你并不能与其任何的交互，也不会显示其执行的过程</p>
</blockquote>
<h2 id="工作管理"><a href="#工作管理" class="headerlink" title="工作管理"></a>工作管理</h2><p>bash(Bourne-Again shell)支持工作控制（job control）,而 sh（Bourne shell）并不支持。  </p>
<p>并且每个终端或者说 bash 只能管理当前终端的中的 job，不能管理其他终端中的 job。比如我当前存在两个 bash 分别为 bash1、bash2，bash1 只能管理其自己里面的 job 并不能管理 bash2 里面的 job  </p>
<p>我们都知道当一个进程在前台运作时我们可以用 ctrl + c 来终止它，但是若是在后台的话就不行了。  </p>
<p>我们可以通过 &amp; 这个符号，让我们的命令在后台中运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls &amp;</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/t6njbEZ.png" alt="">  </p>
<p>图中所显示的 [1] 236分别是该 job 的 job number 与该进程的 PID，而最后一行的 Done 表示该命令已经在后台执行完毕。  </p>
<p>我们还可以通过 ctrl + z 使我们的当前工作停止并丢到后台中去  </p>
<p><img src="http://i.imgur.com/mme7wlc.png" alt="">  </p>
<p>被停止并放置在后台的工作我们可以使用这个命令来查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jobs</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/UtOmOw4.png" alt="">  </p>
<p>其中第一列显示的为被放置后台 job 的编号，而第二列的 ＋ 表示最近(刚刚、最后)被放置后台的 job，同时也表示预设的工作，也就是若是有什么针对后台 job 的操作，首先对预设的 job，- 表示倒数第二（也就是在预设之前的一个）被放置后台的工作，倒数第三个（再之前的）以后都不会有这样的符号修饰，第三列表示它们的状态，而最后一列表示该进程执行的命令  </p>
<p>我们可以通过这样的一个命令将后台的工作拿到前台来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#后面不加参数提取预设工作，加参数提取指定工作的编号</div><div class="line">#ubuntu 在 zsh 中需要 %，在 bash 中不需要 %</div><div class="line">fg [%jobnumber]</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/TTxSjQC.png" alt=""><br><img src="http://i.imgur.com/wWiI1wb.png" alt="">  </p>
<p>之前我们通过 ctrl + z 使得工作停止放置在后台，若是我们想让其在后台运作我们就使用这样一个命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#与fg类似，加参则指定，不加参则取预设</div><div class="line">bg [%jobnumber]</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/ZsVKHUW.png" alt="">  </p>
<p>既然有方法将被放置在后台的工作提至前台或者让它从停止变成继续运行在后台，当然也有方法删除一个工作，或者重启等等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#kill的使用格式如下</div><div class="line">kill -signal %jobnumber</div><div class="line">  </div><div class="line">#signal从1-64个信号值可以选择，可以这样查看</div><div class="line">kill －l</div></pre></td></tr></table></figure></p>
<p>其中常用的有这些信号值  </p>
<table>
<thead>
<tr>
<th>信号值</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-1</td>
<td>重新读取参数运行，类似与restart</td>
</tr>
<tr>
<td>-2</td>
<td>如同 ctrl+c 的操作退出</td>
</tr>
<tr>
<td>-9</td>
<td>强制终止该任务</td>
</tr>
<tr>
<td>-15</td>
<td>正常的方式终止该任务</td>
</tr>
</tbody>
</table>
<p><img src="http://i.imgur.com/ooBuH04.png" alt="">  </p>
<blockquote>
<p>注意:</p>
<p>若是在使用kill＋信号值然后直接加 pid，你将会对 pid 对应的进程进行操作</p>
<p>若是在使用kill+信号值然后 ％jobnumber，这时所操作的对象是 job，这个数字就是就当前 bash 中后台的运行的 job 的 ID</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;进程与程序&quot;&gt;&lt;a href=&quot;#进程与程序&quot; class=&quot;headerlink&quot; title=&quot;进程与程序&quot;&gt;&lt;/a&gt;进程与程序&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;程序（procedure）：不太精确地说，程序就是执行一系列有逻辑、有顺序结构的指令，帮我
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Linux/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux基础" scheme="http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>01_用户及文件权限管理</title>
    <link href="http://yoursite.com/2017/07/07/Linux/Base/01_%E7%94%A8%E6%88%B7%E5%8F%8A%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86(sudo,su%20-,su,groups,ls,chown,chmod,%20adduser,useradd,deluser,userdel)/"/>
    <id>http://yoursite.com/2017/07/07/Linux/Base/01_用户及文件权限管理(sudo,su -,su,groups,ls,chown,chmod, adduser,useradd,deluser,userdel)/</id>
    <published>2017-07-07T12:59:47.000Z</published>
    <updated>2017-07-07T12:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用户及文件权限管理"><a href="#用户及文件权限管理" class="headerlink" title="用户及文件权限管理"></a>用户及文件权限管理</h1><h2 id="Linux用户管理"><a href="#Linux用户管理" class="headerlink" title="Linux用户管理"></a>Linux用户管理</h2><h3 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">who am i  </div><div class="line">liaoyujian pts/0 2017-11-19 17:10(:1.0)</div></pre></td></tr></table></figure>
<p>输出的第一列表示打开当前伪终端的用户的用户名（要查看当前登录用户的用户名，去掉空格直接使用 whoami 即可），第二列的 pts/0 中 pts 表示伪终端，所谓伪是相对于 /dev/tty 设备而言的，还记得上一节讲终端时的那七个使用 [Ctrl]+[Alt]+[F1]～[F7] 进行切换的 /dev/tty 设备么,这是“真终端”，伪终端就是当你在图形用户界面使用 /dev/tty7 时每打开一个终端就会产生一个伪终端， pts/0 后面那个数字就表示打开的伪终端序号，你可以尝试再打开一个终端，然后在里面输入 who am i ，看第二列是不是就变成 pts/1 了，第三列则表示当前伪终端的启动时间。  </p>
<p>who 命令其它常用参数  </p>
<p>参数    说明<br>-a    打印能打印的全部<br>-d    打印死掉的进程<br>-m    同am i,mom likes<br>-q    打印当前登录用户数及用户名<br>-u    打印当前登录用户登录信息<br>-r    打印运行等级  </p>
<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>在 Linux 系统里， root 账户拥有整个系统至高无上的权利，比如 新建/添加 用户。  </p>
<blockquote>
<p>root 权限，系统权限的一种，与 SYSTEM 权限可以理解成一个概念，但高于 Administrator 权限，root 是 Linux 和 UNIX 系统中的超级管理员用户帐户，该帐户拥有整个系统至高无上的权力，所有对象他都可以操作，所以很多黑客在入侵系统的时候，都要把权限提升到 root 权限，用 Windows 的方法理解也就是将自己的非法帐户添加到 Administrators 用户组。更比如安卓操作系统中（基于 Linux 内核）获得 root 权限之后就意味着已经获得了手机的最高权限，这时候你可以对手机中的任何文件（包括系统文件）执行所有增、删、改、查的操作。</p>
</blockquote>
<p>我们一般登录系统时都是以普通账户的身份登录的，要创建用户需要 root 权限，这里就要用到 sudo 这个命令了。不过使用这个命令有两个大前提，一是你要知道当前登录用户的密码，二是当前用户必须在 sudo 用户组。shiyanlou 用户也属于 sudo 用户组（稍后会介绍如何查看和添加用户组）。  </p>
<p><strong>su ， su - 与 sudo</strong><br>su <user> 可以切换到用户 user，执行时需要输入目标用户的密码，<br>sudo <cmd> 可以以特权级别运行 cmd 命令，需要当前用户属于 sudo 组，且需要输入当前用户的密码。<br>su - <user> 命令也是切换用户，同时环境变量也会跟着改变成目标用户的环境变量。  </user></cmd></user></p>
<p><strong>新建用户</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo adduser lilei</div></pre></td></tr></table></figure></p>
<p>这个命令不但可以添加用户到系统，同时也会默认为新用户创建 home 目录  </p>
<blockquote>
<p>adduser 和 useradd 的区别是什么？</p>
</blockquote>
<p>答：adduser 会创建用户，创建目录，创建密码（提示你设置），做这一系列的操作。useradd 只创建用户，创建完了用 passwd lilei 去设置新用户的密码。其实 useradd、userdel 这类操作更像是一种命令，执行完了就返回。而 adduser 更像是一种程序，需要你输入、确定等一系列操作。</p>
<p><strong>切换登录用户</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">su -l lilei</div></pre></td></tr></table></figure></p>
<p>退出当前用户跟退出终端一样可以使用 exit 命令或者使用快捷键 Ctrl+d。  </p>
<h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><p>在 Linux 里面每个用户都有一个归属（用户组），用户组简单地理解就是一组用户的集合，它们共享一些资源和权限，同时拥有私有资源，就跟家的形式差不多，你的兄弟姐妹（不同的用户）属于同一个家（用户组），你们可以共同拥有这个家（共享资源），爸妈对待你们都一样（共享权限），你偶尔写写日记，其他人未经允许不能查看（私有资源和权限）。当然一个用户是可以属于多个用户组的，正如你既属于家庭，又属于学校或公司。  </p>
<p>查看自己属于哪些用户组  </p>
<p><strong>方法一：使用 groups 命令</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">groups lilei</div><div class="line">lilei : lilei</div></pre></td></tr></table></figure></p>
<p>其中冒号之前表示用户，后面表示该用户所属的用户组。这里可以看到 lilei 用户属于 lilei 用户组，每次新建用户如果不指定用户组的话，默认会自动创建一个与用户名相同的用户组（差不多就相当于家长的意思，或者说是老总）。默认情况下在 sudo 用户组里的可以使用 sudo 命令获得 root 权限。lilei 用户也可以使用 sudo 命令，为什么这里没有显示在 sudo 用户组里呢？可以查看下 /etc/sudoers.d/lilei 文件，我们在 /etc/sudoers.d 目录下创建了这个文件，从而给 lilei 用户赋予了 sudo 权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo cat /etc/sudoers.d/lilei</div><div class="line">lilei ALL=(ALL) NOPASSWD: ALL</div><div class="line">Defaults:lilei !requiretty</div></pre></td></tr></table></figure></p>
<p><strong>方法二：查看 /etc/group 文件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /etc/group | sort</div></pre></td></tr></table></figure></p>
<p>这里 cat 命令用于读取指定文件的内容并打印到终端输出，后面会详细讲它的使用。 | sort 表示将读取的文本进行一个字典排序再输出，然后你将看到如下一堆输出，可以在看到 lilei 的用户组信息  </p>
<p>使用命令过滤掉一些你不想看到的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cat /etc/group | grep -E &quot;lilei&quot;</div><div class="line">lilei:x:5000:</div></pre></td></tr></table></figure></p>
<p>etc/group 文件格式说明  </p>
<p>/etc/group 的内容包括用户组（Group）、用户组口令、GID 及该用户组所包含的用户（User），每个用户组一条记录。格式如下：  </p>
<blockquote>
<p>group_name:password:GID:user_list  </p>
</blockquote>
<p>上面的 password 字段为一个 x 并不是说密码就是它，只是表示密码不可见而已。  </p>
<p><strong>将其它用户加入 sudo 用户组</strong>  </p>
<p>默认情况下新创建的用户是不具有 root 权限的，也不在 sudo 用户组  </p>
<p>使用 usermod 命令可以为用户添加用户组，同样使用该命令你必需有 root 权限，你可以直接使用 root 用户为其它用户添加用户组，或者用其它已经在 sudo 用户组的用户使用 sudo 命令获取权限来执行该命令。</p>
<p>这里我用 shiyanlou 用户执行 sudo 命令将 lilei 添加到 sudo 用户组，让它也可以使用 sudo 命令获得 root 权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">su shiyanlou</div><div class="line">groups lilei</div><div class="line">sudo usermod -G sudo lilei</div><div class="line">groups lilei</div></pre></td></tr></table></figure></p>
<h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo deluser lilei --remove-home</div></pre></td></tr></table></figure>
<h2 id="Linux文件权限"><a href="#Linux文件权限" class="headerlink" title="Linux文件权限"></a>Linux文件权限</h2><h3 id="查看文件权限"><a href="#查看文件权限" class="headerlink" title="查看文件权限"></a>查看文件权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -l</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/9rWx5HJ.png" alt=""><br><img src="http://i.imgur.com/xDJurAX.png" alt="">  </p>
<ul>
<li><p>文件类型<br>关于文件类型，这里有一点你必需时刻牢记 <strong>Linux 里面一切皆文件</strong>，正因为这一点才有了设备文件（ /dev 目录下有各种设备文件，大都跟具体的硬件设备相关）。 socket：网络套接字。pipe 管道。软链接文件：链接文件是分为两种的，另一种当然是“硬链接”（硬链接不常用，而软链接等同于 Windows 上的快捷方式,你记住这一点就够了）。</p>
</li>
<li><p>文件权限<br>读权限，表示你可以使用 cat <file name=""> 之类的命令来读取某个文件的内容；<br>写权限，表示你可以编辑和修改某个文件；<br>执行权限，通常指可以运行的二进制程序文件或者脚本文件，如同 Windows 上的 exe 后缀的文件，不过 Linux 上不是通过文件后缀名来区分文件的类型。<br>需要注意的一点是，一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息。</file></p>
</li>
<li><p>链接数<br>链接到该文件所在的 inode 结点的文件名数目。  </p>
</li>
<li><p>文件大小  </p>
<blockquote>
<p>以 inode 结点大小为单位来表示的文件大小，可以给 ls 加上 -lh 参数来更直观的查看文件的大小。  </p>
</blockquote>
</li>
</ul>
<p>显示除了 .（当前目录）和 ..（上一级目录）之外的所有文件，包括隐藏文件（Linux 下以 . 开头的文件为隐藏文件）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -A</div></pre></td></tr></table></figure></p>
<p>查看某一个目录的完整属性，而不是显示目录里面的文件属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -dl &lt;目录名&gt;</div></pre></td></tr></table></figure></p>
<p>显示所有文件大小，并以普通人类能看懂的方式呈现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -AsSh</div></pre></td></tr></table></figure></p>
<p>其中小 s 为显示文件大小，大 S 为按文件大小排序，若需要知道如何按其它方式排序，请使用“man”命令查询。</p>
<h3 id="变更文件所有者"><a href="#变更文件所有者" class="headerlink" title="变更文件所有者"></a>变更文件所有者</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chown shiyanlou test.txt</div></pre></td></tr></table></figure>
<h3 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><p><strong>方式一：二进制数字表示</strong>  </p>
<p><img src="http://i.imgur.com/6tKnGVZ.png" alt="">  </p>
<p>每个文件的三组权限（拥有者，所属用户组，其他用户，记住这个顺序是一定的）对应一个 “ rwx “，也就是一个 “ 7 ”  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod 700 test.txt</div></pre></td></tr></table></figure>
<p><strong>方式二：加减赋值操作</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod go-rw test.txt</div></pre></td></tr></table></figure></p>
<p>g、o 还有 u 分别表示 group、others 和 user，+ 和 - 分别表示增加和去掉相应的权限。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;用户及文件权限管理&quot;&gt;&lt;a href=&quot;#用户及文件权限管理&quot; class=&quot;headerlink&quot; title=&quot;用户及文件权限管理&quot;&gt;&lt;/a&gt;用户及文件权限管理&lt;/h1&gt;&lt;h2 id=&quot;Linux用户管理&quot;&gt;&lt;a href=&quot;#Linux用户管理&quot; class
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Linux/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux基础" scheme="http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
