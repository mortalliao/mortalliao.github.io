<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mortalLiao</title>
  <subtitle>Keep learning</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-11-27T06:15:50.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>mortalLiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>01_Docker_Hello_World</title>
    <link href="http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/01_Docker_Hello_World/"/>
    <id>http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/01_Docker_Hello_World/</id>
    <published>2017-11-27T06:15:50.000Z</published>
    <updated>2017-11-27T06:15:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-Hello-World"><a href="#Docker-Hello-World" class="headerlink" title="Docker Hello World"></a>Docker Hello World</h1><p>Docker 允许你在容器内运行应用程序， 使用 docker run 命令来在容器内运行一个应用程序。<br>输出Hello world</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker run ubuntu:15.10 /bin/echo &quot;Hello world&quot;</div><div class="line">Hello world</div></pre></td></tr></table></figure>
<p>各个参数解析：</p>
<ul>
<li>docker: Docker 的二进制执行文件。</li>
<li>run:与前面的 docker 组合来运行一个容器。</li>
<li>ubuntu:15.10指定要运行的镜像，Docker首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。</li>
<li>/bin/echo “Hello world”: 在启动的容器里执行的命令</li>
</ul>
<h1 id="运行交互式的容器"><a href="#运行交互式的容器" class="headerlink" title="运行交互式的容器"></a>运行交互式的容器</h1><p>通过docker的两个参数 -i -t，让docker运行的容器实现”对话”的能力</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker run -i -t ubuntu:15.10 /bin/bash</div><div class="line">root@dc0050c79503:/#</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run –i -t –-name nginx_test[这个名字可以随便起] 904d6c400333[IMAGE ID] /bin/bash</div></pre></td></tr></table></figure>
<p>各个参数解析：</p>
<ul>
<li>t:在新容器内指定一个伪终端或终端。</li>
<li>i:允许你对容器内的标准输入 (STDIN) 进行交互。</li>
</ul>
<p>此时已进入一个 ubuntu15.10系统的容器<br>尝试在容器中运行命令 cat /proc/version和ls分别查看当前系统的版本信息和当前目录下的文件列表<br><img src="https://i.imgur.com/oiv1hkR.png" alt=""><br>可以通过运行exit命令或者使用CTRL+D来退出容器。</p>
<h1 id="启动容器（后台模式）"><a href="#启动容器（后台模式）" class="headerlink" title="启动容器（后台模式）"></a>启动容器（后台模式）</h1><p>使用以下命令创建一个以进程方式运行的容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker run -d ubuntu:15.10 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</div><div class="line">2b1b7a428627c51ab8810d541d759f072b4fc75487eed05812646b8534a2fe63</div></pre></td></tr></table></figure></p>
<p>在输出中，我们没有看到期望的”hello world”，而是一串长字符<br>2b1b7a428627c51ab8810d541d759f072b4fc75487eed05812646b8534a2fe63<br>这个长字符串叫做容器ID，对每个容器来说都是唯一的，我们可以通过容器ID来查看对应的容器发生了什么。<br>首先，我们需要确认容器有在运行，可以通过 <strong>docker ps</strong> 来查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker ps</div></pre></td></tr></table></figure></p>
<p>CONTAINER ID:容器ID<br>NAMES:自动分配的容器名称</p>
<p>在容器内使用 <strong>docker logs</strong> 命令，查看容器内的标准输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker logs 2b1b7a428627</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker logs amazing_cori</div></pre></td></tr></table></figure></p>
<h1 id="git-bash连接"><a href="#git-bash连接" class="headerlink" title="git-bash连接"></a>git-bash连接</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine ssh default</div></pre></td></tr></table></figure>
<h1 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h1><p>使用 <strong>docker stop</strong> 命令来停止容器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker stop 2b1b7a428627</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker logs amazing_cori</div></pre></td></tr></table></figure></p>
<p>通过docker ps查看，容器已经停止工作:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker ps</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-Hello-World&quot;&gt;&lt;a href=&quot;#Docker-Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Docker Hello World&quot;&gt;&lt;/a&gt;Docker Hello World&lt;/h1&gt;&lt;p&gt;Docker
    
    </summary>
    
      <category term="Cloud&amp;BigData" scheme="http://yoursite.com/categories/Cloud-BigData/"/>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Cloud-BigData/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>05_Docker_命令大全</title>
    <link href="http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/05_Docker_%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/05_Docker_命令大全/</id>
    <published>2017-11-27T06:15:50.000Z</published>
    <updated>2017-11-27T06:15:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="info-version"><a href="#info-version" class="headerlink" title="info | version"></a>info | version</h2><h3 id="info"><a href="#info" class="headerlink" title="info"></a>info</h3><p>docker info : 显示 Docker 系统信息，包括镜像和容器数。。  </p>
<h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>docker version :显示 Docker 版本信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker version [OPTIONS]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-f :指定返回值的模板文件。</li>
</ul>
<h2 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h2><h3 id="login-logout"><a href="#login-logout" class="headerlink" title="login/logout"></a>login/logout</h3><p>docker login : 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub<br>docker logout : 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker login [OPTIONS] [SERVER]</div><div class="line">docker logout [OPTIONS] [SERVER]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-u :登陆的用户名</li>
<li>-p :登陆的密码</li>
</ul>
<p>登陆到Docker Hub<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker login -u 用户名 -p 密码</div></pre></td></tr></table></figure></p>
<p>登出Docker Hub<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker logout</div></pre></td></tr></table></figure></p>
<h3 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h3><p>docker pull : 从镜像仓库中拉取或者更新指定镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull [OPTIONS] NAME[:TAG|@DIGEST]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-a :拉取所有 tagged 镜像</li>
<li>–disable-content-trust :忽略镜像的校验,默认开启</li>
</ul>
<p>从Docker Hub下载java最新版镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull java</div></pre></td></tr></table></figure></p>
<p>从Docker Hub下载REPOSITORY为java的所有镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull -a java</div></pre></td></tr></table></figure></p>
<h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p>docker push : 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker push [OPTIONS] NAME[:TAG]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>–disable-content-trust :忽略镜像的校验,默认开启</li>
</ul>
<p>上传本地镜像myapache:v1到镜像仓库中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker push myapache:v1</div></pre></td></tr></table></figure></p>
<h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>docker search : 从Docker Hub查找镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker search [OPTIONS] TERM</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>–automated :只列出 automated build类型的镜像；</li>
<li>–no-trunc :显示完整的镜像描述；</li>
<li>-s :列出收藏数不小于指定值的镜像。</li>
</ul>
<p>从Docker Hub查找所有镜像名包含java，并且收藏数大于10的镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker search -s 10 java</div></pre></td></tr></table></figure></p>
<h2 id="本地镜像管理"><a href="#本地镜像管理" class="headerlink" title="本地镜像管理"></a>本地镜像管理</h2><h3 id="images"><a href="#images" class="headerlink" title="images"></a>images</h3><p>docker images : 列出本地镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker images [OPTIONS] [REPOSITORY[:TAG]]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</li>
<li>–digests :显示镜像的摘要信息；</li>
<li>-f :显示满足条件的镜像；</li>
<li>–format :指定返回值的模板文件；</li>
<li>–no-trunc :显示完整的镜像信息；</li>
<li>-q :只显示镜像ID。</li>
</ul>
<p>列出本地镜像中REPOSITORY为ubuntu的镜像列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker images  ubuntu</div></pre></td></tr></table></figure></p>
<h3 id="rmi"><a href="#rmi" class="headerlink" title="rmi"></a>rmi</h3><p>docker rmi : 删除本地一个或多少镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-f :强制删除；</li>
<li>–no-prune :不移除该镜像的过程镜像，默认移除；</li>
</ul>
<p>强制删除本地镜像runoob/ubuntu:v4。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rmi -f runoob/ubuntu:v4</div></pre></td></tr></table></figure></p>
<h3 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h3><p>docker tag : 标记本地镜像，将其归入某一仓库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]</div></pre></td></tr></table></figure></p>
<p>将镜像ubuntu:15.10标记为 runoob/ubuntu:v3 镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker tag ubuntu:15.10 runoob/ubuntu:v3</div></pre></td></tr></table></figure></p>
<h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>docker build : 使用Dockerfile创建镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build [OPTIONS] PATH | URL | -</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：  </p>
<ul>
<li>–build-arg=[] :设置镜像创建时的变量；</li>
<li>–cpu-shares :设置 cpu 使用权重；</li>
<li>–cpu-period :限制 CPU CFS周期；</li>
<li>–cpu-quota :限制 CPU CFS配额；</li>
<li>–cpuset-cpus :指定使用的CPU id；</li>
<li>–cpuset-mems :指定使用的内存 id；</li>
<li>–disable-content-trust :忽略校验，默认开启；</li>
<li>-f :指定要使用的Dockerfile路径；</li>
<li>–force-rm :设置镜像过程中删除中间容器；</li>
<li>–isolation :使用容器隔离技术；</li>
<li>–label=[] :设置镜像使用的元数据；</li>
<li>-m :设置内存最大值；</li>
<li>–memory-swap :设置Swap的最大值为内存+swap，”-1”表示不限swap；</li>
<li>–no-cache :创建镜像的过程不使用缓存；</li>
<li>–pull :尝试去更新镜像的新版本；</li>
<li>-q :安静模式，成功后只输出镜像ID；</li>
<li>–rm :设置镜像成功后删除中间容器；</li>
<li>–shm-size :设置/dev/shm的大小，默认值是64M；</li>
<li>–ulimit :Ulimit配置。</li>
</ul>
<p>使用当前目录的Dockerfile创建镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build -t runoob/ubuntu:v1 .</div></pre></td></tr></table></figure></p>
<p>使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build github.com/creack/docker-firefox</div></pre></td></tr></table></figure></p>
<h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>docker history : 查看指定镜像的创建历史。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker history [OPTIONS] IMAGE</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：  </p>
<ul>
<li>-H :以可读的格式打印镜像大小和日期，默认为true；</li>
<li>–no-trunc :显示完整的提交记录；</li>
<li>-q :仅列出提交记录ID。</li>
</ul>
<p>查看本地镜像runoob/ubuntu:v3的创建历史。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker history runoob/ubuntu:v3</div></pre></td></tr></table></figure></p>
<h3 id="save"><a href="#save" class="headerlink" title="save"></a>save</h3><p>docker save : 将指定镜像保存成 tar 归档文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker save [OPTIONS] IMAGE [IMAGE...]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-o :输出到的文件。</li>
</ul>
<p>将镜像runoob/ubuntu:v3 生成my_ubuntu_v3.tar文档<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3</div></pre></td></tr></table></figure></p>
<p>docker 容器导入导出有两种方法：  </p>
<p>一种是使用 save 和 load 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker save ubuntu:load&gt;/root/ubuntu.tar</div><div class="line">docker load&lt;ubuntu.tar</div></pre></td></tr></table></figure></p>
<p>一种是使用 export 和 import 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker export 98ca36&gt; ubuntu.tar</div><div class="line">cat ubuntu.tar | sudo docker import - ubuntu:import</div></pre></td></tr></table></figure></p>
<p>注意两种方法不可混用。</p>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>docker import : 从归档文件中创建镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：  </p>
<ul>
<li>-c :应用docker 指令创建镜像；</li>
<li>-m :提交时的说明文字；</li>
</ul>
<p>从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为runoob/ubuntu:v4<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker import  my_ubuntu_v3.tar runoob/ubuntu:v4</div></pre></td></tr></table></figure></p>
<h2 id="容器生命周期管理"><a href="#容器生命周期管理" class="headerlink" title="容器生命周期管理"></a>容器生命周期管理</h2><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>docker run ：创建一个新的容器并运行一个命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</li>
<li>-d: 后台运行容器，并返回容器ID；</li>
<li>-i: 以交互模式运行容器，通常与 -t 同时使用；</li>
<li>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li>
<li>–name=”nginx-lb”: 为容器指定一个名称；</li>
<li>–dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；</li>
<li>–dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；</li>
<li>-h “mars”: 指定容器的hostname；</li>
<li>-e username=”ritchie”: 设置环境变量；</li>
<li>–env-file=[]: 从指定文件读入环境变量；</li>
<li>–cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行；</li>
<li>-m :设置容器使用内存最大值；</li>
<li>–net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</li>
<li>–link=[]: 添加链接到另一个容器；</li>
<li>–expose=[]: 开放一个端口或一组端口；</li>
</ul>
<p>使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --name mynginx -d nginx:latest</div></pre></td></tr></table></figure></p>
<p>使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -P -d nginx:latest</div></pre></td></tr></table></figure></p>
<p>使用镜像nginx:latest以后台模式启动一个容器,将容器的80端口映射到主机的80端口,主机的目录/data映射到容器的/data。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -p 80:80 -v /data:/data -d nginx:latest</div></pre></td></tr></table></figure></p>
<p>使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -it nginx:latest /bin/bash</div></pre></td></tr></table></figure></p>
<h3 id="start-stop-restart"><a href="#start-stop-restart" class="headerlink" title="start/stop/restart"></a>start/stop/restart</h3><p>docker start :启动一个或多少已经被停止的容器<br>docker stop :停止一个运行中的容器<br>docker restart :重启容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker start [OPTIONS] CONTAINER [CONTAINER...]</div><div class="line">docker stop [OPTIONS] CONTAINER [CONTAINER...]</div><div class="line">docker restart [OPTIONS] CONTAINER [CONTAINER...]</div></pre></td></tr></table></figure></p>
<p>启动已被停止的容器myrunoob<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker start myrunoob</div></pre></td></tr></table></figure></p>
<p>停止运行中的容器myrunoob<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker stop myrunoob</div></pre></td></tr></table></figure></p>
<p>重启容器myrunoob<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker restart myrunoob</div></pre></td></tr></table></figure></p>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>docker kill :杀掉一个运行中的容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker kill [OPTIONS] CONTAINER [CONTAINER...]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-s :向容器发送一个信号</li>
</ul>
<p>杀掉运行中的容器mynginx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker kill -s KILL mynginx</div></pre></td></tr></table></figure></p>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>docker rm ：删除一个或多少容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm [OPTIONS] CONTAINER [CONTAINER...]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-f :通过SIGKILL信号强制删除一个运行中的容器</li>
<li>-l :移除容器间的网络连接，而非容器本身</li>
<li>-v :-v 删除与容器关联的卷</li>
</ul>
<p>强制删除容器db01、db02<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm -f db01、db02</div></pre></td></tr></table></figure></p>
<p>移除容器nginx01对容器db01的连接，连接名db<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm -l db</div></pre></td></tr></table></figure></p>
<p>删除容器nginx01,并删除容器挂载的数据卷<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm -v nginx01</div></pre></td></tr></table></figure></p>
<h3 id="pause-unpause"><a href="#pause-unpause" class="headerlink" title="pause/unpause"></a>pause/unpause</h3><p>docker pause :暂停容器中所有的进程。<br>docker unpause :恢复容器中所有的进程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker pause [OPTIONS] CONTAINER [CONTAINER...]</div><div class="line">docker unpause [OPTIONS] CONTAINER [CONTAINER...]</div></pre></td></tr></table></figure></p>
<p>暂停数据库容器db01提供服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pause db01</div></pre></td></tr></table></figure></p>
<p>恢复数据库容器db01提供服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker unpause db01</div></pre></td></tr></table></figure></p>
<h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><p>docker create ：创建一个新的容器但不启动它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</div></pre></td></tr></table></figure></p>
<p>用法同 docker run</p>
<p>使用docker镜像nginx:latest创建一个容器,并将容器命名为myrunoob<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker create  --name myrunoob  nginx:latest</div></pre></td></tr></table></figure></p>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>docker exec ：在运行的容器中执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-d :分离模式: 在后台运行</li>
<li>-i :即使没有附加也保持STDIN 打开</li>
<li>-t :分配一个伪终端</li>
</ul>
<p>在容器mynginx中以交互模式执行容器内/root/runoob.sh脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker exec -it mynginx /bin/sh /root/runoob.sh</div></pre></td></tr></table></figure></p>
<p>在容器mynginx中开启一个交互模式的终端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker exec -i -t  mynginx /bin/bash</div></pre></td></tr></table></figure></p>
<h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>docker ps : 列出容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker ps [OPTIONS]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-a :显示所有的容器，包括未运行的。</li>
<li>-f :根据条件过滤显示的内容。</li>
<li>–format :指定返回值的模板文件。</li>
<li>-l :显示最近创建的容器。</li>
<li>-n :列出最近创建的n个容器。</li>
<li>–no-trunc :不截断输出。</li>
<li>-q :静默模式，只显示容器编号。</li>
<li>-s :显示总的文件大小。</li>
</ul>
<p>列出所有在运行的容器信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker ps</div></pre></td></tr></table></figure></p>
<p>列出最近创建的5个容器信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker ps -n 5</div></pre></td></tr></table></figure></p>
<p>列出所有创建的容器ID。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker ps -a -q</div></pre></td></tr></table></figure></p>
<h3 id="inspect"><a href="#inspect" class="headerlink" title="inspect"></a>inspect</h3><p>docker inspect : 获取容器/镜像的元数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker inspect [OPTIONS] NAME|ID [NAME|ID...]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：  </p>
<ul>
<li>-f :指定返回值的模板文件。</li>
<li>-s :显示总的文件大小。</li>
<li>–type :为指定类型返回JSON。</li>
</ul>
<p>获取镜像mysql:5.6的元信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker inspect mysql:5.6</div></pre></td></tr></table></figure></p>
<p>获取正在运行的容器mymysql的 IP。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker inspect --format=&apos;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&apos; mymysql  </div><div class="line">172.17.0.3</div></pre></td></tr></table></figure></p>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>docker top :查看容器中运行的进程信息，支持 ps 命令参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker top [OPTIONS] CONTAINER [ps OPTIONS]</div></pre></td></tr></table></figure></p>
<p>容器运行时不一定有/bin/bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程。  </p>
<p>查看容器mymysql的进程信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker top mymysql</div></pre></td></tr></table></figure></p>
<p>查看所有运行容器的进程信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for i in  `docker ps |grep Up|awk &apos;&#123;print $1&#125;&apos;`;do echo \ &amp;&amp;docker top $i; done</div></pre></td></tr></table></figure></p>
<h3 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h3><p>docker attach :连接到正在运行中的容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker attach [OPTIONS] CONTAINER</div></pre></td></tr></table></figure></p>
<p>要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。<br>官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上–sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。  </p>
<p>容器mynginx将访问日志指到标准输出，连接到容器查看访问信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker attach --sig-proxy=false mynginx</div></pre></td></tr></table></figure></p>
<h3 id="events"><a href="#events" class="headerlink" title="events"></a>events</h3><p>docker events : 从服务器获取实时事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker events [OPTIONS]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-f ：根据条件过滤事件；</li>
<li>–since ：从指定的时间戳后显示所有事件;</li>
<li>–until ：流水时间显示到指定的时间为止；</li>
</ul>
<p>显示docker 2016年7月1日后的所有事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker events  --since=&quot;1467302400&quot;</div></pre></td></tr></table></figure></p>
<p>显示docker 镜像为mysql:5.6 2016年7月1日后的相关事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker events -f &quot;image&quot;=&quot;mysql:5.6&quot; --since=&quot;1467302400&quot;</div></pre></td></tr></table></figure></p>
<p>如果指定的时间是到秒级的，需要将时间转成时间戳。如果时间为日期的话，可以直接使用，如–since=”2016-07-01”。  </p>
<h3 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h3><p>docker logs : 获取容器的日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker logs [OPTIONS] CONTAINER</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-f : 跟踪日志输出</li>
<li>–since :显示某个开始时间的所有日志</li>
<li>-t : 显示时间戳</li>
<li>–tail :仅列出最新N条容器日志</li>
</ul>
<p>跟踪查看容器mynginx的日志输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker logs -f mynginx</div></pre></td></tr></table></figure></p>
<p>查看容器mynginx从2016年7月1日后的最新10条日志。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker logs --since=&quot;2016-07-01&quot; --tail=10 mynginx</div></pre></td></tr></table></figure></p>
<h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><p>docker wait : 阻塞运行直到容器停止，然后打印出它的退出代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker wait [OPTIONS] CONTAINER [CONTAINER...]</div></pre></td></tr></table></figure></p>
<h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><p>docker export :将文件系统作为一个tar归档文件导出到STDOUT。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker export [OPTIONS] CONTAINER</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-o :将输入内容写到文件。</li>
</ul>
<p>将id为a404c6c174a2的容器按日期保存为tar文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker export -o mysql-`date +%Y%m%d`.tar a404c6c174a2</div></pre></td></tr></table></figure></p>
<h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><p>docker port :列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]]</div></pre></td></tr></table></figure></p>
<p>查看容器mynginx的端口映射情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker port mymysql</div></pre></td></tr></table></figure></p>
<h2 id="容器rootfs命令"><a href="#容器rootfs命令" class="headerlink" title="容器rootfs命令"></a>容器rootfs命令</h2><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><p>docker commit :从容器创建一个新的镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-a :提交的镜像作者；</li>
<li>-c :使用Dockerfile指令来创建镜像；</li>
<li>-m :提交时的说明文字；</li>
<li>-p :在commit时，将容器暂停。</li>
</ul>
<p>将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker commit -a &quot;runoob.com&quot; -m &quot;my apache&quot; a404c6c174a2  mymysql:v1</div></pre></td></tr></table></figure></p>
<h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>docker cp :用于容器与主机之间的数据拷贝。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</div><div class="line">docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-L :保持源目标中的链接</li>
</ul>
<p>将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker cp /www/runoob 96f7f14e99ab:/www/</div></pre></td></tr></table></figure></p>
<p>将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker cp /www/runoob 96f7f14e99ab:/www</div></pre></td></tr></table></figure></p>
<p>将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker cp  96f7f14e99ab:/www /tmp/</div></pre></td></tr></table></figure></p>
<h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>docker diff : 检查容器里文件结构的更改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker diff [OPTIONS] CONTAINER</div></pre></td></tr></table></figure></p>
<p>查看容器mymysql的文件结构更改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker diff mymysql</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;info-version&quot;&gt;&lt;a href=&quot;#info-version&quot; class=&quot;headerlink&quot; title=&quot;info | version&quot;&gt;&lt;/a&gt;info | version&lt;/h2&gt;&lt;h3 id=&quot;info&quot;&gt;&lt;a href=&quot;#info&quot;
    
    </summary>
    
      <category term="Cloud&amp;BigData" scheme="http://yoursite.com/categories/Cloud-BigData/"/>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Cloud-BigData/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>04_Docker_容器连接</title>
    <link href="http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/04_Docker_%E5%AE%B9%E5%99%A8%E8%BF%9E%E6%8E%A5/"/>
    <id>http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/04_Docker_容器连接/</id>
    <published>2017-11-27T06:15:50.000Z</published>
    <updated>2017-11-27T06:15:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络端口映射"><a href="#网络端口映射" class="headerlink" title="网络端口映射"></a>网络端口映射</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run -d -P training/webapp python app.py</div><div class="line">fce072cc88cee71b1cdceb57c2821d054a4a59f67da6b416fceb5593f059fc6d</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 5000:5000 training/webapp python app.py</div><div class="line">33e4523d30aaf0258915c368e66e03b49535de0ef20317d3f639d40222ba6bc0</div></pre></td></tr></table></figure>
<ul>
<li>-P :是容器内部端口随机映射到主机的高端口。</li>
<li>-p : 是容器内部端口绑定到指定的主机端口。</li>
</ul>
<p>使用 docker ps 来看到端口5000绑定主机端口32768。</p>
<p>可以指定容器绑定的网络地址，比如绑定127.0.0.1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 127.0.0.1:5001:5002 training/webapp python app.py</div><div class="line">95c6ceef88ca3e71eaf303c2833fd6701d8d1b2572b5613b5a932dfdfe8a857c</div></pre></td></tr></table></figure></p>
<p>默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 /udp。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</div><div class="line">6779686f06f6204579c1d655dd8b2b31e8e809b245a97b2d3a8e35abe9dcd22a</div></pre></td></tr></table></figure></p>
<p><strong>docker port</strong> 命令可以让我们快捷地查看端口的绑定情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker port adoring_stonebraker 5002</div></pre></td></tr></table></figure></p>
<h2 id="Docker容器连接"><a href="#Docker容器连接" class="headerlink" title="Docker容器连接"></a>Docker容器连接</h2><p>端口映射并不是唯一把 docker 连接到另一个容器的方法。<br>docker有一个连接系统允许将多个容器连接在一起，共享连接信息。<br>docker连接会创建一个父子关系，其中父容器可以看到子容器的信息。  </p>
<h3 id="容器命名"><a href="#容器命名" class="headerlink" title="容器命名"></a>容器命名</h3><p>当我们创建一个容器的时候，docker会自动对它进行命名。另外，我们也可以使用–name标识来命名容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run -d -P --name runoob training/webapp python app.py</div><div class="line">43780a6eabaaf14e590b6e849235c75f3012995403f97749775e38436db9a441</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;网络端口映射&quot;&gt;&lt;a href=&quot;#网络端口映射&quot; class=&quot;headerlink&quot; title=&quot;网络端口映射&quot;&gt;&lt;/a&gt;网络端口映射&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
    
    </summary>
    
      <category term="Cloud&amp;BigData" scheme="http://yoursite.com/categories/Cloud-BigData/"/>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Cloud-BigData/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>02_Docker_容器使用</title>
    <link href="http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/02_Docker_%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/02_Docker_容器使用/</id>
    <published>2017-11-27T06:15:50.000Z</published>
    <updated>2017-11-27T06:15:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-容器使用"><a href="#Docker-容器使用" class="headerlink" title="Docker 容器使用"></a>Docker 容器使用</h1><h2 id="Docker-客户端"><a href="#Docker-客户端" class="headerlink" title="Docker 客户端"></a>Docker 客户端</h2><p>可以直接输入 docker 命令来查看到 Docker 客户端的所有命令选项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~# docker</div></pre></td></tr></table></figure></p>
<p><img src="https://i.imgur.com/sjan9rZ.png" alt="">  </p>
<p>可以通过命令 <strong>docker command –help</strong> 更深入的了解指定的 Docker 命令使用方法。<br>例如要查看 docker stats 指令的具体使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~# docker stats --help</div></pre></td></tr></table></figure></p>
<p><img src="https://i.imgur.com/BA4GSFY.png" alt="">  </p>
<h2 id="运行一个web应用"><a href="#运行一个web应用" class="headerlink" title="运行一个web应用"></a>运行一个web应用</h2><p>使用 docker 构建一个 web 应用程序。<br>在docker容器中运行一个 Python Flask 应用来运行一个web应用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~# docker run -d -P training/webapp python app.py</div></pre></td></tr></table></figure></p>
<p>参数说明:</p>
<ul>
<li>d:让容器在后台运行。</li>
<li>P:将容器内部使用的网络端口映射到我们使用的主机上。</li>
</ul>
<h2 id="查看-WEB-应用容器"><a href="#查看-WEB-应用容器" class="headerlink" title="查看 WEB 应用容器"></a>查看 WEB 应用容器</h2><p>使用 <strong>docker ps</strong> 来查看我们正在运行的容器<br>使用 <strong>docker inspect</strong> 命令可以查看更详细的关于某一个容器的信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker ps</div></pre></td></tr></table></figure></p>
<p>多了端口信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PORTS</div><div class="line">0.0.0.0:32769-&gt;5000/tcp</div></pre></td></tr></table></figure></p>
<p>Docker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 32769 上。</p>
<p>也可以指定 -p 标识来绑定指定端口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker run -d -p 5000:5000 training/webapp python app.py</div></pre></td></tr></table></figure></p>
<p>docker ps查看正在运行的容器<br>容器内部的 5000 端口映射到我们本地主机的 5000 端口上。  </p>
<h2 id="网络端口的快捷方式"><a href="#网络端口的快捷方式" class="headerlink" title="网络端口的快捷方式"></a>网络端口的快捷方式</h2><p>通过 <strong>docker ps</strong> 命令可以查看到容器的端口映射<br>docker还提供了另一个快捷方式： <strong>docker port</strong> ,使用 docker port 可以查看指定 （ID或者名字）容器的某个确定端口映射到宿主机的端口号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker port 7a38a1ad55c6</div><div class="line">5000/tcp -&gt; 0.0.0.0:5000</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker port determined_swanson</div><div class="line">5000/tcp -&gt; 0.0.0.0:5000</div></pre></td></tr></table></figure></p>
<h2 id="查看WEB应用程序日志"><a href="#查看WEB应用程序日志" class="headerlink" title="查看WEB应用程序日志"></a>查看WEB应用程序日志</h2><p><strong>docker logs [ID或者名字]</strong> 可以查看容器内部的标准输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker logs -f 7a38a1ad55c6</div><div class="line"> * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</div><div class="line">192.168.239.1 - - [09/May/2016 16:30:37] &quot;GET / HTTP/1.1&quot; 200 -</div><div class="line">192.168.239.1 - - [09/May/2016 16:30:37] &quot;GET /favicon.ico HTTP/1.1&quot; 404 -</div></pre></td></tr></table></figure>
<p>-f:让 dokcer logs 像使用 tail -f 一样来输出容器内部的标准输出。<br>从上面，可以看到应用程序使用的是 5000 端口并且能够查看到应用程序的访问日志。  </p>
<h2 id="查看WEB应用程序容器的进程"><a href="#查看WEB应用程序容器的进程" class="headerlink" title="查看WEB应用程序容器的进程"></a>查看WEB应用程序容器的进程</h2><p>使用 <strong>docker top</strong> 来查看容器内部运行的进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker top determined_swanson</div></pre></td></tr></table></figure></p>
<h2 id="检查WEB应用程序"><a href="#检查WEB应用程序" class="headerlink" title="检查WEB应用程序"></a>检查WEB应用程序</h2><p>使用 <strong>docker inspect</strong> 来查看Docker的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker inspect determined_swanson</div><div class="line">[</div><div class="line">    &#123;</div><div class="line">        &quot;Id&quot;: &quot;7a38a1ad55c6914b360b565819604733db751d86afd2575236a70a2519527361&quot;,</div><div class="line">        &quot;Created&quot;: &quot;2016-05-09T16:20:45.427996598Z&quot;,</div><div class="line">        &quot;Path&quot;: &quot;python&quot;,</div><div class="line">        &quot;Args&quot;: [</div><div class="line">            &quot;app.py&quot;</div><div class="line">        ],</div><div class="line">        &quot;State&quot;: &#123;</div><div class="line">            &quot;Status&quot;: &quot;running&quot;,</div><div class="line">......</div></pre></td></tr></table></figure></p>
<h2 id="停止WEB应用容器"><a href="#停止WEB应用容器" class="headerlink" title="停止WEB应用容器"></a>停止WEB应用容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker stop determined_swanson   </div><div class="line">determined_swanson</div></pre></td></tr></table></figure>
<h2 id="重启WEB应用容器"><a href="#重启WEB应用容器" class="headerlink" title="重启WEB应用容器"></a>重启WEB应用容器</h2><p>已经停止的容器，可以使用命令 docker start 来启动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker start determined_swanson</div><div class="line">determined_swanson</div></pre></td></tr></table></figure></p>
<p>docker ps -l 查询最后一次创建的容器  </p>
<p>正在运行的容器，我们可以使用 docker restart 命令来重启  </p>
<h2 id="移除WEB应用容器"><a href="#移除WEB应用容器" class="headerlink" title="移除WEB应用容器"></a>移除WEB应用容器</h2><p>可以使用 <strong>docker rm</strong> 命令来删除不需要的容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker rm determined_swanson  </div><div class="line">determined_swanson</div></pre></td></tr></table></figure></p>
<p>删除容器时，容器必须是停止状态，否则会报如下错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker rm determined_swanson</div><div class="line">Error response from daemon: You cannot remove a running container 7a38a1ad55c6914b360b565819604733db751d86afd2575236a70a2519527361. Stop the container before attempting removal or use -f</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-容器使用&quot;&gt;&lt;a href=&quot;#Docker-容器使用&quot; class=&quot;headerlink&quot; title=&quot;Docker 容器使用&quot;&gt;&lt;/a&gt;Docker 容器使用&lt;/h1&gt;&lt;h2 id=&quot;Docker-客户端&quot;&gt;&lt;a href=&quot;#Docker-
    
    </summary>
    
      <category term="Cloud&amp;BigData" scheme="http://yoursite.com/categories/Cloud-BigData/"/>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Cloud-BigData/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>03_Docker_镜像使用</title>
    <link href="http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/03_Docker_%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/03_Docker_镜像使用/</id>
    <published>2017-11-27T06:15:50.000Z</published>
    <updated>2017-11-27T06:15:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-镜像使用"><a href="#Docker-镜像使用" class="headerlink" title="Docker 镜像使用"></a>Docker 镜像使用</h1><p>当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。  </p>
<h2 id="列出镜像列表"><a href="#列出镜像列表" class="headerlink" title="列出镜像列表"></a>列出镜像列表</h2><p>使用 <strong>docker images</strong> 来列出本地主机上的镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker images           </div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div></pre></td></tr></table></figure></p>
<p>各个选项说明:  </p>
<ul>
<li>REPOSTITORY：表示镜像的仓库源</li>
<li>TAG：镜像的标签</li>
<li>IMAGE ID：镜像ID</li>
<li>CREATED：镜像创建时间</li>
<li>SIZE：镜像大小</li>
</ul>
<p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如ubuntu仓库源里，有15.10、14.04等多个不同的版本，我们使用 REPOSTITORY:TAG 来定义不同的镜像。  </p>
<p>如果不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。</p>
<h2 id="获取一个新的镜像"><a href="#获取一个新的镜像" class="headerlink" title="获取一个新的镜像"></a>获取一个新的镜像</h2><p>当在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果想预先下载这个镜像，可以使用 <strong>docker pull</strong> 命令来下载它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Crunoob@runoob:~$ docker pull ubuntu:13.10</div></pre></td></tr></table></figure></p>
<p>下载完成后，可以直接使用这个镜像来运行容器。</p>
<h2 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h2><p>可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： <a href="https://hub.docker.com/" target="_blank" rel="external">https://hub.docker.com/</a><br>也可以使用 <strong>docker search</strong> 命令来搜索镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$  docker search nginx</div></pre></td></tr></table></figure></p>
<ul>
<li>NAME:镜像仓库源的名称</li>
<li>DESCRIPTION:镜像的描述</li>
<li>OFFICIAL:是否docker官方发布</li>
</ul>
<h2 id="拖取镜像"><a href="#拖取镜像" class="headerlink" title="拖取镜像"></a>拖取镜像</h2><p>使用命令 docker pull 来下载镜像。</p>
<h1 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h1><p>当从docker镜像仓库中下载的镜像不能满足需求时，可以通过以下两种方式对镜像进行更改。  </p>
<ol>
<li>从已经创建的容器中更新镜像，并且提交这个镜像  </li>
<li>使用 Dockerfile 指令来创建一个新的镜像  </li>
</ol>
<h2 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h2><p>更新镜像之前，我们需要使用镜像来创建一个容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker run -i -t ubuntu:15.10 /bin/bash</div><div class="line">root@e218edb10161:/#</div></pre></td></tr></table></figure></p>
<p>在运行的容器内使用 apt-get update 命令进行更新。<br>在完成操作之后，输入 exit命令来退出这个容器。  </p>
<p>此时ID为e218edb10161的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit来提交容器副本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2</div><div class="line">sha256:70bf1840fd7c0d2d8ef0a42a817eb29f854c1af8f7c59fc03ac7bdee9545aff8</div></pre></td></tr></table></figure></p>
<p>各个参数说明：  </p>
<ul>
<li>m:提交的描述信息</li>
<li>a:指定镜像作者</li>
<li>e218edb10161：容器ID</li>
<li>runoob/ubuntu:v2:指定要创建的目标镜像名</li>
</ul>
<p>使用 docker images 命令来查看我们的新镜像 runoob/ubuntu:v2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker images</div></pre></td></tr></table></figure></p>
<p>使用新镜像 runoob/ubuntu 来启动一个容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -i -t runoob/ubuntu:v2 /bin/bash</div></pre></td></tr></table></figure></p>
<h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>使用命令 <strong>docker build</strong> ， 从零开始来创建一个新的镜像。为此，需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建新的镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ cat Dockerfile </div><div class="line">FROM    centos:6.7</div><div class="line">MAINTAINER      Fisher &quot;fisher@sudops.com&quot;</div><div class="line"></div><div class="line">RUN     /bin/echo &apos;root:123456&apos; |chpasswd</div><div class="line">RUN     useradd runoob</div><div class="line">RUN     /bin/echo &apos;runoob:123456&apos; |chpasswd</div><div class="line">RUN     /bin/echo -e &quot;LANG=\&quot;en_US.UTF-8\&quot;&quot; &gt;/etc/default/local</div><div class="line">EXPOSE  22</div><div class="line">EXPOSE  80</div><div class="line">CMD     /usr/sbin/sshd -D</div></pre></td></tr></table></figure></p>
<p>每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。<br>第一条FROM，指定使用哪个镜像源<br>RUN 指令告诉docker 在镜像内执行命令，安装了什么。<br>然后，我们使用 Dockerfile 文件，通过 docker build 命令来构建一个镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker build -t runoob/centos:6.7 .</div><div class="line">Sending build context to Docker daemon 17.92 kB</div><div class="line">Step 1 : FROM centos:6.7</div><div class="line"> ---&amp;gt; d95b5ca17cc3</div><div class="line">Step 2 : MAINTAINER Fisher &quot;fisher@sudops.com&quot;</div><div class="line"> ---&amp;gt; Using cache</div><div class="line"> ---&amp;gt; 0c92299c6f03</div><div class="line">Step 3 : RUN /bin/echo &apos;root:123456&apos; |chpasswd</div><div class="line"> ---&amp;gt; Using cache</div><div class="line"> ---&amp;gt; 0397ce2fbd0a</div><div class="line">Step 4 : RUN useradd runoob</div><div class="line">......</div></pre></td></tr></table></figure></p>
<p>参数说明：  </p>
<ul>
<li>t ：指定要创建的目标镜像名  </li>
<li>. ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径  </li>
</ul>
<p>使用docker images 查看创建的镜像已经在列表中存在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker images</div></pre></td></tr></table></figure></p>
<p>可以使用新的镜像来创建容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker run -t -i runoob/centos:6.7  /bin/bash</div><div class="line">[root@41c28d18b5fb /]# id runoob</div><div class="line">uid=500(runoob) gid=500(runoob) groups=500(runoob)</div></pre></td></tr></table></figure></p>
<h2 id="设置镜像标签"><a href="#设置镜像标签" class="headerlink" title="设置镜像标签"></a>设置镜像标签</h2><p>可以使用 <strong>docker tag</strong> 命令，为镜像添加一个新的标签。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker tag 860c279d2fec runoob/centos:dev</div></pre></td></tr></table></figure></p>
<p>docker tag 镜像ID，这里是 860c279d2fec ,用户名称、镜像源名(repository name)和新的标签名(tag)。  </p>
<p>使用 docker images 命令可以看到，ID为860c279d2fec的镜像多一个标签。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker images</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">runoob/centos       6.7                 860c279d2fec        5 hours ago         190.6 MB</div><div class="line">runoob/centos       dev                 860c279d2fec        5 hours ago         190.6 MB</div></pre></td></tr></table></figure></p>
<h2 id="Docker-容器镜像删除"><a href="#Docker-容器镜像删除" class="headerlink" title="Docker 容器镜像删除"></a>Docker 容器镜像删除</h2><h3 id="停止所有的container，这样才能够删除其中的images："><a href="#停止所有的container，这样才能够删除其中的images：" class="headerlink" title="停止所有的container，这样才能够删除其中的images："></a>停止所有的container，这样才能够删除其中的images：</h3><p>docker stop $(docker ps -a -q)</p>
<p>如果想要删除所有container的话再加一个指令：<br>docker rm $(docker ps -a -q)</p>
<h3 id="查看当前有哪些images"><a href="#查看当前有哪些images" class="headerlink" title="查看当前有哪些images"></a>查看当前有哪些images</h3><p>docker images</p>
<h3 id="删除images，通过image的id来指定删除镜像"><a href="#删除images，通过image的id来指定删除镜像" class="headerlink" title="删除images，通过image的id来指定删除镜像"></a>删除images，通过image的id来指定删除镜像</h3><p>docker rmi <image id=""></image></p>
<p>想要删除untagged images，也就是那些id为<none>的image的话可以用<br>docker rmi $(docker images | grep “^<none>“ | awk “{print $3}”)</none></none></p>
<p>要删除全部image的话<br>docker rmi $(docker images -q)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-镜像使用&quot;&gt;&lt;a href=&quot;#Docker-镜像使用&quot; class=&quot;headerlink&quot; title=&quot;Docker 镜像使用&quot;&gt;&lt;/a&gt;Docker 镜像使用&lt;/h1&gt;&lt;p&gt;当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从
    
    </summary>
    
      <category term="Cloud&amp;BigData" scheme="http://yoursite.com/categories/Cloud-BigData/"/>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Cloud-BigData/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>02_Java并发篇_线程状态_Java内存模型</title>
    <link href="http://yoursite.com/2017/07/29/Backend/Java/concurrence/02_Java%E5%B9%B6%E5%8F%91%E7%AF%87_%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81_Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2017/07/29/Backend/Java/concurrence/02_Java并发篇_线程状态_Java内存模型/</id>
    <published>2017-07-29T12:57:13.000Z</published>
    <updated>2017-07-29T12:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><p>Java中，线程的状态有以下6类：NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED。  </p>
<p><img src="http://i.imgur.com/6UG5qH5.png" alt="">  </p>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>Java内存模型把Java虚拟机内部划分为线程栈和堆。  </p>
<p>每一个运行在Java虚拟机里的线程都拥有自己的线程栈。  </p>
<p>一个线程仅能访问自己的线程栈。一个线程创建的本地变量对其它线程不可见，仅自己可见。  </p>
<p>即使两个线程执行同样的代码，这两个线程任然在在自己的线程栈中的代码来创建本地变量。因此，每个线程拥有每个本地变量的独有版本。  </p>
<p>所有原始类型的本地变量都存放在线程栈上，因此对其它线程不可见。一个线程可能向另一个线程传递一个原始类型变量的拷贝，但是它不能共享这个原始类型变量自身。  </p>
<p>堆上包含在Java程序中创建的所有对象，无论是哪一个对象创建的。这包括原始类型的对象版本。如果一个对象被创建然后赋值给一个局部变量，或者用来作为另一个对象的成员变量，这个对象任然是存放在堆上。  </p>
<p><img src="http://i.imgur.com/KkNgaH3.png" alt="">  </p>
<p>一个本地变量可能是原始类型，在这种情况下，它总是“呆在”线程栈上。  </p>
<p>一个本地变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。  </p>
<p>一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量任然存放在线程栈上，即使这些方法所属的对象存放在堆上。  </p>
<p><strong>一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。</strong>  </p>
<p><strong>静态成员变量跟随着类定义一起也存放在堆上。</strong></p>
<p>存放在堆上的对象可以被所有持有对这个对象引用的线程访问。<br>当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。<br>如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个本地变量的私有拷贝。<br><img src="http://i.imgur.com/P8Qadbg.png" alt="">  </p>
<h1 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a>硬件内存架构</h1><p><img src="http://i.imgur.com/N1SOkpH.png" alt="">  </p>
<p>每个CPU都包含一系列的寄存器，它们是CPU内内存的基础。CPU在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为CPU访问寄存器的速度远大于主存。  </p>
<p>每个CPU可能还有一个CPU缓存层。实际上，绝大多数的现代CPU都有一定大小的缓存层。  </p>
<p>共享对象被初始化在主存中。跑在CPU上的一个线程将这个共享对象读到CPU缓存中。然后修改了这个对象。只要CPU缓存没有被刷新会主存，对象修改后的版本对跑在其它CPU上的线程都是不可见的。这种方式可能导致每个线程拥有这个共享对象的私有拷贝，每个拷贝停留在不同的CPU缓存中。  </p>
<p>跑在左边CPU的线程拷贝这个共享对象到它的CPU缓存中，然后将count变量的值修改为2。这个修改对跑在右边CPU上的其它线程是不可见的，因为修改后的count的值还没有被刷新回主存中去。<br><img src="http://i.imgur.com/aIckfGe.png" alt=""><br>解决这个问题你可以使用Java中的volatile关键字。volatile关键字可以保证直接从主存中读取一个变量，如果这个变量被修改后，总是会被写回到主存中去。  </p>
<h2 id="Race-Conditions"><a href="#Race-Conditions" class="headerlink" title="Race Conditions"></a>Race Conditions</h2><p>如果两个或者更多的线程共享一个对象，多个线程在这个共享对象上更新变量，就有可能发生race conditions。</p>
<p>如果线程A读一个共享对象的变量count到它的CPU缓存中。线程B也做了同样的事情，但是往一个不同的CPU缓存中。现在线程A将count加1，线程B也做了同样的事情。现在count已经被增在了两个，每个CPU缓存中一次。</p>
<p>如果这些增加操作被顺序的执行，变量count应该被增加两次，然后原值+2被写回到主存中去。</p>
<p>然而，两次增加都是在没有适当的同步下并发执行的。无论是线程A还是线程B将count修改后的版本写回到主存中取，修改后的值仅会被原值大1，尽管增加了两次。</p>
<p><img src="http://i.imgur.com/zfLpW4r.png" alt="">  </p>
<p>解决这个问题可以使用Java同步块。<br><strong>一个同步块可以保证在同一时刻仅有一个线程可以进入代码的临界区。</strong><br>同步块还可以保证代码块中所有被访问的变量将会从主存中读入，当线程退出同步代码块时，所有被更新的变量都会被刷新回主存中去，不管这个变量是否被声明为volatile。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线程的状态&quot;&gt;&lt;a href=&quot;#线程的状态&quot; class=&quot;headerlink&quot; title=&quot;线程的状态&quot;&gt;&lt;/a&gt;线程的状态&lt;/h1&gt;&lt;p&gt;Java中，线程的状态有以下6类：NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WA
    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/"/>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>01_Java并发篇_前言</title>
    <link href="http://yoursite.com/2017/07/29/Backend/Java/concurrence/01_Java%E5%B9%B6%E5%8F%91%E7%AF%87_%E5%89%8D%E8%A8%80/"/>
    <id>http://yoursite.com/2017/07/29/Backend/Java/concurrence/01_Java并发篇_前言/</id>
    <published>2017-07-29T12:57:13.000Z</published>
    <updated>2017-07-29T12:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>并发很重要的，前言中记录事件与体会</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并发很重要的，前言中记录事件与体会&lt;/p&gt;

    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/"/>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>05_Java并发篇_饥饿与公平</title>
    <link href="http://yoursite.com/2017/07/29/Backend/Java/concurrence/05_Java%E5%B9%B6%E5%8F%91%E7%AF%87_%E9%A5%A5%E9%A5%BF%E4%B8%8E%E5%85%AC%E5%B9%B3/"/>
    <id>http://yoursite.com/2017/07/29/Backend/Java/concurrence/05_Java并发篇_饥饿与公平/</id>
    <published>2017-07-29T12:57:13.000Z</published>
    <updated>2017-07-29T12:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="饥饿和公平"><a href="#饥饿和公平" class="headerlink" title="饥饿和公平"></a>饥饿和公平</h1><p>如果一个线程因为CPU时间全部被其他线程抢走而得不到CPU运行时间，这种状态被称之为“饥饿”。<br>而该线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。<br>解决饥饿的方案被称之为“公平性” – 即所有线程均能公平地获得运行机会。  </p>
<h2 id="Java中导致饥饿的原因："><a href="#Java中导致饥饿的原因：" class="headerlink" title="Java中导致饥饿的原因："></a>Java中导致饥饿的原因：</h2><ol>
<li><p>高优先级线程吞噬所有的低优先级线程的CPU时间。  </p>
</li>
<li><p>线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。  </p>
</li>
<li><p>线程在等待一个本身(在其上调用wait())也处于永久等待完成的对象，因为其他线程总是被持续地获得唤醒。  </p>
</li>
</ol>
<p>如果多个线程处在wait()方法执行上，而对其调用notify()不会保证哪一个线程会获得唤醒，任何线程都有可能处于继续等待的状态。因此存在这样一个风险：一个等待线程从来得不到唤醒，因为其他等待线程总是能被获得唤醒。</p>
<h3 id="高优先级线程吞噬所有的低优先级线程的CPU时间"><a href="#高优先级线程吞噬所有的低优先级线程的CPU时间" class="headerlink" title="高优先级线程吞噬所有的低优先级线程的CPU时间"></a>高优先级线程吞噬所有的低优先级线程的CPU时间</h3><p>你能为每个线程设置独自的线程优先级，优先级越高的线程获得的CPU时间越多，线程优先级值设置在1到10之间，而这些优先级值所表示行为的准确解释则依赖于你的应用运行平台。对大多数应用来说，你最好是不要改变其优先级值。  </p>
<h3 id="线程被永久堵塞在一个等待进入同步块的状态"><a href="#线程被永久堵塞在一个等待进入同步块的状态" class="headerlink" title="线程被永久堵塞在一个等待进入同步块的状态"></a>线程被永久堵塞在一个等待进入同步块的状态</h3><p>Java的同步代码区也是一个导致饥饿的因素。Java的同步代码区对哪个线程允许进入的次序没有任何保障。这就意味着理论上存在一个试图进入该同步区的线程处于被永久堵塞的风险，因为其他线程总是能持续地先于它获得访问，这即是“饥饿”问题，而一个线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。  </p>
<h3 id="线程在等待一个本身-在其上调用wait-也处于永久等待完成的对象"><a href="#线程在等待一个本身-在其上调用wait-也处于永久等待完成的对象" class="headerlink" title="线程在等待一个本身(在其上调用wait())也处于永久等待完成的对象"></a>线程在等待一个本身(在其上调用wait())也处于永久等待完成的对象</h3><p>如果多个线程处在wait()方法执行上，而对其调用notify()不会保证哪一个线程会获得唤醒，任何线程都有可能处于继续等待的状态。因此存在这样一个风险：一个等待线程从来得不到唤醒，因为其他等待线程总是能被获得唤醒。  </p>
<h2 id="在Java中实现公平性方案"><a href="#在Java中实现公平性方案" class="headerlink" title="在Java中实现公平性方案"></a>在Java中实现公平性方案</h2><ol>
<li>使用锁，而不是同步块。</li>
<li>公平锁。</li>
<li>注意性能方面。</li>
</ol>
<p>Java不可能实现100%的公平性，我们依然可以通过同步结构在线程间实现公平性的提高。</p>
<h3 id="同步态代码"><a href="#同步态代码" class="headerlink" title="同步态代码"></a>同步态代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class Synchronizer&#123;</div><div class="line">  </div><div class="line">    public synchronized void doSynchronized()&#123;</div><div class="line">        //do a lot of work which takes a long time</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果有一个以上的线程调用doSynchronized()方法，在第一个获得访问的线程未完成前，其他线程将一直处于阻塞状态，而且在这种多线程被阻塞的场景下，接下来将是哪个线程获得访问是没有保障的。  </p>
<h3 id="使用锁方式替代同步块"><a href="#使用锁方式替代同步块" class="headerlink" title="使用锁方式替代同步块"></a>使用锁方式替代同步块</h3><p>为了提高等待线程的公平性，使用锁方式来替代同步块。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Synchronizer&#123;</div><div class="line">    Lock lock = new Lock();</div><div class="line">    public void doSynchronized() throws InterruptedException&#123;</div><div class="line">        this.lock.lock();</div><div class="line">        //critical section, do a lot of work which takes a long time</div><div class="line">        this.lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>doSynchronized()不再声明为synchronized，而是用lock.lock()和lock.unlock()来替代。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class Lock&#123;</div><div class="line">  </div><div class="line">    private boolean isLocked      = false;</div><div class="line">    private Thread lockingThread = null;</div><div class="line">  </div><div class="line">    public synchronized void lock() throws InterruptedException&#123;</div><div class="line">  </div><div class="line">        while(isLocked)&#123;</div><div class="line">            wait();</div><div class="line">        &#125;</div><div class="line">  </div><div class="line">        isLocked = true;</div><div class="line">        lockingThread = Thread.currentThread();</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    public synchronized void unlock()&#123;</div><div class="line">  </div><div class="line">        if(this.lockingThread != Thread.currentThread())&#123;</div><div class="line">  </div><div class="line">             throw new IllegalMonitorStateException(</div><div class="line">                  &quot;Calling thread has not locked this lock&quot;);</div><div class="line">             &#125;</div><div class="line">  </div><div class="line">        isLocked = false;</div><div class="line">        lockingThread = null;</div><div class="line">        notify();</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果存在多线程并发访问lock()，这些线程将阻塞在对lock()方法的访问上。另外，如果锁已经锁上（校对注：这里指的是isLocked等于true时），这些线程将阻塞在while(isLocked)循环的wait()调用里面。要记住的是，当线程正在等待进入lock() 时，可以调用wait()释放其锁实例对应的同步锁，使得其他多个线程可以进入lock()方法，并调用wait()方法。  </p>
<p>在lock()和unlock()之间：在这两个调用之间的代码将运行很长一段时间。进一步设想，这段代码将长时间运行，和进入lock()并调用wait()来比较的话。这意味着大部分时间用在等待进入锁和进入临界区的过程是用在wait()的等待中，而不是被阻塞在试图进入lock()方法中。  </p>
<p>同步块不会对等待进入的多个线程谁能获得访问做任何保障，同样当调用notify()时，也不会做保障一定能唤醒线程。因此这个的Lock类和doSynchronized()那个就保障公平性而言，没有任何区别。</p>
<p>但是，如果每个线程在不同的对象上调用wait()，那么只有一个线程会在该对象上调用wait()，Lock类可以决定哪个对象能对其调用notify()，因此能做到有效的选择唤醒哪个线程。</p>
<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>每一个调用lock()的线程都会进入一个队列，当解锁后，只有队列里的第一个线程被允许锁住Farlock实例，所有其它的线程都将处于等待状态，直到他们处于队列头部。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public class FairLock &#123;</div><div class="line">    private boolean           isLocked       = false;</div><div class="line">    private Thread            lockingThread  = null;</div><div class="line">    private List&lt;QueueObject&gt; waitingThreads = new ArrayList&lt;QueueObject&gt;();</div><div class="line"></div><div class="line">  public void lock() throws InterruptedException&#123;</div><div class="line">    QueueObject queueObject = new QueueObject();</div><div class="line">    boolean isLockedForThisThread = true;</div><div class="line">    synchronized(this)&#123;</div><div class="line">        waitingThreads.add(queueObject);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    while(isLockedForThisThread)&#123;</div><div class="line">      synchronized(this)&#123;</div><div class="line">        isLockedForThisThread =</div><div class="line">            isLocked || waitingThreads.get(0) != queueObject;</div><div class="line">        if(!isLockedForThisThread)&#123;</div><div class="line">          isLocked = true;</div><div class="line">           waitingThreads.remove(queueObject);</div><div class="line">           lockingThread = Thread.currentThread();</div><div class="line">           return;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      try&#123;</div><div class="line">        queueObject.doWait();</div><div class="line">      &#125;catch(InterruptedException e)&#123;</div><div class="line">        synchronized(this) &#123; waitingThreads.remove(queueObject); &#125;</div><div class="line">        throw e;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  public synchronized void unlock()&#123;</div><div class="line">    if(this.lockingThread != Thread.currentThread())&#123;</div><div class="line">      throw new IllegalMonitorStateException(</div><div class="line">        &quot;Calling thread has not locked this lock&quot;);</div><div class="line">    &#125;</div><div class="line">    isLocked      = false;</div><div class="line">    lockingThread = null;</div><div class="line">    if(waitingThreads.size() &gt; 0)&#123;</div><div class="line">      waitingThreads.get(0).doNotify();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class QueueObject &#123;</div><div class="line">  </div><div class="line">    private boolean isNotified = false;</div><div class="line">  </div><div class="line">    public synchronized void doWait() throws InterruptedException &#123;</div><div class="line"></div><div class="line">        while(!isNotified)&#123;</div><div class="line">            this.wait();</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        this.isNotified = false;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    public synchronized void doNotify() &#123;</div><div class="line">        this.isNotified = true;</div><div class="line">        this.notify();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public boolean equals(Object o) &#123;</div><div class="line">        return this == o;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>lock()方法不在声明为synchronized，取而代之的是对必需同步的代码，在synchronized中进行嵌套。  </p>
<p>FairLock新创建了一个QueueObject的实例，并对每个调用lock()的线程进行入队列。调用unlock()的线程将从队列头部获取QueueObject，并对其调用doNotify()，以唤醒在该对象上等待的线程。通过这种方式，在同一时间仅有一个等待线程获得唤醒，而不是所有的等待线程。这也是实现FairLock公平性的核心所在。  </p>
<p>请注意，在同一个同步块中，锁状态依然被检查和设置，以避免出现滑漏条件。  </p>
<p>还需注意到，QueueObject实际是一个semaphore。doWait()和doNotify()方法在QueueObject中保存着信号。这样做以避免一个线程在调用queueObject.doWait()之前被另一个调用unlock()并随之调用queueObject.doNotify()的线程重入，从而导致信号丢失。queueObject.doWait()调用放置在synchronized(this)块之外，以避免被monitor嵌套锁死，所以另外的线程可以解锁，只要当没有线程在lock方法的synchronized(this)块中执行即可。  </p>
<p>最后，注意到queueObject.doWait()在try – catch块中是怎样调用的。在InterruptedException抛出的情况下，线程得以离开lock()，并需让它从队列中移除。  </p>
<h3 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h3><p>如果比较Lock和FairLock类，你会注意到在FairLock类中lock()和unlock()还有更多需要深入的地方。这些额外的代码会导致FairLock的同步机制实现比Lock要稍微慢些。究竟存在多少影响，还依赖于应用在FairLock临界区执行的时长。执行时长越大，FairLock带来的负担影响就越小，当然这也和代码执行的频繁度相关。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;饥饿和公平&quot;&gt;&lt;a href=&quot;#饥饿和公平&quot; class=&quot;headerlink&quot; title=&quot;饥饿和公平&quot;&gt;&lt;/a&gt;饥饿和公平&lt;/h1&gt;&lt;p&gt;如果一个线程因为CPU时间全部被其他线程抢走而得不到CPU运行时间，这种状态被称之为“饥饿”。&lt;br&gt;而该线程被“饥
    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/"/>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>04_Java并发篇_死锁</title>
    <link href="http://yoursite.com/2017/07/29/Backend/Java/concurrence/04_Java%E5%B9%B6%E5%8F%91%E7%AF%87_%E6%AD%BB%E9%94%81/"/>
    <id>http://yoursite.com/2017/07/29/Backend/Java/concurrence/04_Java并发篇_死锁/</id>
    <published>2017-07-29T12:57:13.000Z</published>
    <updated>2017-07-29T12:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>死锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。  </p>
<p>例如：<br>如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这时死锁就发生了。<br>线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。  </p>
<h1 id="数据库的死锁"><a href="#数据库的死锁" class="headerlink" title="数据库的死锁"></a>数据库的死锁</h1><p>更加复杂的死锁场景发生在数据库事务中。一个数据库事务可能由多条SQL更新请求组成。<br><strong>当在一个事务中更新一条记录，这条记录就会被锁住避免其他事务的更新请求，直到第一个事务结束。</strong><br>同一个事务中每一个更新请求都可能会锁住一些记录。  </p>
<p>当多个事务同时需要对一些相同的记录做更新操作时，就很有可能发生死锁，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Transaction 1, request 1, locks record 1 for update</div><div class="line">Transaction 2, request 1, locks record 2 for update</div><div class="line">Transaction 1, request 2, tries to lock record 2 for update.</div><div class="line">Transaction 2, request 2, tries to lock record 1 for update.</div></pre></td></tr></table></figure></p>
<p>因为锁发生在不同的请求中，并且对于一个事务来说不可能提前知道所有它需要的锁，因此很难检测和避免数据库事务中的死锁。  </p>
<h1 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h1><p>在有些情况下死锁是可以避免的。  </p>
<ol>
<li>加锁顺序</li>
<li>加锁时限</li>
<li>死锁检测</li>
</ol>
<h2 id="加锁顺序"><a href="#加锁顺序" class="headerlink" title="加锁顺序"></a>加锁顺序</h2><p>当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。  </p>
<p>如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Thread 1:</div><div class="line">  lock A </div><div class="line">  lock B</div><div class="line">  </div><div class="line">Thread 2:</div><div class="line">   wait for A</div><div class="line">   lock C (when A locked)</div><div class="line">  </div><div class="line">Thread 3:</div><div class="line">   wait for A</div><div class="line">   wait for B</div><div class="line">   wait for C</div></pre></td></tr></table></figure></p>
<p>按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁(译者注：并对这些锁做适当的排序)，但总有些时候是无法预知的。  </p>
<h2 id="加锁时限"><a href="#加锁时限" class="headerlink" title="加锁时限"></a>加锁时限</h2><p>另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。<br>若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。  </p>
<p>这段随机的等待时间让其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行(注：加锁超时后可以先继续运行干点其它事情，再回头来重复之前加锁的逻辑)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Thread 1 locks A</div><div class="line">Thread 2 locks B</div><div class="line">  </div><div class="line">Thread 1 attempts to lock B but is blocked</div><div class="line">Thread 2 attempts to lock A but is blocked</div><div class="line">  </div><div class="line">Thread 1&apos;s lock attempt on B times out</div><div class="line">Thread 1 backs up and releases A as well</div><div class="line">Thread 1 waits randomly (e.g. 257 millis) before retrying.</div><div class="line">  </div><div class="line">Thread 2&apos;s lock attempt on A times out</div><div class="line">Thread 2 backs up and releases B as well</div><div class="line">Thread 2 waits randomly (e.g. 43 millis) before retrying.</div></pre></td></tr></table></figure></p>
<p>需要注意的是，由于存在锁的超时，所以我们不能认为这种场景就一定是出现了死锁。也可能是因为获得了锁的线程（导致其它线程超时）需要很长的时间去完成它的任务。  </p>
<p>此外，如果有非常多的线程同一时间去竞争同一批资源，就算有超时和回退机制，还是可能会导致这些线程重复地尝试但却始终得不到锁。如果只有两个线程，并且重试的超时时间设定为0到500毫秒之间，这种现象可能不会发生，但是如果是10个或20个线程情况就不同了。因为这些线程等待相等的重试时间的概率就高的多（或者非常接近以至于会出现问题）。  </p>
<h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><p>死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。  </p>
<p>每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。  </p>
<p>当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。例如，线程A请求锁7，但是锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前所持有的锁。如果线程B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线程B拥有锁7，请求锁1）。  </p>
<p>当然，死锁一般要比两个线程互相持有对方的锁这种情况要复杂的多。线程A等待线程B，线程B等待线程C，线程C等待线程D，线程D又在等待线程A。线程A为了检测死锁，它需要递进地检测所有被B请求的锁。从线程B所请求的锁开始，线程A找到了线程C，然后又找到了线程D，发现线程D请求的锁被线程A自己持有着。这是它就知道发生了死锁。  </p>
<p>可以被用来检测死锁的数据结构。<br><img src="http://i.imgur.com/wW4vN5G.png" alt="">  </p>
<p>那么当检测出死锁时，这些线程该做些什么呢？  </p>
<p>一个可行的做法是释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁（编者注：原因同超时类似，不能从根本上减轻竞争）。  </p>
<p>一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁&quot;&gt;&lt;/a&gt;死锁&lt;/h1&gt;&lt;p&gt;死锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。  &lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/"/>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>01_Java容器篇_前言</title>
    <link href="http://yoursite.com/2017/07/29/Backend/Java/container/01_Java%E5%AE%B9%E5%99%A8%E7%AF%87_%E5%89%8D%E8%A8%80/"/>
    <id>http://yoursite.com/2017/07/29/Backend/Java/container/01_Java容器篇_前言/</id>
    <published>2017-07-29T12:57:13.000Z</published>
    <updated>2017-07-29T12:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>这几天一直在面试，跟一个面试官聊了挺多，其中有一点感悟特别深，也提点了我。</p>
<p>是啊，有些知识点可能永远也用不上，像ArrayList和LinkedList，源码这辈子不知道都没关系，可惜，用不到不能够是偷懒就不学的理由，积少成多才能质变。</p>
<p>所以从现在必须花时间看源码上。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天一直在面试，跟一个面试官聊了挺多，其中有一点感悟特别深，也提点了我。&lt;/p&gt;
&lt;p&gt;是啊，有些知识点可能永远也用不上，像ArrayList和LinkedList，源码这辈子不知道都没关系，可惜，用不到不能够是偷懒就不学的理由，积少成多才能质变。&lt;/p&gt;
&lt;p&gt;所以从现
    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/"/>
    
      <category term="容器" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="Java容器" scheme="http://yoursite.com/tags/Java%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>02_Java容器篇_ThreadLocal</title>
    <link href="http://yoursite.com/2017/07/29/Backend/Java/container/02_Java%E5%AE%B9%E5%99%A8%E7%AF%87_ThreadLocal/"/>
    <id>http://yoursite.com/2017/07/29/Backend/Java/container/02_Java容器篇_ThreadLocal/</id>
    <published>2017-07-29T12:57:13.000Z</published>
    <updated>2017-07-29T12:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p>
<h1 id="ThreadLocal类提供的方法："><a href="#ThreadLocal类提供的方法：" class="headerlink" title="ThreadLocal类提供的方法："></a>ThreadLocal类提供的方法：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public T get() &#123; &#125;</div><div class="line">public void set(T value) &#123; &#125;</div><div class="line">public void remove() &#123; &#125;</div><div class="line">protected T initialValue() &#123; &#125;</div></pre></td></tr></table></figure>
<p>get()方法是用来获取ThreadLocal在当前线程中保存的变量副本，<br>set()用来设置当前线程中变量的副本，<br>remove()用来移除当前线程中变量的副本，<br>initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法  </p>
<h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><p><img src="http://i.imgur.com/A9nfw1e.jpg" alt="">  </p>
<p>第一句是取得当前线程，然后通过getMap(t)方法获取到一个map，map的类型为ThreadLocalMap。然后接着下面获取到<key,value>键值对，注意这里获取键值对传进去的是  this，而不是当前线程t。  </key,value></p>
<p>如果获取成功，则返回value值。  </p>
<p>如果map为空，则调用setInitialValue方法返回value。  </p>
<p>getMap()<br><img src="http://i.imgur.com/OyctcgA.jpg" alt="">  </p>
<p>在getMap中，是调用当期线程t，返回当前线程t中的一个成员变量threadLocals。<br><img src="http://i.imgur.com/qPnpfOa.jpg" alt="">  </p>
<p>实际上就是一个ThreadLocalMap，这个类型是ThreadLocal类的一个内部类:<br><img src="http://i.imgur.com/2g2gaS2.jpg" alt=""><br>ThreadLocalMap的Entry继承了WeakReference，并且使用ThreadLocal作为键值。  </p>
<h2 id="setInitialValue"><a href="#setInitialValue" class="headerlink" title="setInitialValue()"></a>setInitialValue()</h2><p><img src="http://i.imgur.com/6ROXpdf.jpg" alt=""><br>如果map不为空，就设置键值对，为空，再创建Map<br><img src="http://i.imgur.com/gf3RhcN.jpg" alt="">  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。  </p>
<p>初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。  </p>
<p>然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。  </p>
<p>1）实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的；</p>
<p>2）为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个类型不同的threadLocal变量；</p>
<p>3）在进行get之前，必须先set，否则会报空指针异常；  </p>
<p>如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法。  </p>
<p>如果没有先set的话，即在map中查找不到对应的存储，则会通过调用setInitialValue方法返回i，而在setInitialValue方法中，有一个语句是T value = initialValue()， 而默认情况下，initialValue方法返回的是null</p>
<p><img src="http://i.imgur.com/7QdrQ0S.jpg" alt="">  </p>
<h1 id="ThreadLocal的应用场景"><a href="#ThreadLocal的应用场景" class="headerlink" title="ThreadLocal的应用场景"></a>ThreadLocal的应用场景</h1><p>最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ThreadLocal&quot;&gt;&lt;a href=&quot;#ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal&quot;&gt;&lt;/a&gt;ThreadLocal&lt;/h1&gt;&lt;p&gt;ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线
    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/"/>
    
      <category term="容器" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="Java容器" scheme="http://yoursite.com/tags/Java%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>03_Java并发篇_Java同步块</title>
    <link href="http://yoursite.com/2017/07/29/Backend/Java/concurrence/03_Java%E5%B9%B6%E5%8F%91%E7%AF%87_Java%E5%90%8C%E6%AD%A5%E5%9D%97/"/>
    <id>http://yoursite.com/2017/07/29/Backend/Java/concurrence/03_Java并发篇_Java同步块/</id>
    <published>2017-07-29T12:57:13.000Z</published>
    <updated>2017-07-29T12:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-同步关键字（synchronized）"><a href="#Java-同步关键字（synchronized）" class="headerlink" title="Java 同步关键字（synchronized）"></a>Java 同步关键字（synchronized）</h1><p>Java中的同步块用synchronized标记。同步块在Java中是同步在某个对象上。所有同步在一个对象上的同步块在同时只能被一个线程进入并执行操作。所有其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出。  </p>
<p>有四种不同的同步块：  </p>
<ol>
<li>实例方法</li>
<li>静态方法</li>
<li>实例方法中的同步块</li>
<li>静态方法中的同步块</li>
</ol>
<h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><p>1、通过共享对象通信</p>
<p>2、忙等待</p>
<p>3、wait(),notify()和notifyAll()</p>
<p>4、丢失的信号</p>
<p>5、不要对常量字符串或全局对象调用wait()</p>
<h2 id="通过共享对象通信"><a href="#通过共享对象通信" class="headerlink" title="通过共享对象通信"></a>通过共享对象通信</h2><p>线程间发送信号的一个简单方式是在共享对象的变量里设置信号值。线程A在一个同步块里设置boolean型成员变量hasDataToProcess为true，线程B也在同步块里读取hasDataToProcess这个成员变量。这个简单的例子使用了一个持有信号的对象，并提供了set和check方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class MySignal&#123;</div><div class="line">  </div><div class="line">  protected boolean hasDataToProcess = false;</div><div class="line">  </div><div class="line">  public synchronized boolean hasDataToProcess()&#123;</div><div class="line">    return this.hasDataToProcess;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  public synchronized void setHasDataToProcess(boolean hasData)&#123;</div><div class="line">    this.hasDataToProcess = hasData;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>线程A和B必须获得指向一个MySignal共享实例的引用，以便进行通信。如果它们持有的引用指向不同的MySingal实例，那么彼此将不能检测到对方的信号。需要处理的数据可以存放在一个共享缓存区里，它和MySignal实例是分开存放的。</p>
<h2 id="忙等待-Busy-Wait"><a href="#忙等待-Busy-Wait" class="headerlink" title="忙等待(Busy Wait)"></a>忙等待(Busy Wait)</h2><p>准备处理数据的线程B正在等待数据变为可用。换句话说，它在等待线程A的一个信号，这个信号使hasDataToProcess()返回true。线程B运行在一个循环里，以等待这个信号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">protected MySignal sharedSignal = ...</div><div class="line">...</div><div class="line">while(!sharedSignal.hasDataToProcess())&#123;</div><div class="line">  //do nothing... busy waiting</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="wait-notify-和notifyAll"><a href="#wait-notify-和notifyAll" class="headerlink" title="wait(),notify()和notifyAll()"></a>wait(),notify()和notifyAll()</h2><p>忙等待没有对运行等待线程的CPU进行有效的利用。否则，让等待线程进入睡眠或者非运行状态更为明智，直到它接收到它等待的信号。</p>
<p>忙等待没有对运行等待线程的CPU进行有效的利用，除非平均等待时间非常短。否则，让等待线程进入睡眠或者非运行状态更为明智，直到它接收到它等待的信号。  </p>
<p>Java有一个内建的等待机制来允许线程在等待信号的时候变为非运行状态。java.lang.Object 类定义了三个方法，wait()、notify()和notifyAll()来实现这个等待机制。  </p>
<p>一个线程一旦调用了任意对象的wait()方法，就会变为非运行状态，直到另一个线程调用了同一个对象的notify()方法。为了调用wait()或者notify()，线程必须先获得那个对象的锁。也就是说，线程必须在同步块里调用wait()或者notify()。  </p>
<p>当一个线程调用一个对象的notify()方法，正在等待该对象的所有线程中将有一个线程被唤醒并允许执行（校注：这个将被唤醒的线程是随机的，不可以指定唤醒哪个线程）。同时也提供了一个notifyAll()方法来唤醒正在等待一个给定对象的所有线程。  </p>
<blockquote>
<p>JVM是这么实现的，当你调用wait时候它首先要检查下当前线程是否是锁的拥有者，不是则抛出IllegalMonitorStateExcept，参考JVM源码的 1422行。  </p>
</blockquote>
<p>一旦一个线程被唤醒，不能立刻就退出wait()的方法调用，直到调用notify()的线程退出了它自己的同步块。换句话说：被唤醒的线程必须重新获得监视器对象的锁，才可以退出wait()的方法调用，因为wait方法调用运行在同步块里面。如果多个线程被notifyAll()唤醒，那么在同一时刻将只有一个线程可以退出wait()方法，因为每个线程在退出wait()前必须获得监视器对象的锁。  </p>
<h2 id="丢失的信号（Missed-Signals）"><a href="#丢失的信号（Missed-Signals）" class="headerlink" title="丢失的信号（Missed Signals）"></a>丢失的信号（Missed Signals）</h2><p>notify()和notifyAll()方法不会保存调用它们的方法，因为当这两个方法被调用时，有可能没有线程处于等待状态。通知信号过后便丢弃了。因此，如果一个线程先于被通知线程调用wait()前调用了notify()，等待的线程将错过这个信号。这可能是也可能不是个问题。不过，在某些情况下，这可能使等待线程永远在等待，不再醒来，因为线程错过了唤醒信号。<br>为了避免丢失信号，必须把它们保存在信号类里。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class MyWaitNotify2&#123;</div><div class="line">  </div><div class="line">  MonitorObject myMonitorObject = new MonitorObject();</div><div class="line">  boolean wasSignalled = false;</div><div class="line">  </div><div class="line">  public void doWait()&#123;</div><div class="line">    synchronized(myMonitorObject)&#123;</div><div class="line">      if(!wasSignalled)&#123;</div><div class="line">        try&#123;</div><div class="line">          myMonitorObject.wait();</div><div class="line">         &#125; catch(InterruptedException e)&#123;...&#125;</div><div class="line">      &#125;</div><div class="line">      //clear signal and continue running.</div><div class="line">      wasSignalled = false;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  public void doNotify()&#123;</div><div class="line">    synchronized(myMonitorObject)&#123;</div><div class="line">      wasSignalled = true;</div><div class="line">      myMonitorObject.notify();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>留意doNotify()方法在调用notify()前把wasSignalled变量设为true。同时，留意doWait()方法在调用wait()前会检查wasSignalled变量。事实上，如果没有信号在前一次doWait()调用和这次doWait()调用之间的时间段里被接收到，它将只调用wait()。  </p>
<p>（为了避免信号丢失， 用一个变量来保存是否被通知过。在notify前，设置自己已经被通知过。在wait后，设置自己没有被通知过，需要等待通知。）  </p>
<h2 id="不要在字符串常量或全局对象中调用wait"><a href="#不要在字符串常量或全局对象中调用wait" class="headerlink" title="不要在字符串常量或全局对象中调用wait()"></a>不要在字符串常量或全局对象中调用wait()</h2><p>JVM/编译器内部会把常量字符串转换成同一个对象。这意味着，即使你有2个不同的MyWaitNotify实例，它们都引用了相同的空字符串实例。  </p>
<p>在wait()/notify()机制中，不要使用全局对象，字符串常量等。应该使用对应唯一的对象。  </p>
<p>管程 (Monitors，也称为监视器) 是对多个工作线程实现互斥访问共享资源的对象或模块。这些共享资源一般是硬件设备或一群变量。管程实现了在一个时间点，最多只有一个线程在执行它的某个子程序。与那些通过修改数据结构实现互斥访问的并发程序设计相比，管程很大程度上简化了程序设计。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-同步关键字（synchronized）&quot;&gt;&lt;a href=&quot;#Java-同步关键字（synchronized）&quot; class=&quot;headerlink&quot; title=&quot;Java 同步关键字（synchronized）&quot;&gt;&lt;/a&gt;Java 同步关键字（syn
    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/"/>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>02_Python函数</title>
    <link href="http://yoursite.com/2017/07/16/Backend/Python/Base/02_%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2017/07/16/Backend/Python/Base/02_函数/</id>
    <published>2017-07-16T07:23:07.000Z</published>
    <updated>2017-07-16T07:23:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python内置函数"><a href="#Python内置函数" class="headerlink" title="Python内置函数"></a>Python内置函数</h1><p><a href="http://docs.python.org/3/library/functions.html#abs" target="_blank" rel="external">http://docs.python.org/3/library/functions.html#abs</a>  </p>
<p>以在交互式命令行通过help(abs)查看abs函数的帮助信息。  </p>
<p>abs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; abs(100)</div><div class="line">100</div><div class="line">&gt;&gt;&gt; abs(-20)</div><div class="line">20</div><div class="line">&gt;&gt;&gt; abs(12.34)</div><div class="line">12.34</div></pre></td></tr></table></figure></p>
<p>max<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; max(1, 2)</div><div class="line">2</div><div class="line">&gt;&gt;&gt; max(2, 3, 1, -5)</div><div class="line">3</div></pre></td></tr></table></figure></p>
<h1 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; int(&apos;123&apos;)</div><div class="line">123</div><div class="line">&gt;&gt;&gt; int(12.34)</div><div class="line">12</div><div class="line">&gt;&gt;&gt; float(&apos;12.34&apos;)</div><div class="line">12.34</div><div class="line">&gt;&gt;&gt; str(1.23)</div><div class="line">&apos;1.23&apos;</div><div class="line">&gt;&gt;&gt; str(100)</div><div class="line">&apos;100&apos;</div><div class="line">&gt;&gt;&gt; bool(1)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; bool(&apos;&apos;)</div><div class="line">False</div></pre></td></tr></table></figure>
<p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = abs # 变量a指向abs函数</div><div class="line">&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数</div><div class="line">1</div></pre></td></tr></table></figure></p>
<h1 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h1><p>在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def my_abs(x):</div><div class="line">    if x &gt;= 0:</div><div class="line">        return x</div><div class="line">    else:</div><div class="line">        return -x</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。  </p>
</blockquote>
<p>如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。  </p>
<p>return None可以简写为return  </p>
<p>如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python解释器，用from abstest import my_abs来导入my_abs()函数，注意abstest是文件名（不含.py扩展名）：</p>
<h1 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h1><p>如果想定义一个什么事也不做的空函数，可以用pass语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def nop():</div><div class="line">    pass</div></pre></td></tr></table></figure></p>
<p>实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。</p>
<p>pass还可以用在其他语句里，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if age &gt;= 18:</div><div class="line">    pass</div></pre></td></tr></table></figure></p>
<p>缺少了pass，代码运行就会有语法错误。</p>
<h1 id="参数检查"><a href="#参数检查" class="headerlink" title="参数检查"></a>参数检查</h1><p>调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError：</p>
<p>如果参数类型不对，Python解释器就无法帮我们检查。试试my_abs和内置函数abs的差别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; my_abs(&apos;A&apos;)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 2, in my_abs</div><div class="line">TypeError: unorderable types: str() &gt;= int()</div><div class="line">&gt;&gt;&gt; abs(&apos;A&apos;)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">TypeError: bad operand type for abs(): &apos;str&apos;</div></pre></td></tr></table></figure></p>
<p>数据类型检查可以用内置函数isinstance()实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def my_abs(x):</div><div class="line">    if not isinstance(x, (int, float)):</div><div class="line">        raise TypeError(&apos;bad operand type&apos;)</div><div class="line">    if x &gt;= 0:</div><div class="line">        return x</div><div class="line">    else:</div><div class="line">        return -x</div></pre></td></tr></table></figure></p>
<p>如果传入错误的参数类型，函数就可以抛出一个错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; my_abs(&apos;A&apos;)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 3, in my_abs</div><div class="line">TypeError: bad operand type</div></pre></td></tr></table></figure></p>
<h1 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import math</div><div class="line"></div><div class="line">def move(x, y, step, angle=0):</div><div class="line">    nx = x + step * math.cos(angle)</div><div class="line">    ny = y - step * math.sin(angle)</div><div class="line">    return nx, ny</div></pre></td></tr></table></figure>
<p>import math语句表示导入math包，并允许后续代码引用math包里的sin、cos等函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)</div><div class="line">&gt;&gt;&gt; print(x, y)</div><div class="line">151.96152422706632 70.0</div></pre></td></tr></table></figure>
<p>Python函数返回的仍然是单一值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)</div><div class="line">&gt;&gt;&gt; print(r)</div><div class="line">(151.96152422706632, 70.0)</div></pre></td></tr></table></figure></p>
<p>返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。  </p>
<h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def power(x, n=2):</div><div class="line">    s = 1</div><div class="line">    while n &gt; 0:</div><div class="line">        n = n - 1</div><div class="line">        s = s * x</div><div class="line">    return s</div></pre></td></tr></table></figure>
<p>设置默认参数时，有几点要注意：</p>
<ol>
<li><p>必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；  </p>
</li>
<li><p>如何设置默认参数。<br>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</p>
</li>
</ol>
<p>默认参数很有用，但使用不当，也会掉坑里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">def add_end(L=[]):</div><div class="line">    L.append(&apos;END&apos;)</div><div class="line">    return L</div><div class="line">  </div><div class="line">&gt;&gt;&gt; add_end([1, 2, 3])</div><div class="line">[1, 2, 3, &apos;END&apos;]</div><div class="line">&gt;&gt;&gt; add_end([&apos;x&apos;, &apos;y&apos;, &apos;z&apos;])</div><div class="line">[&apos;x&apos;, &apos;y&apos;, &apos;z&apos;, &apos;END&apos;]</div><div class="line">  </div><div class="line">&gt;&gt;&gt; add_end()</div><div class="line">[&apos;END&apos;]</div><div class="line">  </div><div class="line">&gt;&gt;&gt; add_end()</div><div class="line">[&apos;END&apos;, &apos;END&apos;]</div><div class="line">&gt;&gt;&gt; add_end()</div><div class="line">[&apos;END&apos;, &apos;END&apos;, &apos;END&apos;]</div></pre></td></tr></table></figure></p>
<p>原因解释如下：  </p>
<p>Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。  </p>
<p>所以，定义默认参数要牢记一点：默认参数必须指向不变对象！  </p>
<p>可以用None这个不变对象来实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def add_end(L=None):</div><div class="line">    if L is None:</div><div class="line">        L = []</div><div class="line">    L.append(&apos;END&apos;)</div><div class="line">    return L</div></pre></td></tr></table></figure></p>
<h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><p>参数个数可变  </p>
<p>组装出一个list或tuple：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">def calc(numbers):</div><div class="line">    sum = 0</div><div class="line">    for n in numbers:</div><div class="line">        sum = sum + n * n</div><div class="line">    return sum</div><div class="line">  </div><div class="line">&gt;&gt;&gt; calc([1, 2, 3])</div><div class="line">14</div><div class="line">&gt;&gt;&gt; calc((1, 3, 5, 7))</div><div class="line">84</div></pre></td></tr></table></figure></p>
<p>可变参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def calc(*numbers):</div><div class="line">    sum = 0</div><div class="line">    for n in numbers:</div><div class="line">        sum = sum + n * n</div><div class="line">    return sum</div></pre></td></tr></table></figure></p>
<p>定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：  </p>
<p>如果已经有一个list或者tuple，要调用一个可变参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; nums = [1, 2, 3]</div><div class="line">&gt;&gt;&gt; calc(nums[0], nums[1], nums[2])</div><div class="line">14</div></pre></td></tr></table></figure></p>
<p>Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; nums = [1, 2, 3]</div><div class="line">&gt;&gt;&gt; calc(*nums)</div><div class="line">14</div></pre></td></tr></table></figure></p>
<h1 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h1><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">def person(name, age, **kw):</div><div class="line">    print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw)</div><div class="line">  </div><div class="line">&gt;&gt;&gt; person(&apos;Michael&apos;, 30)</div><div class="line">name: Michael age: 30 other: &#123;&#125;</div><div class="line">  </div><div class="line">&gt;&gt;&gt; person(&apos;Bob&apos;, 35, city=&apos;Beijing&apos;)</div><div class="line">name: Bob age: 35 other: &#123;&apos;city&apos;: &apos;Beijing&apos;&#125;</div><div class="line">&gt;&gt;&gt; person(&apos;Adam&apos;, 45, gender=&apos;M&apos;, job=&apos;Engineer&apos;)</div><div class="line">name: Adam age: 45 other: &#123;&apos;gender&apos;: &apos;M&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</div><div class="line">  </div><div class="line">&gt;&gt;&gt; extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</div><div class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, city=extra[&apos;city&apos;], job=extra[&apos;job&apos;])</div><div class="line">name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</div><div class="line">  </div><div class="line">&gt;&gt;&gt; extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</div><div class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, **extra)</div><div class="line">name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</div></pre></td></tr></table></figure>
<p><code>**extra</code>表示把extra这个dict的所有key-value用关键字参数传入到函数的<code>**kw</code>参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。</p>
<h1 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h1><p>如果要限制关键字参数的名字，就可以用命名关键字参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def person(name, age, *, city, job):</div><div class="line">    print(name, age, city, job)</div><div class="line">  </div><div class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, city=&apos;Beijing&apos;, job=&apos;Engineer&apos;)</div><div class="line">Jack 24 Beijing Engineer</div></pre></td></tr></table></figure></p>
<p>和关键字参数<em>*kw不同，命名关键字参数需要一个特殊分隔符</em>，*后面的参数被视为命名关键字参数。  </p>
<p>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：  </p>
<p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def person(name, age, *args, city, job):</div><div class="line">    print(name, age, args, city, job)</div></pre></td></tr></table></figure></p>
<p>命名关键字参数可以有缺省值，从而简化调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def person(name, age, *, city=&apos;Beijing&apos;, job):</div><div class="line">    print(name, age, city, job)</div><div class="line">  </div><div class="line"># 命名关键字参数city具有默认值，调用时，可不传入city参数  </div><div class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, job=&apos;Engineer&apos;)</div><div class="line">Jack 24 Beijing Engineer</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def person(name, age, city, job):</div><div class="line">    # 缺少 *，city和job被视为位置参数</div><div class="line">    pass</div></pre></td></tr></table></figure>
<h1 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h1><p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。  </p>
<p>但是请注意，参数定义的顺序必须是：<br><strong>必选参数、默认参数、可变参数、命名关键字参数和关键字参数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def f1(a, b, c=0, *args, **kw):</div><div class="line">    print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;args =&apos;, args, &apos;kw =&apos;, kw)</div><div class="line"></div><div class="line">def f2(a, b, c=0, *, d, **kw):</div><div class="line">    print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;d =&apos;, d, &apos;kw =&apos;, kw)</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; f1(1, 2)</div><div class="line">a = 1 b = 2 c = 0 args = () kw = &#123;&#125;</div><div class="line">&gt;&gt;&gt; f1(1, 2, c=3)</div><div class="line">a = 1 b = 2 c = 3 args = () kw = &#123;&#125;</div><div class="line">&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;)</div><div class="line">a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = &#123;&#125;</div><div class="line">&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;, x=99)</div><div class="line">a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = &#123;&apos;x&apos;: 99&#125;</div><div class="line">&gt;&gt;&gt; f2(1, 2, d=99, ext=None)</div><div class="line">a = 1 b = 2 c = 0 d = 99 kw = &#123;&apos;ext&apos;: None&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; args = (1, 2, 3, 4)</div><div class="line">&gt;&gt;&gt; kw = &#123;&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;&#125;</div><div class="line">&gt;&gt;&gt; f1(*args, **kw)</div><div class="line">a = 1 b = 2 c = 3 args = (4,) kw = &#123;&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;&#125;</div><div class="line">&gt;&gt;&gt; args = (1, 2, 3)</div><div class="line">&gt;&gt;&gt; kw = &#123;&apos;d&apos;: 88, &apos;x&apos;: &apos;#&apos;&#125;</div><div class="line">&gt;&gt;&gt; f2(*args, **kw)</div><div class="line">a = 1 b = 2 c = 3 d = 88 kw = &#123;&apos;x&apos;: &apos;#&apos;&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python内置函数&quot;&gt;&lt;a href=&quot;#Python内置函数&quot; class=&quot;headerlink&quot; title=&quot;Python内置函数&quot;&gt;&lt;/a&gt;Python内置函数&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://docs.python.org/3/libr
    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Python/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Python/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>01_Python基础</title>
    <link href="http://yoursite.com/2017/07/16/Backend/Python/Base/01_Python%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2017/07/16/Backend/Python/Base/01_Python基础/</id>
    <published>2017-07-16T07:23:07.000Z</published>
    <updated>2017-07-16T07:23:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python介绍"><a href="#Python介绍" class="headerlink" title="Python介绍"></a>Python介绍</h1><ul>
<li><p>Python适合的领域<br>Web网站和各种网络服务<br>系统工具和脚本<br>作为“胶水”语言把其它语言开发和模块包装起来方便使用  </p>
</li>
<li><p>Python不适合的领域<br>贴近硬件的代码（首选C）<br>移动开发：iOS/Android有各自的开发语言（ObjC,Swift/Java）<br>游戏开发：C/C++</p>
</li>
<li><p>Python和其它语言对比<br>|      |   类型   |   运行速度   |   代码量   |<br>| —- | —- | —- | —- |<br>|   C   |   编译为机器码   |   非常快   |   非常多   |<br>|   Java   |   编译为字节码   |   快   |   多   |<br>|   Python   |   解释执行       |   慢   |   少   |</p>
</li>
</ul>
<ul>
<li>Python源码不能加密  </li>
</ul>
<h1 id="Python文件类型"><a href="#Python文件类型" class="headerlink" title="Python文件类型"></a>Python文件类型</h1><p>Hello.py -&gt; python解释器 -&gt; 字节码文件 -&gt; python解释器 -&gt; 二进制文件 -&gt; 内存、运行 -&gt; 打印结果  </p>
<p>字节码文件：<br>.pyc<br>.pyo  </p>
<p>python -V  </p>
<p>生成pyc文件<br>python -m py_compile hello.py  </p>
<p>python hello.pyc  </p>
<p>生成pyo文件<br>python -o -m py_compile hello.py  </p>
<p>python hello.pyo  </p>
<p>ord(‘A’)<br>65  </p>
<p>chr(66)<br>‘B’  </p>
<p>‘ABC’.encode(‘ascii’)<br>b’ABC’  </p>
<p> b’ABC’.decode(‘ascii’)<br>‘ABC’  </p>
<p>len(‘ABC’)  </p>
<p>float(String)<br>int(String)<br>str(integer)<br>str(float)  </p>
<p>type(var)  </p>
<p><code># -*- coding: utf-8 -*-</code>  </p>
<h1 id="str"><a href="#str" class="headerlink" title="str"></a>str</h1><p>想要分几行输入字符串，并且希望行尾的换行符自动包含到字符串当中，可以使用三对引号：”””…””” 或 ‘’’…’’’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print(&quot;&quot;&quot;\</div><div class="line">... Usage: thingy [OPTIONS]</div><div class="line">...      -h                        Display this usage message</div><div class="line">...      -H hostname               Hostname to connect to</div><div class="line">... &quot;&quot;&quot;)</div><div class="line">Usage: thingy [OPTIONS]</div><div class="line">     -h                        Display this usage message</div><div class="line">     -H hostname               Hostname to connect to</div></pre></td></tr></table></figure></p>
<p>方法 title() 返回字符串的标题版本，即单词首字母大写其余字母小写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;shi yan lou&quot;</div><div class="line">&gt;&gt;&gt; s.title()</div><div class="line">&apos;Shi Yan Lou&apos;</div></pre></td></tr></table></figure></p>
<p>方法 upper() 返回字符串全部大写的版本，反之 lower() 返回字符串的全部小写版本。<br>方法 swapcase() 返回字符串大小写交换后的版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;I am A pRoGraMMer&quot;</div><div class="line">&gt;&gt; s.swapcase()</div><div class="line">&apos;i AM a PrOgRAmmER&apos;</div></pre></td></tr></table></figure></p>
<p>方法 isalnum() 检查所有字符是否为字母数字，字符串 s 中包含空格字符，所以返回 False。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;jdwb 2323bjb&quot;</div><div class="line">&gt;&gt;&gt; s.isalnum()</div><div class="line">False</div><div class="line">&gt;&gt;&gt; s = &quot;jdwb2323bjb&quot;</div><div class="line">&gt;&gt;&gt; s.isalnum()</div><div class="line">True</div></pre></td></tr></table></figure></p>
<p>方法 isalpha() 检查字符串之中是否只有字母。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;SankarshanSir&quot;</div><div class="line">&gt;&gt;&gt; s.isalpha()</div><div class="line">True</div><div class="line">&gt;&gt;&gt; s = &quot;Sankarshan Sir&quot;</div><div class="line">&gt;&gt;&gt; s.isalpha()</div><div class="line">False</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;1234&quot;</div><div class="line">&gt;&gt;&gt; s.isdigit() # 检查字符串是否所有字符为数字</div><div class="line">True</div><div class="line">&gt;&gt;&gt; s = &quot;ShiYanLou is coming&quot;</div><div class="line">&gt;&gt;&gt; s.islower() # 检查字符串是否所有字符为小写</div><div class="line">False</div><div class="line">&gt;&gt;&gt; s = &quot;Shiyanlou Is Coming&quot;</div><div class="line">&gt;&gt;&gt; s.istitle() # To 检查字符串是否为标题样式</div><div class="line">True</div><div class="line">&gt;&gt;&gt; s = &quot;CHINA&quot;</div><div class="line">&gt;&gt;&gt; s.isupper() # 检查字符串是否所有字符为大写</div><div class="line">True</div></pre></td></tr></table></figure>
<p>使用 split() 分割任意字符串，split() 允许有一个参数，用来指定字符串以什么字符分隔（默认为 “ “），它返回一个包含所有分割后的字符串的列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;We all love Python&quot;</div><div class="line">&gt;&gt;&gt; s.split()</div><div class="line">[&apos;We&apos;, &apos;all&apos;, &apos;love&apos;, &apos;Python&apos;]</div><div class="line">&gt;&gt;&gt; x = &quot;shiyanlou:is:waiting&quot;</div><div class="line">&gt;&gt;&gt; x.split(&apos;:&apos;)</div><div class="line">[&apos;shiyanlou&apos;, &apos;is&apos;, &apos;waiting&apos;]</div></pre></td></tr></table></figure></p>
<p>方法 join() 使用指定字符连接多个字符串，它需要一个包含字符串元素的列表作为输入然后连接列表内的字符串元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; &quot;-&quot;.join(&quot;GNU/Linux is great&quot;.split())</div><div class="line">&apos;GNU/Linux-is-great&apos;</div></pre></td></tr></table></figure></p>
<p>strip(chars)，用来剥离字符串首尾中指定的字符，它允许有一个字符串参数，这个参数为剥离哪些字符提供依据。不指定参数则默认剥离掉首尾的空格和换行符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;  a bc\n &quot;</div><div class="line">&gt;&gt;&gt; s.strip()</div><div class="line">&apos;a bc&apos;</div></pre></td></tr></table></figure></p>
<p>使用 lstrip(chars) 或 rstrip(chars) 只对字符串左或右剥离。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;www.foss.in&quot; </div><div class="line">&gt;&gt;&gt; s.lstrip(&quot;cwsd.&quot;) #删除在字符串左边出现的&apos;c&apos;,&apos;w&apos;,&apos;s&apos;,&apos;d&apos;,&apos;.&apos;字符</div><div class="line">&apos;foss.in&apos;</div><div class="line">&gt;&gt;&gt; s.rstrip(&quot;cnwdi.&quot;) #删除在字符串右边出现的&apos;c&apos;,&apos;n&apos;,&apos;w&apos;,&apos;d&apos;,&apos;i&apos;,&apos;.&apos;字符</div><div class="line">&apos;www.foss&apos;</div></pre></td></tr></table></figure></p>
<p>文本搜索<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;faulty for a reason&quot;</div><div class="line">&gt;&gt;&gt; s.find(&quot;for&quot;)</div><div class="line">7</div><div class="line">&gt;&gt;&gt; s.find(&quot;fora&quot;)</div><div class="line">-1</div><div class="line">&gt;&gt;&gt; s.startswith(&quot;fa&quot;) # 检查字符串是否以 fa 开头</div><div class="line">True</div><div class="line">&gt;&gt;&gt; s.endswith(&quot;reason&quot;) # 检查字符串是否以 reason 结尾</div><div class="line">True</div></pre></td></tr></table></figure></p>
<p>回文是一种无论从左还是从右读都一样的字符序列。比如 “madam”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python3</div><div class="line">s = input(&quot;Please enter a string: &quot;)</div><div class="line">z = s[::-1]</div><div class="line">if s == z:</div><div class="line">    print(&quot;The string is a palindrome&quot;)</div><div class="line">else:</div><div class="line">    print(&quot;The string is not a palindrome&quot;)</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python3</div><div class="line">s = input(&quot;Enter a line: &quot;)</div><div class="line">print(&quot;The number of words in the line are %d&quot; % (len(s.split(&quot; &quot;))))</div></pre></td></tr></table></figure>
<p>%d    整数<br>%f    浮点数<br>%s    字符串<br>%x    十六进制整数  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; &apos;Hello, %s&apos; % &apos;world&apos;</div><div class="line">&apos;Hello, world&apos;</div><div class="line">&gt;&gt;&gt; &apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000)</div><div class="line">&apos;Hi, Michael, you have $1000000.&apos;</div><div class="line"></div><div class="line">&gt;&gt;&gt; &apos;%2d-%02d&apos; % (3, 1)</div><div class="line">&apos; 3-01&apos;</div><div class="line">&gt;&gt;&gt; &apos;%.2f&apos; % 3.1415926</div><div class="line">&apos;3.14&apos;</div><div class="line"></div><div class="line">&gt;&gt;&gt; &apos;Age: %s. Gender: %s&apos; % (25, True)</div><div class="line">&apos;Age: 25. Gender: True&apos;</div><div class="line"></div><div class="line">&gt;&gt;&gt; &apos;growth rate: %d %%&apos; % 7</div><div class="line">&apos;growth rate: 7 %&apos;</div></pre></td></tr></table></figure>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; classmates = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</div><div class="line">&gt;&gt;&gt; classmates</div><div class="line">[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</div><div class="line"></div><div class="line">&gt;&gt;&gt; classmates[0]</div><div class="line">&apos;Michael&apos;</div><div class="line">&gt;&gt;&gt; classmates[1]</div><div class="line">&apos;Bob&apos;</div></pre></td></tr></table></figure>
<p>len(list)  </p>
<p>list.append(‘ABC’)</p>
<p>list.insert(0, 111)<br>在列表索引 0 位置添加元素 111  </p>
<p>list.pop()<br>list.pop(i)  </p>
<p>list.count(‘ABC’)<br>列表方法 count(s) 会返回列表元素中 s 的数量。  </p>
<p>list.remove(‘ABC’)<br>在列表中移除任意指定值  </p>
<p>del a[-1]<br>也能使用 del 关键字删除指定位置的列表元素。</p>
<p>list.reverse()<br>反转整个列表  </p>
<p>b=[45, 56, 90]<br>list.extend(b)<br>将一个列表的所有元素添加到另一个列表的末尾  </p>
<p>a.sort()<br>给列表排序，排序的前提是列表的元素是可比较的  </p>
<p>squares = list(map(lambda x: x<strong>2, range(10)))<br>等价于下面的列表推导式。<br>squares = [x</strong>2 for x in range(10)]  </p>
<p>列表推导式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]</div><div class="line">[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]</div></pre></td></tr></table></figure></p>
<h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>元组是由数个逗号分割的值组成。  </p>
<p>tuple一旦初始化就不能修改  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; classmates = (&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;)</div><div class="line">&gt;&gt;&gt; t = (1, 2)</div><div class="line">&gt;&gt;&gt; t</div><div class="line">(1, 2)</div></pre></td></tr></table></figure>
<p>定义一个空的tuple<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; t = ()</div><div class="line">&gt;&gt;&gt; t</div><div class="line">()</div></pre></td></tr></table></figure></p>
<p>定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。</p>
<p>所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; t = (1,)</div><div class="line">&gt;&gt;&gt; t</div><div class="line">(1,)</div><div class="line">```</div></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>t = (‘a’, ‘b’, [‘A’, ‘B’])<br>t[2][0] = ‘X’<br>t[2][1] = ‘Y’<br>t<br>(‘a’, ‘b’, [‘X’, ‘Y’])<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## if</div></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
</blockquote>
<p>if &lt;条件判断1&gt;:<br>    &lt;执行1&gt;<br>elif &lt;条件判断2&gt;:<br>    &lt;执行2&gt;<br>elif &lt;条件判断3&gt;:<br>    &lt;执行3&gt;<br>else:<br>    &lt;执行4&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">int(str) 字符串转数字  </div><div class="line"></div><div class="line">replace</div></pre></td></tr></table></figure></p>
<blockquote>
<blockquote>
<blockquote>
<p>a = ‘abc’<br>b = a.replace(‘a’, ‘A’)<br>b<br>‘Abc’<br>a<br>‘abc’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## for</div></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
</blockquote>
<p>names = [‘Michael’, ‘Bob’, ‘Tracy’]<br>for name in names:<br>    print(name)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">range()函数，可以生成一个整数序列，再通过list()函数可以转换为list</div></pre></td></tr></table></figure></p>
<blockquote>
<blockquote>
<blockquote>
<p>list(range(5))<br>[0, 1, 2, 3, 4]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## while</div></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
</blockquote>
<p>sum = 0<br>n = 99<br>while n &gt; 0:<br>    sum = sum + n<br>    n = n - 2<br>print(sum)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">break  </div><div class="line"></div><div class="line">continue  </div><div class="line"></div><div class="line"></div><div class="line">## dict</div><div class="line">无序的键值对（key:value）集合，同一个字典内的键必须是互不相同的。  </div><div class="line"></div><div class="line">一对大括号 &#123;&#125; 创建一个空字典。</div></pre></td></tr></table></figure></p>
<blockquote>
<blockquote>
<blockquote>
<p>d = {‘Michael’: 95, ‘Bob’: 75, ‘Tracy’: 85}<br>d[‘Michael’]<br>95<br>d[‘test’]=’50’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">dict() 可以从包含键值对的元组中创建字典。</div></pre></td></tr></table></figure></p>
<p>dict(((‘Indian’,’Delhi’),(‘Bangladesh’,’Dhaka’)))<br>{‘Indian’: ‘Delhi’, ‘Bangladesh’: ‘Dhaka’}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">如果你想要遍历一个字典，使用字典的 items() 方法。</div></pre></td></tr></table></figure></p>
<p>data = {‘kushal’:’Fedora’, ‘kart<em>‘:’Debian’, ‘Jace’:’Mac’}<br>for x, y in data.items():<br>…     print(“{} uses {}”.format(x, y))<br>…<br>Kushal uses Fedora<br>Jace uses Mac<br>kart</em> uses Debian<br>parthan uses Ubuntu<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">如果key不存在，dict就会报错：</div><div class="line"></div><div class="line"></div><div class="line">要避免key不存在的错误，有两种办法：</div><div class="line"></div><div class="line">一是通过in判断key是否存在：</div><div class="line">in</div></pre></td></tr></table></figure></p>
<p>‘Thomas’ in d<br>False<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">二是通过dict提供的get方法，如果key不存在，可以返回None，或者自己指定的value：</div><div class="line">get</div></pre></td></tr></table></figure></p>
<p>d.get(‘Thomas’)<br>d.get(‘Thomas’, -1)<br>-1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">pop</div></pre></td></tr></table></figure></p>
<p>d.pop(‘Bob’)<br>75<br>d<br>{‘Michael’: 95, ‘Tracy’: 85}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">使用 del 关键字删除任意指定的键值对：</div></pre></td></tr></table></figure></p>
<p>del d[‘test’]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">必须知道的是，字典中的键必须是不可变类型，比如你不能使用列表作为键。  </div><div class="line"></div><div class="line">dict.setdefault(key, default)  </div><div class="line">往字典中的元素添加数据，我们首先要判断这个元素是否存在，不存在则创建一个默认值。</div></pre></td></tr></table></figure></p>
<p>data = {}<br>data.setdefault(‘names’, []).append(‘Ruby’)<br>data<br>{‘names’: [‘Ruby’]}<br>data.setdefault(‘names’, []).append(‘Python’)<br>data<br>{‘names’: [‘Ruby’, ‘Python’]}<br>data.setdefault(‘names’, []).append(‘C’)<br>data<br>{‘names’: [‘Ruby’, ‘Python’, ‘C’]}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">试图索引一个不存在的键将会抛出一个 keyError 错误。我们可以使用 dict.get(key, default) 来索引键，如果键不存在，那么返回指定的 default 值。</div></pre></td></tr></table></figure></p>
<p>data[‘foo’]<br>Traceback (most recent call last):<br>File “<stdin>“, line 1, in <module><br>KeyError: ‘foo’<br>data.get(‘foo’, 0)<br>0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在遍历列表（或任何序列类型）的同时获得元素索引值，你可以使用 enumerate()。</div></pre></td></tr></table></figure></module></stdin></p>
<p>for i, j in enumerate([‘a’, ‘b’, ‘c’]):<br>…     print(i, j)<br>…<br>0 a<br>1 b<br>2 c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">同时遍历两个序列类型，可以使用 zip() 函数。</div></pre></td></tr></table></figure></p>
<p>a = [‘Pradeepto’, ‘Kushal’]<br>b = [‘OpenSUSE’, ‘Fedora’]<br>for x, y in zip(a, b):<br>…     print(“{} uses {}”.format(x, y))<br>…<br>Pradeepto uses OpenSUSE<br>Kushal uses Fedora<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## set</div><div class="line">set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。  </div><div class="line"></div><div class="line">大括号或 set() 函数可以用来创建集合。注意：想要创建空集合，你必须使用 set() 而不是 &#123;&#125;。  </div><div class="line">  </div><div class="line">要创建一个set，需要提供一个list作为输入集合：</div></pre></td></tr></table></figure></p>
<p>s = set([1, 1, 2, 2, 3, 3])<br>s<br>{1, 2, 3}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">add</div></pre></td></tr></table></figure></p>
<p>s.add(4)<br>s<br>{1, 2, 3, 4}<br>s.add(4)<br>s<br>{1, 2, 3, 4}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">pop</div></pre></td></tr></table></figure></p>
<p>s.pop()<br>1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">remove</div></pre></td></tr></table></figure></p>
<p>s.remove(4)<br>s<br>{1, 2, 3}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">&amp;   |</div></pre></td></tr></table></figure></p>
<p>s1 = set([1, 2, 3])<br>s2 = set([2, 3, 4])<br>s1 &amp; s2<br>{2, 3}<br>s1 | s2<br>{1, 2, 3, 4}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">演示对两个单词中的字母进行集合操作</div></pre></td></tr></table></figure></p>
<p>a = set(‘abracadabra’)<br>b = set(‘alacazam’)<br>a                                  # a 去重后的字母<br>{‘a’, ‘r’, ‘b’, ‘c’, ‘d’}<br>a - b                              # a 有而 b 没有的字母<br>{‘r’, ‘d’, ‘b’}<br>a | b                              # 存在于 a 或 b 的字母<br>{‘a’, ‘c’, ‘r’, ‘d’, ‘b’, ‘m’, ‘z’, ‘l’}<br>a &amp; b                              # a 和 b 都有的字母<br>{‘a’, ‘c’}<br>a ^ b                              # 存在于 a 或 b 但不同时存在的字母<br>{‘r’, ‘d’, ‘b’, ‘m’, ‘z’, ‘l’}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">in</div></pre></td></tr></table></figure></p>
<p>basket = {‘apple’, ‘orange’, ‘apple’, ‘pear’, ‘orange’, ‘banana’}<br>print(basket)                      # 你可以看到重复的元素被去除<br>{‘orange’, ‘banana’, ‘pear’, ‘apple’}<br>‘orange’ in basket<br>True<br>‘crabgrass’ in basket<br>False<br>```</p>
</blockquote>
</blockquote>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python介绍&quot;&gt;&lt;a href=&quot;#Python介绍&quot; class=&quot;headerlink&quot; title=&quot;Python介绍&quot;&gt;&lt;/a&gt;Python介绍&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Python适合的领域&lt;br&gt;Web网站和各种网络服务&lt;br&gt;系统工具和脚
    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Python/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Python/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>10_Linux 数据流重定向</title>
    <link href="http://yoursite.com/2017/07/07/Linux/Base/10_%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>http://yoursite.com/2017/07/07/Linux/Base/10_数据流重定向/</id>
    <published>2017-07-07T12:59:47.000Z</published>
    <updated>2017-07-07T12:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据流重定向"><a href="#数据流重定向" class="headerlink" title="数据流重定向"></a>数据流重定向</h1><p>Linux 默认提供了三个特殊设备，用于终端的显示和输出，分别为stdin（标准输入,对应于你在终端的输入），stdout（标准输出，对应于终端的输出），stderr（标准错误输出，对应于终端的输出）。  </p>
<p>Linux 默认提供了三个特殊设备，用于终端的显示和输出，分别为stdin（标准输入,对应于你在终端的输入），stdout（标准输出，对应于终端的输出），stderr（标准错误输出，对应于终端的输出）。  </p>
<table>
<thead>
<tr>
<th>文件描述符</th>
<th>设备文件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>/dev/stdin</td>
<td>标准输入</td>
</tr>
<tr>
<td>1</td>
<td>/dev/stdout</td>
<td>标准输出</td>
</tr>
<tr>
<td>2</td>
<td>/dev/stderr</td>
<td>标准错误</td>
</tr>
</tbody>
</table>
<blockquote>
<p>文件描述符：文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。  </p>
</blockquote>
<p>另外还有一个符号-,它可以同时作为前一个命令的。  </p>
<p>我们可以这样使用这些文件描述符：  </p>
<p>默认使用终端的标准输入作为命令的输入和标准输出作为命令的输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cat </div><div class="line">（按Ctrl+C退出）\</div></pre></td></tr></table></figure></p>
<p>将cat的连续输出（heredoc方式）重定向到一个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ mkdir Documents</div><div class="line">$ cat &gt; Documents/test.c &lt;&lt;EOF</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    printf(&quot;hello world\n&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<p>将一个文件作为命令的输入，标准输出作为命令的输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat Documents/test.c</div></pre></td></tr></table></figure></p>
<p>将echo命令通过管道传过来的数据作为cat命令的输入，将标准输出作为命令的输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ echo &apos;hi&apos; | cat</div></pre></td></tr></table></figure></p>
<p>将echo命令的输出从默认的标准输出重定向到一个普通文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ echo &apos;hello shiyanlou&apos; &gt; redirect</div><div class="line">$ cat redirect</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/qvu4wha.png" alt="">  </p>
<p>不要将管道和重定向混淆，管道默认是连接前一个命令的输出到下一个命令的输入，而重定向通常是需要一个文件来建立两个命令的连接，你可以仔细体会一下上述第三个操作和最后两个操作的异同点。  </p>
<h1 id="标准错误重定向"><a href="#标准错误重定向" class="headerlink" title="标准错误重定向"></a>标准错误重定向</h1><p>重定向标准输出到文件，这是一个很实用的操作，另一个很实用的操作是将标准错误重定向，标准输出和标准错误都被指向伪终端的屏幕显示，所以我们经常看到的一个命令的输出通常是同时包含了标准输出和标准错误的结果的。比如下面的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 使用cat 命令同时读取两个文件，其中一个存在，另一个不存在</div><div class="line">$ cat Documents/test.c hello.c</div><div class="line"># 你可以看到除了正确输出了前一个文件的内容，还在末尾出现了一条错误信息</div><div class="line"># 下面我们将输出重定向到一个文件，根据我们前面的经验，这里将在看不到任何输出了</div><div class="line">$ cat Documents/test.c hello.c &gt; somefile</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/fwOu6Ag.png" alt="">  </p>
<p>标准输出和标准错误虽然都指向终端屏幕，实际它们并不一样。  </p>
<p>隐藏某些错误或者警告<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 将标准错误重定向到标准输出，再将标准输出重定向到文件，注意要将重定向到文件写到前面</div><div class="line">$ cat Documents/test.c hello.c &gt;somefile  2&gt;&amp;1</div><div class="line"># 或者只用bash提供的特殊的重定向符号&quot;&amp;&quot;将标准错误和标准输出同时重定向到文件</div><div class="line">$ cat Documents/test.c hello.c &amp;&gt;somefilehell</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意你应该在输出重定向文件描述符前加上&amp;,否则shell会当做重定向到一个文件名为1的文件中</p>
</blockquote>
<p><img src="http://i.imgur.com/DgADysY.png" alt="">  </p>
<h1 id="使用tee命令同时重定向到多个文件"><a href="#使用tee命令同时重定向到多个文件" class="headerlink" title="使用tee命令同时重定向到多个文件"></a>使用tee命令同时重定向到多个文件</h1><p>经常可能还有这样的需求，除了将需要将输出重定向到文件之外也需要将信息打印在终端，那么你可以使用tee命令来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ echo &apos;hello shiyanlou&apos; | tee hello</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/nZsrUeT.png" alt="">  </p>
<h1 id="永久重定向"><a href="#永久重定向" class="headerlink" title="永久重定向"></a>永久重定向</h1><p>前面的重定向操作都只是临时性的，即只对当前命令有效，如何做到“永久”有效呢，比如在一个脚本中，你需要某一部分的命令的输出全部进行重定向，难道要在每个命令上面加上临时重定向的操作嘛，当然不需要，可以使用exec命令实现“永久”重定向。exec命令的作用是使用指定的命令替换当前的 Shell，及使用一个进程替换当前进程，或者指定新的重定向：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 先开启一个子 Shell</div><div class="line">$ zsh</div><div class="line"># 使用exec替换当前进程的重定向，将标准输出重定向到一个文件</div><div class="line">$ exec 1&gt;somefile</div><div class="line"># 后面你执行的命令的输出都将被重定向到文件中,直到你退出当前子shell，或取消exec的重定向（后面将告诉你怎么做）</div><div class="line">$ ls</div><div class="line">$ exit</div><div class="line">$ cat somefile</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/44lTnGF.png" alt="">  </p>
<h1 id="创建输出文件描述符"><a href="#创建输出文件描述符" class="headerlink" title="创建输出文件描述符"></a>创建输出文件描述符</h1><p>默认在 Shell 中可以有9个打开的文件描述符，上面使用了也是它默认提供的0,1,2号文件描述符，另外还可以使用3-8的文件描述符，只是它们默认没有打开而已，可以使用下面命令查看当前 Shell 进程中打开的文件描述符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cd /dev/fd/;ls -Al</div></pre></td></tr></table></figure></p>
<p>同样使用exec命令可以创建新的文件描述符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ zsh</div><div class="line">$ exec 3&gt;somefile</div><div class="line"># 先进入目录，再查看，否则你可能不能得到正确的结果，然后再回到上一次的目录</div><div class="line">$ cd /dev/fd/;ls -Al;cd -</div><div class="line"># 注意下面的命令&gt;与&amp;之间不应该有空格，如果有空格则会出错</div><div class="line">$ echo &quot;this is test&quot; &gt;&amp;3</div><div class="line">$ cat somefile</div><div class="line">$ exit</div></pre></td></tr></table></figure></p>
<h1 id="关闭文件描述符"><a href="#关闭文件描述符" class="headerlink" title="关闭文件描述符"></a>关闭文件描述符</h1><p>如上面打开的3号文件描述符，可以使用如下操作将它关闭：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ exec 3&gt;&amp;-</div><div class="line">$ cd /dev/fd;ls -Al;cd -</div></pre></td></tr></table></figure></p>
<h1 id="完全屏蔽命令的输出"><a href="#完全屏蔽命令的输出" class="headerlink" title="完全屏蔽命令的输出"></a>完全屏蔽命令的输出</h1><p>在 Linux 中有一个被称为“黑洞”的设备文件,所以导入它的数据都将被“吞噬”。</p>
<p>在类 UNIX 系统中，/dev/null，或称空设备，是一个特殊的设备文件，它通常被用于丢弃不需要的输出流，或作为用于输入流的空文件，这些操作通常由重定向完成。读取它则会立即得到一个EOF。<br>我们可以利用设个/dev/null屏蔽命令的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat Documents/test.c nefile 1&gt;/dev/null 2&gt;&amp;1</div></pre></td></tr></table></figure></p>
<p>上面这样的操作将使你得不到任何输出结果。</p>
<h1 id="使用-xargs-分割参数列表"><a href="#使用-xargs-分割参数列表" class="headerlink" title="使用 xargs 分割参数列表"></a>使用 xargs 分割参数列表</h1><p>xargs 是一条 UNIX 和类 UNIX 操作系统的常用命令。它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。<br>这个命令在有些时候十分有用，特别是当用来处理产生大量输出结果的命令如 find，locate 和 grep 的结果，详细用法请参看 man 文档。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cut -d: -f1 &lt; /etc/passwd | sort | xargs echo</div></pre></td></tr></table></figure></p>
<p>上面这个命令用于将/etc/passwd文件按:分割取第一个字段排序后，使用echo命令生成一个列表。</p>
<h1 id="使用文本处理"><a href="#使用文本处理" class="headerlink" title="使用文本处理"></a>使用文本处理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat data1 | cut -c 8- | sort|uniq -dc|sort -rn -k1 |head -3 &gt; /home/shiyanlou/result</div></pre></td></tr></table></figure>
<p>解释:</p>
<ol>
<li><p>cut -c 8- 取出每行的第八个字符以后的所有字符</p>
</li>
<li><p>sort将文件/文本的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。</p>
</li>
<li><p>uniq -dc 只显示重复行，并在输出行前面加上每行在输入文件中出现的次数</p>
</li>
<li><p>sort -rn -k1 把3的结果反向按照数字进行排序 -k1是取第一个区间进行排序(第一个区间即是每行出现的次数)</p>
</li>
<li><p>head -3 把排序好的结果取前三个即为出现频率最高的三个</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据流重定向&quot;&gt;&lt;a href=&quot;#数据流重定向&quot; class=&quot;headerlink&quot; title=&quot;数据流重定向&quot;&gt;&lt;/a&gt;数据流重定向&lt;/h1&gt;&lt;p&gt;Linux 默认提供了三个特殊设备，用于终端的显示和输出，分别为stdin（标准输入,对应于你在终端的输入）
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Linux/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux基础" scheme="http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>04_Linux 文件打包与压缩</title>
    <link href="http://yoursite.com/2017/07/07/Linux/Base/04_%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8E%E5%8E%8B%E7%BC%A9(zip,rar,tar)/"/>
    <id>http://yoursite.com/2017/07/07/Linux/Base/04_文件打包与压缩(zip,rar,tar)/</id>
    <published>2017-07-07T12:59:47.000Z</published>
    <updated>2017-07-07T12:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件打包与压缩"><a href="#文件打包与压缩" class="headerlink" title="文件打包与压缩"></a>文件打包与压缩</h1><p>在 Windows 上最常见的不外乎这三种<code>*.zip，*.rar，*.7z</code>后缀的压缩文件，<br>而在 Linux 上面常见常用的除了以上三种外，还有<code>*.gz，*.xz，*.bz2，*.tar，*.tar.gz，*.tar.xz，*.tar.bz2</code>，简单介绍如下：</p>
<table>
<thead>
<tr>
<th>文件后缀名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*.zip</td>
<td>zip 程序打包压缩的文件</td>
</tr>
<tr>
<td>*.rar</td>
<td>rar 程序压缩的文件</td>
</tr>
<tr>
<td>*.7z</td>
<td>7zip 程序压缩的文件</td>
</tr>
<tr>
<td>*.tar</td>
<td>tar 程序打包，未压缩的文件</td>
</tr>
<tr>
<td>*.gz</td>
<td>gzip 程序（GNU zip）压缩的文件</td>
</tr>
<tr>
<td>*.xz</td>
<td>xz程序压缩的文件</td>
</tr>
<tr>
<td>*.bz2</td>
<td>bzip2 程序压缩的文件</td>
</tr>
<tr>
<td>*.tar.gz</td>
<td>tar 打包，gzip 程序压缩的文件</td>
</tr>
<tr>
<td>*.tar.xz</td>
<td>tar 打包，xz 程序压缩的文件</td>
</tr>
<tr>
<td>*tar.bz2</td>
<td>tar 打包，bzip2 程序压缩的文件</td>
</tr>
<tr>
<td>*.tar.7z</td>
<td>tar 打包，7z 程序压缩的文件</td>
</tr>
</tbody>
</table>
<h1 id="zip-压缩打包程序"><a href="#zip-压缩打包程序" class="headerlink" title="zip 压缩打包程序"></a>zip 压缩打包程序</h1><ul>
<li>使用 zip 打包文件夹：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ zip -r -q -o shiyanlou.zip /home/shiyanlou</div><div class="line">$ du -h shiyanlou.zip</div><div class="line">$ file shiyanlou.zip</div></pre></td></tr></table></figure>
</li>
</ul>
<p>第一行命令中，-r 参数表示递归打包包含子目录的全部内容，-q 参数表示为安静模式，即不向屏幕输出信息，-o，表示输出文件，需在其后紧跟打包输出文件名<br>后面使用 du 命令查看打包后文件的大小  </p>
<ul>
<li>设置压缩级别为 9 和 1（9 最大，1 最小），重新打包<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ zip -r -9 -q -o shiyanlou_9.zip /home/shiyanlou -x ~/*.zip</div><div class="line">$ zip -r -1 -q -o shiyanlou_1.zip /home/shiyanlou -x ~/*.zip</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这里添加了一个参数用于设置压缩级别 -[1-9]，1 表示最快压缩但体积大，9 表示体积最小但耗时最久。最后那个 -x 是为了排除我们上一次创建的 zip 文件，否则又会被打包进这一次的压缩文件中  </p>
<blockquote>
<p>注意：这里只能使用绝对路径，否则不起作用。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">du -h -d 0 *.zip ~ | sort</div></pre></td></tr></table></figure>
<p>通过 man 手册可知：  </p>
<ul>
<li>h， –human-readable  </li>
<li>d， –max-depth（所查看文件的深度）  </li>
</ul>
<ul>
<li>创建加密 zip 包<br>使用 -e 参数可以创建加密压缩包：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">zip -r -e -o shiyanlou_encryption.zip /home/shiyanlou</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>注意： 关于 zip 命令，因为 Windows 系统与 Linux/Unix 在文本文件格式上的一些兼容问题，比如换行符（为不可见字符），在 Windows 为 CR+LF（Carriage-Return+Line-Feed：回车加换行），而在 Linux/Unix 上为 LF（换行），所以如果在不加处理的情况下，<strong>在 Linux 上编辑的文本，在 Windows 系统上打开可能看起来是没有换行的</strong>。如果你想让你在 Linux 创建的 zip 压缩文件在 Windows 上解压后没有任何问题，那么你还需要对命令做一些修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">zip -r -l -o shiyanlou.zip /home/shiyanlou</div></pre></td></tr></table></figure></p>
</blockquote>
<p>需要加上 -l 参数将 LF 转换为 CR+LF 来达到以上目的。  </p>
<h1 id="使用-unzip-命令解压缩-zip-文件"><a href="#使用-unzip-命令解压缩-zip-文件" class="headerlink" title="使用 unzip 命令解压缩 zip 文件"></a>使用 unzip 命令解压缩 zip 文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unzip shiyanlou.zip</div></pre></td></tr></table></figure>
<p>使用安静模式，将文件解压到指定目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unzip -q shiyanlou.zip -d ziptest</div></pre></td></tr></table></figure></p>
<p>上述指定目录不存在，将会自动创建。如果你不想解压只想查看压缩包的内容你可以使用 -l 参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unzip -l shiyanlou.zip</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意： 使用 unzip 解压文件时我们同样应该注意兼容问题，不过这里我们关心的不再是上面的问题，而是中文编码的问题，通常 Windows 系统上面创建的压缩文件，如果有有包含中文的文档或以中文作为文件名的文件时默认会采用 GBK 或其它编码，而 Linux 上面默认使用的是 UTF-8 编码，如果不加任何处理，直接解压的话可能会出现中文乱码的问题（有时候它会自动帮你处理），为了解决这个问题，我们可以在解压时指定编码类型。</p>
</blockquote>
<p>使用 -O（英文字母，大写 o）参数指定编码类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unzip -O GBK 中文压缩文件.zip</div></pre></td></tr></table></figure></p>
<h1 id="rar-打包压缩命令"><a href="#rar-打包压缩命令" class="headerlink" title="rar 打包压缩命令"></a>rar 打包压缩命令</h1><p>rar 也是 Windows 上常用的一种压缩文件格式，在 Linux 上可以使用 rar 和 unrar 工具分别创建和解压 rar 压缩包  </p>
<ul>
<li><p>安装 rar 和 unrar 工具：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get update</div><div class="line">$ sudo apt-get install rar unrar</div></pre></td></tr></table></figure>
</li>
<li><p>从指定文件或目录创建压缩包或添加文件到压缩包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ rm *.zip</div><div class="line">$ rar a shiyanlou.rar .</div></pre></td></tr></table></figure>
</li>
</ul>
<p>上面的命令使用 a 参数添加一个目录 ～ 到一个归档文件中，如果该文件不存在就会自动创建。  </p>
<blockquote>
<p>注意：rar 的命令参数没有 -，如果加上会报错。</p>
</blockquote>
<p>从指定压缩包文件中删除某个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rar d shiyanlou.rar .zshrc</div></pre></td></tr></table></figure></p>
<p>查看不解压文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rar l shiyanlou.rar</div></pre></td></tr></table></figure></p>
<p>使用 unrar 解压 rar 文件<br>全路径解压：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ unrar x shiyanlou.rar</div></pre></td></tr></table></figure></p>
<p>去掉路径解压：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mkdir tmp</div><div class="line">$ unrar e shiyanlou.rar tmp/</div></pre></td></tr></table></figure></p>
<p>rar 命令参数非常多，上面只涉及了一些基本操作。  </p>
<h1 id="tar-打包工具"><a href="#tar-打包工具" class="headerlink" title="tar 打包工具"></a>tar 打包工具</h1><p>在 Linux 上面更常用的是 tar 工具，tar 原本只是一个打包工具，只是同时还是实现了对 7z、gzip、xz、bzip2 等工具的支持，这些压缩工具本身只能实现对文件或目录（单独压缩目录中的文件）的压缩，没有实现对文件的打包压缩，所以我们也无需再单独去学习其他几个工具，tar 的解压和压缩都是同一个命令，只需参数不同，使用比较方便。  </p>
<p>先掌握 tar 命令一些基本的使用方式，即不进行压缩只是进行打包（创建归档文件）和解包的操作。</p>
<p>创建一个 tar 包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -cf shiyanlou.tar ~</div></pre></td></tr></table></figure></p>
<p>上面命令中，-c 表示创建一个 tar 包文件，-f 用于指定创建的文件名，注意文件名必须紧跟在 -f 参数之后，比如不能写成 tar -fc shiyanlou.tar，可以写成 tar -f shiyanlou.tar -c ~。你还可以加上 -v 参数以可视的的方式输出打包的文件。上面会自动去掉表示绝对路径的 /，你也可以使用 -P 保留绝对路径符  </p>
<ul>
<li><p>解包一个文件（-x 参数）到指定路径的<strong>已存在</strong>目录（-C 参数）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mkdir tardir</div><div class="line">$ tar -xf shiyanlou.tar -C tardir</div></pre></td></tr></table></figure>
</li>
<li><p>只查看不解包文件 -t 参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -tf shiyanlou.tar</div></pre></td></tr></table></figure>
</li>
<li><p>保留文件属性和跟随链接（符号链接或软链接），有时候我们使用 tar 备份文件当你在其他主机还原时希望保留文件的属性（-p 参数）和备份链接指向的源文件而不是链接本身（-h 参数）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -cphf etc.tar /etc</div></pre></td></tr></table></figure>
</li>
</ul>
<p>对于创建不同的压缩格式的文件，对于 tar 来说是相当简单的，需要的只是换一个参数，这里我们就以使用 gzip 工具创建 *.tar.gz 文件为例来说明。  </p>
<ul>
<li><p>我们只需要在创建 tar 文件的基础上添加 -z 参数，使用 gzip 来压缩文件：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -czf shiyanlou.tar.gz ~</div></pre></td></tr></table></figure>
</li>
<li><p>解压 *.tar.gz 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -xzf shiyanlou.tar.gz</div></pre></td></tr></table></figure>
</li>
</ul>
<p>现在我们要使用其它的压缩工具创建或解压相应文件只需要更改一个参数即可：  </p>
<table>
<thead>
<tr>
<th>压缩文件格式</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>*.tar.gz</td>
<td>-z</td>
</tr>
<tr>
<td>*.tar.xz</td>
<td>-J</td>
</tr>
<tr>
<td>*tar.bz2</td>
<td>-j</td>
</tr>
</tbody>
</table>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>常用命令：</p>
<ul>
<li><p>zip：<br>  打包 ：zip something.zip something （目录请加 -r 参数）<br>  解包：unzip something<br>  指定路径：-d 参数  </p>
</li>
<li><p>tar：<br>  打包：tar -zcvf something.tar something<br>  解包：tar -zxvf something.tar<br>  指定路径：-C 参数  </p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;文件打包与压缩&quot;&gt;&lt;a href=&quot;#文件打包与压缩&quot; class=&quot;headerlink&quot; title=&quot;文件打包与压缩&quot;&gt;&lt;/a&gt;文件打包与压缩&lt;/h1&gt;&lt;p&gt;在 Windows 上最常见的不外乎这三种&lt;code&gt;*.zip，*.rar，*.7z&lt;/code&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Linux/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux基础" scheme="http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>14_Linux 进程的查看</title>
    <link href="http://yoursite.com/2017/07/07/Linux/Base/14_Linux%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86(top,ps,pstree)/"/>
    <id>http://yoursite.com/2017/07/07/Linux/Base/14_Linux 进程管理(top,ps,pstree)/</id>
    <published>2017-07-07T12:59:47.000Z</published>
    <updated>2017-07-07T12:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程的查看"><a href="#进程的查看" class="headerlink" title="进程的查看"></a>进程的查看</h1><p>可以通过 top 实时得查看进程的状态，以及系统的一些信息（如 CPU、内存信息等），我们还可以通过 ps 来静态查看当前的进程信息，同时我们还可以使用 pstree 来查看当前活跃进程的树形结构。</p>
<h2 id="top-工具的使用"><a href="#top-工具的使用" class="headerlink" title="top 工具的使用"></a>top 工具的使用</h2><p>top 工具是我们常用的一个查看工具，能实时的查看我们系统的一些关键信息的变化:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">top</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/zUBIXpi.png" alt="">  </p>
<p>top 是一个在前台执行的程序，所以执行后便进入到这样的一个交互界面，正是因为交互界面我们才可以实时的获取到系统与进程的信息。在交互界面中我们可以通过一些指令来操作和筛选。在此之前我们先来了解显示了哪些信息。  </p>
<p>我们看到 top 显示的第一排，</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>top</td>
<td>表示当前程序的名称</td>
</tr>
<tr>
<td>11:05:18</td>
<td>表示当前的系统的时间</td>
</tr>
<tr>
<td>up 8 days,17:12</td>
<td>表示该机器已经启动了多长时间</td>
</tr>
<tr>
<td>1 user</td>
<td>表示当前系统中只有一个用户</td>
</tr>
<tr>
<td>load average: 0.29,0.20,0.25</td>
<td>分别对应1、5、15分钟内cpu的平均负载</td>
</tr>
</tbody>
</table>
<p>load average 在 wikipedia 中的解释是 the system load is a measure of the amount of work that a computer system is doing 也就是对当前 CPU 工作量的度量，具体来说也就是指运行队列的平均长度，也就是等待 CPU 的平均进程数相关的一个计算值。  </p>
<p>我们该如何看待这个load average 数据呢？  </p>
<p>假设我们的系统是单 CPU、单内核的，把它比喻成是一条单向的桥，把CPU任务比作汽车。  </p>
<ul>
<li>load = 0 的时候意味着这个桥上并没有车，cpu 没有任何任务；</li>
<li>load &lt; 1 的时候意味着桥上的车并不多，一切都还是很流畅的，cpu 的任务并不多，资源还很充足；</li>
<li>load = 1 的时候就意味着桥已经被车给沾满了，没有一点空隙，cpu 的已经在全力工作了，所有的资源都被用完了，当然还好，这还在能力范围之内，只是有点慢而已；</li>
<li>load &gt; 1 的时候就意味着不仅仅是桥上已经被车占满了，就连桥外都被占满了，cpu 已经在全力的工作了，系统资源的用完了，但是还是有大量的进程在请求，在等待。若是这个值大于２，大于３，超过 CPU 工作能力的 2，３。而若是这个值 &gt; 5 说明系统已经在超负荷运作了。【注释1】</li>
</ul>
<p>这是单个 CPU 单核的情况，而实际生活中我们需要将得到的这个值除以我们的核数来看。我们可以通过一下的命令来查看 CPU 的个数与核心数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#查看物理CPU的个数</div><div class="line">#cat /proc/cpuinfo |grep &quot;physical id&quot;|sort |uniq|wc -l</div><div class="line"></div><div class="line">#每个cpu的核心数</div><div class="line">cat /proc/cpuinfo |grep &quot;physical id&quot;|grep &quot;0&quot;|wc -l</div></pre></td></tr></table></figure></p>
<p>通过上面的指数我们可以得知 load 的临界值为 1 ，但是在实际生活中，比较有经验的运维或者系统管理员会将临界值定为0.7。这里的指数都是除以核心数以后的值，不要混淆了</p>
<ul>
<li>若是 load &lt; 0.7 并不会去关注他；</li>
<li>若是 0.7&lt; load &lt; 1 的时候我们就需要稍微关注一下了，虽然还可以应付但是这个值已经离临界不远了；</li>
<li>若是 load = 1 的时候我们就需要警惕了，因为这个时候已经没有更多的资源的了，已经在全力以赴了；</li>
<li>若是 load &gt; 5 的时候系统已经快不行了，这个时候你需要加班解决问题了</li>
</ul>
<p>通常我们都会先看 15 分钟的值来看这个大体的趋势，然后再看 5 分钟的值对比来看是否有下降的趋势。</p>
<p>查看 busybox 的代码可以知道，数据是每 5 秒钟就检查一次活跃的进程数，然后计算出该值，然后 load 从 /proc/loadavg 中读取的。而这个 load 的值是如何计算的呢，这是 load 的计算的源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#define FSHIFT      11          /* nr of bits of precision */</div><div class="line">#define FIXED_1     (1&lt;&lt;FSHIFT) /* 1.0 as fixed-point(定点) */</div><div class="line">#define LOAD_FREQ   (5*HZ)      /* 5 sec intervals，每隔5秒计算一次平均负载值 */</div><div class="line">#define CALC_LOAD(load, exp, n)     \</div><div class="line">         load *= exp;               \</div><div class="line">         load += n*(FIXED_1 - exp); \</div><div class="line">         load &gt;&gt;= FSHIFT;</div><div class="line"></div><div class="line">unsigned long avenrun[3];</div><div class="line"></div><div class="line">EXPORT_SYMBOL(avenrun);</div><div class="line"></div><div class="line">/*</div><div class="line">* calc_load - given tick count, update the avenrun load estimates.</div><div class="line">* This is called while holding a write_lock on xtime_lock.</div><div class="line">*/</div><div class="line">static inline void calc_load(unsigned long ticks)</div><div class="line">&#123;</div><div class="line">        unsigned long active_tasks; /* fixed-point */</div><div class="line">        static int count = LOAD_FREQ;</div><div class="line">        count -= ticks;</div><div class="line">        if (count &lt; 0) &#123;</div><div class="line">                count += LOAD_FREQ;</div><div class="line">                active_tasks = count_active_tasks();</div><div class="line">                CALC_LOAD(avenrun[0], EXP_1, active_tasks);</div><div class="line">                CALC_LOAD(avenrun[1], EXP_5, active_tasks);</div><div class="line">                CALC_LOAD(avenrun[2], EXP_15, active_tasks);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>来看 top 的第二行数据，基本上第二行是进程的一个情况统计</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tasks: 26 total</td>
<td>进程总数</td>
</tr>
<tr>
<td>1 running</td>
<td>1个正在运行的进程数</td>
</tr>
<tr>
<td>25 sleeping</td>
<td>25个睡眠的进程数</td>
</tr>
<tr>
<td>0 stopped</td>
<td>没有停止的进程数</td>
</tr>
<tr>
<td>0 zombie</td>
<td>没有僵尸进程数</td>
</tr>
</tbody>
</table>
<p>来看 top 的第三行数据，这一行基本上是 CPU 的一个使用情况的统计了</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cpu(s): 1.0%us</td>
<td>用户空间进程占用CPU百分比</td>
</tr>
<tr>
<td>1.0% sy</td>
<td>内核空间运行占用CPU百分比</td>
</tr>
<tr>
<td>0.0%ni</td>
<td>用户进程空间内改变过优先级的进程占用CPU百分比</td>
</tr>
<tr>
<td>97.9%id</td>
<td>空闲CPU百分比</td>
</tr>
<tr>
<td>0.0%wa</td>
<td>等待输入输出的CPU时间百分比</td>
</tr>
<tr>
<td>0.1%hi</td>
<td>硬中断(Hardware IRQ)占用CPU的百分比</td>
</tr>
<tr>
<td>0.0%si</td>
<td>软中断(Software IRQ)占用CPU的百分比</td>
</tr>
<tr>
<td>0.0%st</td>
<td>(Steal time) 是 hypervisor 等虚拟服务中，虚拟 CPU 等待实际 CPU 的时间的百分比</td>
</tr>
</tbody>
</table>
<p>CPU 利用率是对一个时间段内 CPU 使用状况的统计，通过这个指标可以看出在某一个时间段内 CPU 被占用的情况，而 Load Average 是 CPU 的 Load，它所包含的信息不是 CPU 的使用率状况，而是在一段时间内 CPU 正在处理以及等待 CPU 处理的进程数情况统计信息，这两个指标并不一样。  </p>
<p>来看 top 的第四行数据，这一行基本上是内存的一个使用情况的统计了：</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>8176740 total</td>
<td>物理内存总量</td>
</tr>
<tr>
<td>8032104 used</td>
<td>使用的物理内存总量</td>
</tr>
<tr>
<td>144636 free</td>
<td>空闲内存总量</td>
</tr>
<tr>
<td>313088 buffers</td>
<td>用作内核缓存的内存量</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意<br>系统的中可用的物理内存最大值并不是 free 这个单一的值，而是 free + buffers + swap 中的 cached 的和</p>
</blockquote>
<p>来看 top 的第五行数据，这一行基本上是交换区的一个使用情况的统计了</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>total</td>
<td>交换区总量</td>
</tr>
<tr>
<td>used</td>
<td>使用的交换区总量</td>
</tr>
<tr>
<td>free</td>
<td>空闲交换区总量</td>
</tr>
<tr>
<td>cached</td>
<td>缓冲的交换区总量,内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>在下面就是进程的一个情况了</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>PID</td>
<td>进程id</td>
</tr>
<tr>
<td>USER</td>
<td>该进程的所属用户</td>
</tr>
<tr>
<td>PR</td>
<td>该进程执行的优先级 priority 值</td>
</tr>
<tr>
<td>NI</td>
<td>该进程的 nice 值</td>
</tr>
<tr>
<td>VIRT</td>
<td>该进程任务所使用的虚拟内存的总数</td>
</tr>
<tr>
<td>RES</td>
<td>该进程所使用的物理内存数，也称之为驻留内存数</td>
</tr>
<tr>
<td>SHR</td>
<td>该进程共享内存的大小</td>
</tr>
<tr>
<td>S</td>
<td>该进程进程的状态: S=sleep R=running Z=zombie</td>
</tr>
<tr>
<td>%CPU</td>
<td>该进程CPU的利用率</td>
</tr>
<tr>
<td>%MEM</td>
<td>该进程内存的利用率</td>
</tr>
<tr>
<td>TIME+</td>
<td>该进程活跃的总时间</td>
</tr>
<tr>
<td>COMMAND</td>
<td>该进程运行的名字</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意</p>
<p>NICE 值叫做静态优先级，是用户空间的一个优先级值，其取值范围是-20至19。这个值越小，表示进程”优先级”越高，而值越大“优先级”越低。nice值中的 -20 到 19，中 -20 优先级最高， 0 是默认的值，而 19 优先级最低</p>
<p>PR 值表示 Priority 值叫动态优先级，是进程在内核中实际的优先级值，进程优先级的取值范围是通过一个宏定义的，这个宏的名称是 MAX_PRIO，它的值为 140。Linux 实际上实现了 140 个优先级范围，取值范围是从 0-139，这个值越小，优先级越高。而这其中的 0 - 99 是实时进程的值，而 100 - 139 是给用户的。</p>
<p>其中 PR 中的 100 to 139 值部分有这么一个对应 PR = 20 + (-20 to +19)，这里的 -20 to +19 便是nice值，所以说两个虽然都是优先级，而且有千丝万缕的关系，但是他们的值，他们的作用范围并不相同</p>
<p>VIRT 任务所使用的虚拟内存的总数，其中包含所有的代码，数据，共享库和被换出 swap空间的页面等所占据空间的总数</p>
</blockquote>
<p>在上文我们曾经说过 top 是一个前台程序，所以是一个可以交互的</p>
<table>
<thead>
<tr>
<th>常用交互命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>q</td>
<td>退出程序</td>
</tr>
<tr>
<td>I</td>
<td>切换显示平均负载和启动时间的信息</td>
</tr>
<tr>
<td>P</td>
<td>根据CPU使用百分比大小进行排序</td>
</tr>
<tr>
<td>M</td>
<td>根据驻留内存大小进行排序</td>
</tr>
<tr>
<td>i</td>
<td>忽略闲置和僵死的进程，这是一个开关式命令</td>
</tr>
<tr>
<td>k</td>
<td>终止一个进程，系统提示输入 PID 及发送的信号值。一般终止进程用 15 信号，不能正常结束则使用 9 信号。安全模式下该命令被屏蔽。</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h2 id="ps-工具的使用"><a href="#ps-工具的使用" class="headerlink" title="ps 工具的使用"></a>ps 工具的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps aux</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/uS7vjWp.png" alt="">  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps axjf</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/x9j1F7j.png" alt="">  </p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>F</td>
<td>进程的标志（process flags），当 flags 值为 1 则表示此子程序只是 fork 但没有执行 exec，为 4 表示此程序使用超级管理员 root 权限</td>
</tr>
<tr>
<td>USER</td>
<td>进程的拥有用户</td>
</tr>
<tr>
<td>PID</td>
<td>进程的 ID</td>
</tr>
<tr>
<td>PPID</td>
<td>其父进程的 PID</td>
</tr>
<tr>
<td>SID</td>
<td>session 的 ID</td>
</tr>
<tr>
<td>TPGID</td>
<td>前台进程组的 ID</td>
</tr>
<tr>
<td>%CPU</td>
<td>进程占用的 CPU 百分比</td>
</tr>
<tr>
<td>%MEM</td>
<td>占用内存的百分比</td>
</tr>
<tr>
<td>NI</td>
<td>进程的 NICE 值</td>
</tr>
<tr>
<td>VSZ</td>
<td>进程使用虚拟内存大小</td>
</tr>
<tr>
<td>RSS</td>
<td>驻留内存中页的大小</td>
</tr>
<tr>
<td>TTY</td>
<td>终端 ID</td>
</tr>
<tr>
<td>S or STAT</td>
<td>进程状态</td>
</tr>
<tr>
<td>WCHAN</td>
<td>正在等待的进程资源</td>
</tr>
<tr>
<td>START</td>
<td>启动进程的时间</td>
</tr>
<tr>
<td>TIME</td>
<td>进程消耗CPU的时间</td>
</tr>
<tr>
<td>COMMAND</td>
<td>命令的名称和参数　</td>
</tr>
</tbody>
</table>
<blockquote>
<p>TPGID栏写着-1的都是没有控制终端的进程，也就是守护进程</p>
</blockquote>
<p>STAT表示进程的状态，而进程的状态有很多，如下表所示</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>R</td>
<td>Running.运行中</td>
</tr>
<tr>
<td>S</td>
<td>Interruptible Sleep.等待调用</td>
</tr>
<tr>
<td>D</td>
<td>Uninterruptible Sleep.不可中断睡眠</td>
</tr>
<tr>
<td>T</td>
<td>Stoped.暂停或者跟踪状态</td>
</tr>
<tr>
<td>X</td>
<td>Dead.即将被撤销</td>
</tr>
<tr>
<td>Z</td>
<td>Zombie.僵尸进程</td>
</tr>
<tr>
<td>W</td>
<td>Paging.内存交换</td>
</tr>
<tr>
<td>N</td>
<td>优先级低的进程</td>
</tr>
<tr>
<td>&lt;</td>
<td>优先级高的进程</td>
</tr>
<tr>
<td>s</td>
<td>进程的领导者</td>
</tr>
<tr>
<td>L</td>
<td>锁定状态</td>
</tr>
<tr>
<td>l</td>
<td>多线程状态</td>
</tr>
<tr>
<td>+</td>
<td>前台进程</td>
</tr>
</tbody>
</table>
<blockquote>
<p>其中的 D 是不能被中断睡眠的状态，处在这种状态的进程不接受外来的任何 signal，所以无法使用 kill 命令杀掉处于D状态的进程，无论是 kill，kill -9 还是 kill -15，一般处于这种状态可能是进程 I/O 的时候出问题了。</p>
</blockquote>
<ul>
<li>使用 -l 参数可以显示自己这次登陆的 bash 相关的进程信息罗列出来<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -l</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://i.imgur.com/hxy6SN8.png" alt="">  </p>
<ul>
<li>罗列出所有的进程信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps aux</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://i.imgur.com/Ka02pI8.png" alt="">  </p>
<ul>
<li>若是查找其中的某个进程的话，还可以配合着 grep 和正则表达式一起使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps aux | grep zsh</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://i.imgur.com/nvI05AN.png" alt="">  </p>
<ul>
<li>查看时，将连同部分的进程呈树状显示出来<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps axjf</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://i.imgur.com/2KYIPZf.png" alt="">  </p>
<h2 id="pstree-工具的使用"><a href="#pstree-工具的使用" class="headerlink" title="pstree 工具的使用"></a>pstree 工具的使用</h2><p>通过 pstree 可以很直接的看到相同的进程数量，最主要的还是我们可以看到所有进程的之间的相关性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pstree</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/FhiQitW.png" alt="">  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">pstree -up</div><div class="line"></div><div class="line">#参数选择：</div><div class="line">#-A  ：各程序树之间以 ASCII 字元來連接；</div><div class="line">#-p  ：同时列出每个 process 的 PID；</div><div class="line">#-u  ：同时列出每个 process 的所屬账户名称。</div></pre></td></tr></table></figure>
<h1 id="进程的管理"><a href="#进程的管理" class="headerlink" title="进程的管理"></a>进程的管理</h1><h2 id="kill-命令的掌握"><a href="#kill-命令的掌握" class="headerlink" title="kill 命令的掌握"></a>kill 命令的掌握</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#首先我们使用图形界面打开了 gedit、gvim，用 ps 可以查看到</div><div class="line">ps aux</div><div class="line">  </div><div class="line">#使用9这个信号强制结束 gedit 进程</div><div class="line">kill -9 1608</div><div class="line">  </div><div class="line">#我们在查找这个进程的时候就找不到了</div><div class="line">ps aux | grep gedit</div></pre></td></tr></table></figure>
<h1 id="进程的执行顺序"><a href="#进程的执行顺序" class="headerlink" title="进程的执行顺序"></a>进程的执行顺序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#打开一个程序放在后台，或者用图形界面打开</div><div class="line">nice -n -5 vim &amp;</div><div class="line"></div><div class="line">#用 ps 查看其优先级</div><div class="line">ps -afxo user,ppid,pid,stat,pri,ni,time,command | grep vim</div></pre></td></tr></table></figure>
<p>还可以用 renice 来修改已经存在的进程的优先级，同样因为权限的原因在实验环境中无法尝试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">renice -5 pid</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;进程的查看&quot;&gt;&lt;a href=&quot;#进程的查看&quot; class=&quot;headerlink&quot; title=&quot;进程的查看&quot;&gt;&lt;/a&gt;进程的查看&lt;/h1&gt;&lt;p&gt;可以通过 top 实时得查看进程的状态，以及系统的一些信息（如 CPU、内存信息等），我们还可以通过 ps 来静态查
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Linux/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux基础" scheme="http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>15_Linux 日志系统</title>
    <link href="http://yoursite.com/2017/07/07/Linux/Base/15_Linux%20%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2017/07/07/Linux/Base/15_Linux 日志系统/</id>
    <published>2017-07-07T12:59:47.000Z</published>
    <updated>2017-07-07T12:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见的日志"><a href="#常见的日志" class="headerlink" title="常见的日志"></a>常见的日志</h1><p>在 Linux 中大部分的发行版都内置使用 syslog 系统日志，常见的日志一般存放在 /var/log 中，我们来看看其中有哪些日志</p>
<p><img src="http://i.imgur.com/8nYxtpg.png" alt="">  </p>
<p>根据服务对象粗略的将日志分为两类</p>
<ul>
<li>系统日志</li>
<li>应用日志</li>
</ul>
<p>系统日志主要是存放系统内置程序或系统内核之类的日志信息如 alternatives.log 、btmp 等等，应用日志主要是我们装的第三方应用所产生的日志如 tomcat7 、apache2 等等。  </p>
<p>常见的系统日志</p>
<table>
<thead>
<tr>
<th>日志名称</th>
<th>记录信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>alternatives.log</td>
<td>系统的一些更新替代信息记录</td>
</tr>
<tr>
<td>apport.log</td>
<td>应用程序崩溃信息记录</td>
</tr>
<tr>
<td>apt/history.log</td>
<td>使用 apt-get 安装卸载软件的信息记录</td>
</tr>
<tr>
<td>apt/term.log</td>
<td>使用 apt-get 时的具体操作，如 package 的下载、打开等</td>
</tr>
<tr>
<td>auth.log</td>
<td>登录认证的信息记录</td>
</tr>
<tr>
<td>boot.log</td>
<td>系统启动时的程序服务的日志信息</td>
</tr>
<tr>
<td>btmp</td>
<td>错误登陆的信息记录</td>
</tr>
<tr>
<td>Consolekit/history</td>
<td>控制台的信息记录</td>
</tr>
<tr>
<td>dist-upgrade</td>
<td>dist-upgrade这种更新方式的信息记录</td>
</tr>
<tr>
<td>dmesg</td>
<td>启动时，显示屏幕上内核缓冲信息,与硬件有关的信息</td>
</tr>
<tr>
<td>dpkg.log    dpkg</td>
<td>命令管理包的日志。</td>
</tr>
<tr>
<td>faillog</td>
<td>用户登录失败详细信息记录</td>
</tr>
<tr>
<td>fontconfig.log</td>
<td>与字体配置有关的信息记录</td>
</tr>
<tr>
<td>kern.log</td>
<td>内核产生的信息记录，在自己修改内核时有很大帮助</td>
</tr>
<tr>
<td>lastlog</td>
<td>用户的最近信息记录</td>
</tr>
<tr>
<td>wtmp</td>
<td>登录信息的记录。wtmp可以找出谁正在登陆进入系统，谁使用命令显示这个文件或信息等</td>
</tr>
<tr>
<td>syslog</td>
<td>系统信息记录</td>
</tr>
</tbody>
</table>
<p>来看 alternatives.log 中的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">update-alternatives 2016-07-02 13:36:16: run with --install /usr/bin/x-www-browser x-www-browser /usr/bin/google-chrome-stable 200</div><div class="line">update-alternatives 2016-07-02 13:36:16: run with --install /usr/bin/gnome-www-browser gnome-www-browser /usr/bin/google-chrome-stable 200</div><div class="line">update-alternatives 2016-07-02 13:36:16: run with --install /usr/bin/google-chrome google-chrome /usr/bin/google-chrome-stable 200</div></pre></td></tr></table></figure></p>
<p>从中得到信息有程序作用，日期，命令，成功与否的返回码</p>
<p>来看看 auth.log 中的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">less auth.log</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/hBaYC0S.png" alt="">  </p>
<p>从中得到的信息有日期与 ip 地址的来源以及登陆的用户与工具</p>
<p>在 apt 文件夹中的日志信息，其中有两个日志文件 history.log 与 term.log，两个日志文件的区别在于 history.log 主要记录了进行了那个操作，相关的依赖有哪些，而 term.log 则是较为具体的一些操作，主要就是下载包，打开包，安装包等等的细节操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">less /var/log/apt/history.log</div><div class="line">  </div><div class="line">less /var/log/apt/term.log</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/whmmuPD.png" alt="">  </p>
<h1 id="配置的日志"><a href="#配置的日志" class="headerlink" title="配置的日志"></a>配置的日志</h1><p>可以通过两种方式：  </p>
<ul>
<li>一种是由软件开发商自己来自定义日志格式然后指定输出日志位置；  </li>
<li>一种方式就是 Linux 提供的日志服务程序，而我们这里系统日志是通过 syslog 来实现，提供日志管理服务。  </li>
</ul>
<p>syslog 是一个系统日志记录程序，在早期的大部分 Linux 发行版都是内置 syslog，让其作为系统的默认日志收集工具，虽然时代的进步与发展，syslog 已经年老体衰跟不上时代的需求，所以他被 rsyslog 所代替了，较新的 Ubuntu、Fedora 等等都是默认使用 rsyslog 作为系统的日志收集工具  </p>
<p>rsyslog的全称是 rocket-fast system for log，它提供了高性能，高安全功能和模块化设计。rsyslog 能够接受从各种各样的来源，将其输入，输出的结果到不同的目的地。rsyslog 可以提供超过每秒一百万条消息给目标文件。  </p>
<p>这样能实时收集日志信息的程序是有其守护进程的，如 rsyslog 的守护进程便是 rsyslogd  </p>
<p>可以手动开启这项服务，然后来查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo service rsyslog start</div><div class="line">  </div><div class="line">ps aux | grep syslog</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/U8FBXoO.png" alt="">  </p>
<p>既然它是一个服务，那么它便是可以配置，为我们提供一些我们自定义的服务  </p>
<p>首先我们来看 rsyslog 的配置文件是什么样子的，而 rsyslog 的配置文件有两个，  </p>
<ul>
<li>一个是 /etc/rsyslog.conf</li>
<li>一个是 /etc/rsyslog.d/50-default.conf。</li>
</ul>
<p>第一个主要是配置的环境，也就是 rsyslog 的加载什么模块，文件的所属者等；而第二个主要是配置的 Filter Conditions<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vim /etc/rsyslog.conf </div><div class="line">  </div><div class="line">vim /etc/rsyslog.d/50-default.conf</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#首先将syslog启动起来</div><div class="line">sudo service rsyslog start</div><div class="line"></div><div class="line">#向 syslog 写入数据</div><div class="line">ping 127.0.0.1 | logger -it logger_test -p local3.notice &amp;</div><div class="line"></div><div class="line">#查看是否有数据写入</div><div class="line">tail -f /var/log/syslog</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常见的日志&quot;&gt;&lt;a href=&quot;#常见的日志&quot; class=&quot;headerlink&quot; title=&quot;常见的日志&quot;&gt;&lt;/a&gt;常见的日志&lt;/h1&gt;&lt;p&gt;在 Linux 中大部分的发行版都内置使用 syslog 系统日志，常见的日志一般存放在 /var/log 中，我们
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Linux/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux基础" scheme="http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>12_Linux 软件安装</title>
    <link href="http://yoursite.com/2017/07/07/Linux/Base/12_Linux%20%E4%B8%8B%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85(apt-get,dpkg)/"/>
    <id>http://yoursite.com/2017/07/07/Linux/Base/12_Linux 下软件安装(apt-get,dpkg)/</id>
    <published>2017-07-07T12:59:47.000Z</published>
    <updated>2017-07-07T12:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-下软件安装"><a href="#Linux-下软件安装" class="headerlink" title="Linux 下软件安装"></a>Linux 下软件安装</h1><p>通常 Linux 上的软件安装主要有四种方式：</p>
<ul>
<li>在线安装</li>
<li>从磁盘安装deb软件包</li>
<li>从二进制软件包安装</li>
<li>从源代码编译安装</li>
</ul>
<p>在不同的linux发行版上面在线安装方式会有一些差异包括使用的命令及它们的包管理工具  </p>
<h1 id="apt-包管理工具介绍"><a href="#apt-包管理工具介绍" class="headerlink" title="apt 包管理工具介绍"></a>apt 包管理工具介绍</h1><blockquote>
<p>APT是Advance Packaging Tool（高级包装工具）的缩写，是Debian及其派生发行版的软件包管理器，APT可以自动下载，配置，安装二进制或者源代码格式的软件包，因此简化了Unix系统上管理软件的过程。APT最早被设计成dpkg的前端，用来处理deb格式的软件包。现在经过APT-RPM组织修改，APT已经可以安装在支持RPM的系统管理RPM包。这个包管理器包含以 apt- 开头的的多个工具，如 apt-get apt-cache apt-cdrom 等，在Debian系列的发行版中使用。</p>
</blockquote>
<p>当你在执行安装操作时，首先apt-get 工具会在本地的一个数据库中搜索关于 w3m 软件的相关信息，并根据这些信息在相关的服务器上下载软件安装</p>
<ul>
<li>软件源镜像服务器</li>
<li>软件源</li>
</ul>
<p>我们需要定期从服务器上下载一个软件包列表，使用 <code>sudo apt-get update</code> 命令来保持本地的软件包列表是最新的（有时你也需要手动执行这个操作，比如更换了软件源），而这个表里会有软件依赖信息的记录，对于软件依赖，举个例子：安装 w3m 软件的时候，而这个软件需要 libgc1c2 这个软件包才能正常工作，这个时候 apt-get 在安装软件的时候会一并替我们安装了，以保证 w3m 能正常的工作。</p>
<h1 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h1><p>apt-get 是用于处理 apt包的公用程序集，可以用它来在线安装、卸载和升级软件包等，下面列出一些apt-get包含的常用的一些工具：</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>install</td>
<td>其后加上软件包名，用于安装一个软件包</td>
</tr>
<tr>
<td>update</td>
<td>从软件源镜像服务器上下载/更新用于更新本地软件源的软件包列表</td>
</tr>
<tr>
<td>upgrade</td>
<td>升级本地可更新的全部软件包，但存在依赖问题时将不会升级，通常会在更新之前执行一次update</td>
</tr>
<tr>
<td>dist-upgrade</td>
<td>解决依赖关系并升级(存在一定危险性)</td>
</tr>
<tr>
<td>remove</td>
<td>移除已安装的软件包，包括与被移除软件包有依赖关系的软件包，但不包含软件包的配置文件</td>
</tr>
<tr>
<td>autoremove</td>
<td>移除之前被其他软件包依赖，但现在不再被使用的软件包</td>
</tr>
<tr>
<td>purge</td>
<td>与remove相同，但会完全移除软件包，包含其配置文件</td>
</tr>
<tr>
<td>clean</td>
<td>移除下载到本地的已经安装的软件包，默认保存在/var/cache/apt/archives/</td>
</tr>
<tr>
<td>autoclean</td>
<td>移除已安装的软件的旧版本软件包</td>
</tr>
</tbody>
</table>
<p>下面是一些apt-get常用的参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-y</td>
<td>自动回应是否安装软件包的选项，在一些自动化安装脚本中使用这个参数将十分有用</td>
</tr>
<tr>
<td>-s</td>
<td>模拟安装</td>
</tr>
<tr>
<td>-q</td>
<td>静默安装方式，指定多个q或者-q=#,#表示数字，用于设定静默级别，这在你不想要在安装软件包时屏幕输出过多时很有用</td>
</tr>
<tr>
<td>-f</td>
<td>修复损坏的依赖关系</td>
</tr>
<tr>
<td>-d</td>
<td>只下载不安装</td>
</tr>
<tr>
<td>–reinstall</td>
<td>重新安装已经安装但可能存在问题的软件包</td>
</tr>
<tr>
<td>–install-suggests</td>
<td>同时安装APT给出的建议安装的软件包</td>
</tr>
</tbody>
</table>
<h2 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install &lt;软件包名&gt;</div></pre></td></tr></table></figure>
<p>重新安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get --reinstall install w3m</div></pre></td></tr></table></figure></p>
<p>软件升级<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 更新软件源</div><div class="line">$ sudo apt-get update</div><div class="line"># 升级没有依赖问题的软件包</div><div class="line">$ sudo apt-get upgrade</div><div class="line"># 升级并解决依赖关系</div><div class="line">$ sudo apt-get dist-upgrade</div></pre></td></tr></table></figure></p>
<p>卸载软件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get remove w3m</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 不保留配置文件的移除</div><div class="line">$ sudo apt-get purge w3m</div><div class="line"># 或者 sudo apt-get --purge remove</div><div class="line"># 移除不再需要的被依赖的软件包</div><div class="line">$ sudo apt-get autoremove</div></pre></td></tr></table></figure>
<p>软件搜索<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-cache search softname1 softname2 softname3……</div></pre></td></tr></table></figure></p>
<p>apt-cache 命令则是针对本地数据进行相关操作的工具，search 顾名思义在本地的数据库中寻找有关 softname1 softname2 ……   </p>
<h1 id="使用-dpkg"><a href="#使用-dpkg" class="headerlink" title="使用 dpkg"></a>使用 dpkg</h1><p>使用 dpkg 从本地磁盘安装 deb 软件包</p>
<h2 id="dpkg-介绍"><a href="#dpkg-介绍" class="headerlink" title="dpkg 介绍"></a>dpkg 介绍</h2><blockquote>
<p>dpkg 是 Debian 软件包管理器的基础，它被伊恩·默多克创建于 1993 年。dpkg 与 RPM 十分相似，同样被用于安装、卸载和供给和 .deb 软件包相关的信息。</p>
<p>dpkg 本身是一个底层的工具。上层的工具，像是 APT，被用于从远程获取软件包以及处理复杂的软件包关系。”dpkg”是”Debian Package”的简写。</p>
</blockquote>
<p>以deb形式打包的软件包，就需要使用dpkg命令来安装。</p>
<p>dpkg常用参数介绍：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-i</td>
<td>安装指定deb包</td>
</tr>
<tr>
<td>-R</td>
<td>后面加上目录名，用于安装该目录下的所有deb安装包</td>
</tr>
<tr>
<td>-r</td>
<td>remove，移除某个已安装的软件包</td>
</tr>
<tr>
<td>-I</td>
<td>显示deb包文件的信息</td>
</tr>
<tr>
<td>-s</td>
<td>显示已安装软件的信息</td>
</tr>
<tr>
<td>-S</td>
<td>搜索已安装的软件包</td>
</tr>
<tr>
<td>-L</td>
<td>显示已安装软件包的目录信息</td>
</tr>
</tbody>
</table>
<h2 id="使用dpkg安装deb软件包"><a href="#使用dpkg安装deb软件包" class="headerlink" title="使用dpkg安装deb软件包"></a>使用dpkg安装deb软件包</h2><p><img src="http://i.imgur.com/0vwHZuF.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 使用dpkg安装</div><div class="line">$ sudo dpkg -i emacs24_24.3+1-4ubuntu1_amd64.deb</div></pre></td></tr></table></figure></p>
<p>dpkg并不能为你解决依赖关系。用apt-get了，使用它的-f参数了，修复依赖关系的安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get -f install</div></pre></td></tr></table></figure></p>
<h2 id="查看已安装软件包的安装目录"><a href="#查看已安装软件包的安装目录" class="headerlink" title="查看已安装软件包的安装目录"></a>查看已安装软件包的安装目录</h2><p>使用dpkg -L查看deb包目录信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo dpkg -L emacs</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-下软件安装&quot;&gt;&lt;a href=&quot;#Linux-下软件安装&quot; class=&quot;headerlink&quot; title=&quot;Linux 下软件安装&quot;&gt;&lt;/a&gt;Linux 下软件安装&lt;/h1&gt;&lt;p&gt;通常 Linux 上的软件安装主要有四种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Linux/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux基础" scheme="http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>13_Linux 进程与程序</title>
    <link href="http://yoursite.com/2017/07/07/Linux/Base/13_Linux%20%E8%BF%9B%E7%A8%8B(pstree,&amp;,jobs,fg,bg,kill)/"/>
    <id>http://yoursite.com/2017/07/07/Linux/Base/13_Linux 进程(pstree,&amp;,jobs,fg,bg,kill)/</id>
    <published>2017-07-07T12:59:47.000Z</published>
    <updated>2017-07-07T12:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程与程序"><a href="#进程与程序" class="headerlink" title="进程与程序"></a>进程与程序</h1><blockquote>
<p>程序（procedure）：不太精确地说，程序就是执行一系列有逻辑、有顺序结构的指令，帮我们达成某个结果。就如我们去餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，最后我们得到了这么一盘牛肉盖浇饭。它需要去执行，不然它就像一本武功秘籍，放在那里等人翻看。  </p>
<p>进程（process）：进程是程序在一个数据集合上的一次执行过程，在早期的UNIX、Linux 2.4及更早的版本中，它是系统进行资源分配和调度的独立基本单位。同上一个例子，就如我们去了餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，而里面做饭的是一个进程，做牛肉汤汁的是一个进程，把牛肉汤汁与饭混合在一起的是一个进程，把饭端上桌的是一个进程。它就像是我们在看武功秘籍这么一个过程，然后一个篇章一个篇章地去练。  </p>
</blockquote>
<p>程序只是一些列指令的集合，是一个静止的实体，而进程不同，进程有以下的特性：  </p>
<ul>
<li>动态性：进程的实质是一次程序执行的过程，有创建、撤销等状态的变化。而程序是一个静态的实体。</li>
<li>并发性：进程可以做到在一个时间段内，有多个程序在运行中。程序只是静态的实体，所以不存在并发性。</li>
<li>独立性：进程可以独立分配资源，独立接受调度，独立地运行。</li>
<li>异步性：进程以不可预知的速度向前推进。</li>
<li>结构性：进程拥有代码段、数据段、PCB（进程控制块，进程存在的唯一标志）。也正是因为有结构性，进程才可以做到独立地运行。</li>
</ul>
<blockquote>
<p>并发：在一个时间段内，宏观来看有多个程序都在活动，有条不紊的执行（每一瞬间只有一个在执行，只是在一段时间有多个程序都执行过）</p>
<p>并行：在每一个瞬间，都有多个程序都在同时执行，这个必须有多个 CPU 才行</p>
</blockquote>
<p>引入进程是因为传统意义上的程序已经不足以描述 OS 中各种活动之间的动态性、并发性、独立性还有相互制约性。程序就像一个公司，只是一些证书，文件的堆积（静态实体）。而当公司运作起来就有各个部门的区分，财务部，技术部，销售部等等，就像各个进程，各个部门之间可以独立运做，也可以有交互（独立性、并发性）。  </p>
<p>而随着程序的发展越做越大，又会继续细分，从而引入了线程的概念，当代多数操作系统、Linux 2.6及更新的版本中，进程本身不是基本运行单位，而是线程的容器。就像上述所说的，每个部门又会细分为各个工作小组（线程），而工作小组需要的资源需要向上级（进程）申请。  </p>
<blockquote>
<p>线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。因为线程中几乎不包含系统资源，所以执行更快、更有效率。</p>
</blockquote>
<p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p>
<p><img src="http://i.imgur.com/srhDdXb.png" alt=""></p>
<h1 id="进程的属性"><a href="#进程的属性" class="headerlink" title="进程的属性"></a>进程的属性</h1><h2 id="进程的分类"><a href="#进程的分类" class="headerlink" title="进程的分类"></a>进程的分类</h2><p>大概明白进程是个什么样的存在后，我们需要进一步了解的就是进程分类。可以从两个角度来分：</p>
<ul>
<li>以进程的功能与服务的对象来分；</li>
<li>以应用程序的服务类型来分；</li>
</ul>
<p>第一个角度来看，我们可以分为用户进程与系统进程：</p>
<ul>
<li>用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。</li>
<li>系统进程：通过执行系统内核程序而产生的进程，比如可以执行内存资源分配和进程切换等相对底层的工作；而且该进程的运行不受用户的干预，即使是 root 用户也不能干预系统进程的运行。</li>
</ul>
<p>第二角度来看，我们可以将进程分为交互进程、批处理进程、守护进程</p>
<ul>
<li>交互进程：由一个 shell 终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。</li>
<li>批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。</li>
<li>守护进程：守护进程是一直运行的一种进程，在 Linux 系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如 httpd 进程，一直处于运行状态，等待用户的访问。还有经常用的 cron（在 centOS 系列为 crond）进程，这个进程为 crontab 的守护进程，可以周期性的执行用户设定的某些任务。</li>
</ul>
<h2 id="进程的衍生"><a href="#进程的衍生" class="headerlink" title="进程的衍生"></a>进程的衍生</h2><p>比如我们启动了终端，就是启动了一个 bash 进程，我们可以在 bash 中再输入 bash 则会再启动一个 bash 的进程，此时第二个 bash 进程就是由第一个 bash 进程创建出来的，他们直接又是个什么关系？  </p>
<p>我们一般称呼第一个 bash 进程是第二 bash 进程的父进程，第二 bash 进程是第一个 bash 进程的子进程，这层关系是如何得来的呢？  </p>
<p>关于父进程与子进程便会提及这两个系统调用 fork() 与 exec()  </p>
<blockquote>
<p>fork-exec是由 Dennis M. Ritchie 创造的</p>
<p>fork() 是一个系统调用（system call），它的主要作用就是为当前的进程创建一个新的进程，这个新的进程就是它的子进程，这个子进程除了父进程的返回值和 PID 以外其他的都一模一样，如进程的执行代码段，内存信息，文件描述，寄存器状态等等</p>
<p>exec() 也是系统调用，作用是切换子进程中的执行程序也就是替换其从父进程复制过来的代码段与数据段</p>
</blockquote>
<p>子进程就是父进程通过系统调用 fork() 而产生的复制品，fork() 就是把父进程的 PCB 等进程的数据结构信息直接复制过来，只是修改了 PID，所以一模一样，只有在执行 exec() 之后才会不同，而早先的 fork() 比较消耗资源后来进化成 vfork(),效率高了不少。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">pid_t p;</div><div class="line">  </div><div class="line">p = fork();</div><div class="line">if (p == (pid_t) -1)</div><div class="line">        /* ERROR */</div><div class="line">else if (p == 0)</div><div class="line">        /* CHILD */</div><div class="line">else</div><div class="line">        /* PARENT */</div></pre></td></tr></table></figure>
<p>既然子进程是通过父进程而衍生出来的，那么子进程的退出与资源的回收定然与父进程有很大的相关性。当一个子进程要正常的终止运行时，或者该进程结束时它的主函数 main() 会执行 exit(n); 或者 return n，这里的返回值 n 是一个信号，系统会把这个 SIGCHLD 信号传给其父进程，当然若是异常终止也往往是因为这个信号。  </p>
<p>在将要结束时的子进程代码执行部分已经结束执行了，系统的资源也基本归还给系统了，但若是其进程的进程控制块（PCB）仍驻留在内存中，而它的 PCB 还在，代表这个进程还存在（因为 PCB 就是进程存在的唯一标志，里面有 PID 等消息），并没有消亡，这样的进程称之为僵尸进程（Zombie）。  </p>
<p>如图中第四列标题是 S，S 表示的是进程的状态，而在下属的第三行的 Z 表示的是 Zombie 的意思。（ ps 命令将在后续详解）  </p>
<p><img src="http://i.imgur.com/fwSfuhx.png" alt="">  </p>
<p>正常情况下，父进程会收到两个返回值：exit code（SIGCHLD 信号）与 reason for termination 。之后，父进程会使用 wait(&amp;status) 系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的 PCB；而如若父进程没有这么做的话，子进程的 PCB 就会一直驻留在内存中，一直留在系统中成为僵尸进程（Zombie）。  </p>
<p>虽然僵尸进程是已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，在进程列表中保留一个位置，记载该进程的退出状态等信息供其父进程收集，从而释放它。但是 Linux 系统中能使用的 PID 是有限的，如果系统中存在有大量的僵尸进程，系统将会因为没有可用的 PID 从而导致不能产生新的进程。  </p>
<p>另外如果父进程结束（非正常的结束），未能及时收回子进程，子进程仍在运行，这样的子进程称之为孤儿进程。在 Linux 系统中，孤儿进程一般会被 init 进程所“收养”，成为 init 的子进程。由 init 来做善后处理，所以它并不至于像僵尸进程那样无人问津，不管不顾，大量存在会有危害。  </p>
<p>进程 0 是系统引导时创建的一个特殊进程，也称之为内核初始化，其最后一个动作就是调用 fork() 创建出一个子进程运行 /sbin/init 可执行文件,而该进程就是 PID=1 的进程 1，而进程 0 就转为交换进程（也被称为空闲进程），进程 1 （init 进程）是第一个用户态的进程，再由它不断调用 fork() 来创建系统里其他的进程，所以它是所有进程的父进程或者祖先进程。同时它是一个守护程序，直到计算机关机才会停止。  </p>
<p>通过以下的命令我们可以很明显的看到这样的结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pstree</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/4Y1j8Bn.png" alt="">  </p>
<p>或者从此图可以更加形象的看清子父进程的关系</p>
<p><img src="http://i.imgur.com/AR8rlHI.png" alt="">  </p>
<p>通过以上的显示结果我们可以看的很清楚，init 为所有进程的父进程或者说是祖先进程  </p>
<p>我们还可以使用这样一个命令来看，其中 pid 就是该进程的一个唯一编号，ppid 就是该进程的父进程的 pid，command 表示的是该进程通过执行什么样的命令或者脚本而产生的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps －fxo user,ppid,pid,pgid,command</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/kYJ2idS.png" alt="">  </p>
<p>可以在图中看见我们执行的 ps 就是由 zsh 通过 fork-exec 创建的子进程而执行的</p>
<p>使用这样的一个命令我们也能清楚的看见 init 如上文所说是由进程 0 这个初始化进程来创建而出的子进程,而其他的进程基本是由 init 创建的子进程，或者是由它的子进程创建出来的子进程。所以 init 是用户进程的第一个进程也是所有用户进程的父进程或者祖先进程。（ps 命令将在后续课程详解）</p>
<p>就像一个树状图，而 init 进程就是这棵树的根，其他进程由根不断的发散，开枝散叶</p>
<h2 id="进程组与-Sessions"><a href="#进程组与-Sessions" class="headerlink" title="进程组与 Sessions"></a>进程组与 Sessions</h2><p>每一个进程都会是一个进程组的成员，而且这个进程组是唯一存在的，他们是依靠 PGID（process group ID）来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。  </p>
<p>一般情况，进程组的 PGID 等同于进程组的第一个成员的 PID，并且这样的进程称为该进程组的领导者,也就是领导进程，进程一般通过使用 getpgrp() 系统调用来寻找其所在组的 PGID，领导进程可以先终结，此时进程组依然存在，并持有相同的PGID，直到进程组中最后一个进程终结。  </p>
<p>与进程组类似，每当一个进程被创建的时候，它便会成为其父进程所在 Session 中的一员，每一个进程组都会在一个 Session 中，并且这个 Session 是唯一存在的，  </p>
<p>Session 主要是针对一个 tty 建立，Session 中的每个进程都称为一个工作(job)。每个会话可以连接一个终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。Session 意义在于将多个 jobs 囊括在一个终端，并取其中的一个 job 作为前台，来直接接收该终端的输入输出以及终端信号。 其他 jobs 在后台运行。  </p>
<blockquote>
<p>前台（foreground）就是在终端中运行，能与你有交互的</p>
<p>后台（background）就是在终端中运行，但是你并不能与其任何的交互，也不会显示其执行的过程</p>
</blockquote>
<h2 id="工作管理"><a href="#工作管理" class="headerlink" title="工作管理"></a>工作管理</h2><p>bash(Bourne-Again shell)支持工作控制（job control）,而 sh（Bourne shell）并不支持。  </p>
<p>并且每个终端或者说 bash 只能管理当前终端的中的 job，不能管理其他终端中的 job。比如我当前存在两个 bash 分别为 bash1、bash2，bash1 只能管理其自己里面的 job 并不能管理 bash2 里面的 job  </p>
<p>我们都知道当一个进程在前台运作时我们可以用 ctrl + c 来终止它，但是若是在后台的话就不行了。  </p>
<p>我们可以通过 &amp; 这个符号，让我们的命令在后台中运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls &amp;</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/t6njbEZ.png" alt="">  </p>
<p>图中所显示的 [1] 236分别是该 job 的 job number 与该进程的 PID，而最后一行的 Done 表示该命令已经在后台执行完毕。  </p>
<p>我们还可以通过 ctrl + z 使我们的当前工作停止并丢到后台中去  </p>
<p><img src="http://i.imgur.com/mme7wlc.png" alt="">  </p>
<p>被停止并放置在后台的工作我们可以使用这个命令来查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jobs</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/UtOmOw4.png" alt="">  </p>
<p>其中第一列显示的为被放置后台 job 的编号，而第二列的 ＋ 表示最近(刚刚、最后)被放置后台的 job，同时也表示预设的工作，也就是若是有什么针对后台 job 的操作，首先对预设的 job，- 表示倒数第二（也就是在预设之前的一个）被放置后台的工作，倒数第三个（再之前的）以后都不会有这样的符号修饰，第三列表示它们的状态，而最后一列表示该进程执行的命令  </p>
<p>我们可以通过这样的一个命令将后台的工作拿到前台来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#后面不加参数提取预设工作，加参数提取指定工作的编号</div><div class="line">#ubuntu 在 zsh 中需要 %，在 bash 中不需要 %</div><div class="line">fg [%jobnumber]</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/TTxSjQC.png" alt=""><br><img src="http://i.imgur.com/wWiI1wb.png" alt="">  </p>
<p>之前我们通过 ctrl + z 使得工作停止放置在后台，若是我们想让其在后台运作我们就使用这样一个命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#与fg类似，加参则指定，不加参则取预设</div><div class="line">bg [%jobnumber]</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/ZsVKHUW.png" alt="">  </p>
<p>既然有方法将被放置在后台的工作提至前台或者让它从停止变成继续运行在后台，当然也有方法删除一个工作，或者重启等等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#kill的使用格式如下</div><div class="line">kill -signal %jobnumber</div><div class="line">  </div><div class="line">#signal从1-64个信号值可以选择，可以这样查看</div><div class="line">kill －l</div></pre></td></tr></table></figure></p>
<p>其中常用的有这些信号值  </p>
<table>
<thead>
<tr>
<th>信号值</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-1</td>
<td>重新读取参数运行，类似与restart</td>
</tr>
<tr>
<td>-2</td>
<td>如同 ctrl+c 的操作退出</td>
</tr>
<tr>
<td>-9</td>
<td>强制终止该任务</td>
</tr>
<tr>
<td>-15</td>
<td>正常的方式终止该任务</td>
</tr>
</tbody>
</table>
<p><img src="http://i.imgur.com/ooBuH04.png" alt="">  </p>
<blockquote>
<p>注意:</p>
<p>若是在使用kill＋信号值然后直接加 pid，你将会对 pid 对应的进程进行操作</p>
<p>若是在使用kill+信号值然后 ％jobnumber，这时所操作的对象是 job，这个数字就是就当前 bash 中后台的运行的 job 的 ID</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;进程与程序&quot;&gt;&lt;a href=&quot;#进程与程序&quot; class=&quot;headerlink&quot; title=&quot;进程与程序&quot;&gt;&lt;/a&gt;进程与程序&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;程序（procedure）：不太精确地说，程序就是执行一系列有逻辑、有顺序结构的指令，帮我
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Linux/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux基础" scheme="http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
