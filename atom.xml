<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mortalLiao</title>
  <subtitle>Keep learning</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-07-29T12:57:13.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>mortalLiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>01_Java并发篇_前言</title>
    <link href="http://yoursite.com/2017/07/29/Backend/Java/concurrence/01_Java%E5%B9%B6%E5%8F%91%E7%AF%87_%E5%89%8D%E8%A8%80/"/>
    <id>http://yoursite.com/2017/07/29/Backend/Java/concurrence/01_Java并发篇_前言/</id>
    <published>2017-07-29T12:57:13.000Z</published>
    <updated>2017-07-29T12:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>并发很重要的，前言中记录事件与体会</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并发很重要的，前言中记录事件与体会&lt;/p&gt;

    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/"/>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>05_Java并发篇_饥饿与公平</title>
    <link href="http://yoursite.com/2017/07/29/Backend/Java/concurrence/05_Java%E5%B9%B6%E5%8F%91%E7%AF%87_%E9%A5%A5%E9%A5%BF%E4%B8%8E%E5%85%AC%E5%B9%B3/"/>
    <id>http://yoursite.com/2017/07/29/Backend/Java/concurrence/05_Java并发篇_饥饿与公平/</id>
    <published>2017-07-29T12:57:13.000Z</published>
    <updated>2017-07-29T12:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="饥饿和公平"><a href="#饥饿和公平" class="headerlink" title="饥饿和公平"></a>饥饿和公平</h1><p>如果一个线程因为CPU时间全部被其他线程抢走而得不到CPU运行时间，这种状态被称之为“饥饿”。<br>而该线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。<br>解决饥饿的方案被称之为“公平性” – 即所有线程均能公平地获得运行机会。  </p>
<h2 id="Java中导致饥饿的原因："><a href="#Java中导致饥饿的原因：" class="headerlink" title="Java中导致饥饿的原因："></a>Java中导致饥饿的原因：</h2><ol>
<li><p>高优先级线程吞噬所有的低优先级线程的CPU时间。  </p>
</li>
<li><p>线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。  </p>
</li>
<li><p>线程在等待一个本身(在其上调用wait())也处于永久等待完成的对象，因为其他线程总是被持续地获得唤醒。  </p>
</li>
</ol>
<p>如果多个线程处在wait()方法执行上，而对其调用notify()不会保证哪一个线程会获得唤醒，任何线程都有可能处于继续等待的状态。因此存在这样一个风险：一个等待线程从来得不到唤醒，因为其他等待线程总是能被获得唤醒。</p>
<h3 id="高优先级线程吞噬所有的低优先级线程的CPU时间"><a href="#高优先级线程吞噬所有的低优先级线程的CPU时间" class="headerlink" title="高优先级线程吞噬所有的低优先级线程的CPU时间"></a>高优先级线程吞噬所有的低优先级线程的CPU时间</h3><p>你能为每个线程设置独自的线程优先级，优先级越高的线程获得的CPU时间越多，线程优先级值设置在1到10之间，而这些优先级值所表示行为的准确解释则依赖于你的应用运行平台。对大多数应用来说，你最好是不要改变其优先级值。  </p>
<h3 id="线程被永久堵塞在一个等待进入同步块的状态"><a href="#线程被永久堵塞在一个等待进入同步块的状态" class="headerlink" title="线程被永久堵塞在一个等待进入同步块的状态"></a>线程被永久堵塞在一个等待进入同步块的状态</h3><p>Java的同步代码区也是一个导致饥饿的因素。Java的同步代码区对哪个线程允许进入的次序没有任何保障。这就意味着理论上存在一个试图进入该同步区的线程处于被永久堵塞的风险，因为其他线程总是能持续地先于它获得访问，这即是“饥饿”问题，而一个线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。  </p>
<h3 id="线程在等待一个本身-在其上调用wait-也处于永久等待完成的对象"><a href="#线程在等待一个本身-在其上调用wait-也处于永久等待完成的对象" class="headerlink" title="线程在等待一个本身(在其上调用wait())也处于永久等待完成的对象"></a>线程在等待一个本身(在其上调用wait())也处于永久等待完成的对象</h3><p>如果多个线程处在wait()方法执行上，而对其调用notify()不会保证哪一个线程会获得唤醒，任何线程都有可能处于继续等待的状态。因此存在这样一个风险：一个等待线程从来得不到唤醒，因为其他等待线程总是能被获得唤醒。  </p>
<h2 id="在Java中实现公平性方案"><a href="#在Java中实现公平性方案" class="headerlink" title="在Java中实现公平性方案"></a>在Java中实现公平性方案</h2><ol>
<li>使用锁，而不是同步块。</li>
<li>公平锁。</li>
<li>注意性能方面。</li>
</ol>
<p>Java不可能实现100%的公平性，我们依然可以通过同步结构在线程间实现公平性的提高。</p>
<h3 id="同步态代码"><a href="#同步态代码" class="headerlink" title="同步态代码"></a>同步态代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class Synchronizer&#123;</div><div class="line">  </div><div class="line">    public synchronized void doSynchronized()&#123;</div><div class="line">        //do a lot of work which takes a long time</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果有一个以上的线程调用doSynchronized()方法，在第一个获得访问的线程未完成前，其他线程将一直处于阻塞状态，而且在这种多线程被阻塞的场景下，接下来将是哪个线程获得访问是没有保障的。  </p>
<h3 id="使用锁方式替代同步块"><a href="#使用锁方式替代同步块" class="headerlink" title="使用锁方式替代同步块"></a>使用锁方式替代同步块</h3><p>为了提高等待线程的公平性，使用锁方式来替代同步块。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Synchronizer&#123;</div><div class="line">    Lock lock = new Lock();</div><div class="line">    public void doSynchronized() throws InterruptedException&#123;</div><div class="line">        this.lock.lock();</div><div class="line">        //critical section, do a lot of work which takes a long time</div><div class="line">        this.lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>doSynchronized()不再声明为synchronized，而是用lock.lock()和lock.unlock()来替代。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class Lock&#123;</div><div class="line">  </div><div class="line">    private boolean isLocked      = false;</div><div class="line">    private Thread lockingThread = null;</div><div class="line">  </div><div class="line">    public synchronized void lock() throws InterruptedException&#123;</div><div class="line">  </div><div class="line">        while(isLocked)&#123;</div><div class="line">            wait();</div><div class="line">        &#125;</div><div class="line">  </div><div class="line">        isLocked = true;</div><div class="line">        lockingThread = Thread.currentThread();</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    public synchronized void unlock()&#123;</div><div class="line">  </div><div class="line">        if(this.lockingThread != Thread.currentThread())&#123;</div><div class="line">  </div><div class="line">             throw new IllegalMonitorStateException(</div><div class="line">                  &quot;Calling thread has not locked this lock&quot;);</div><div class="line">             &#125;</div><div class="line">  </div><div class="line">        isLocked = false;</div><div class="line">        lockingThread = null;</div><div class="line">        notify();</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果存在多线程并发访问lock()，这些线程将阻塞在对lock()方法的访问上。另外，如果锁已经锁上（校对注：这里指的是isLocked等于true时），这些线程将阻塞在while(isLocked)循环的wait()调用里面。要记住的是，当线程正在等待进入lock() 时，可以调用wait()释放其锁实例对应的同步锁，使得其他多个线程可以进入lock()方法，并调用wait()方法。  </p>
<p>在lock()和unlock()之间：在这两个调用之间的代码将运行很长一段时间。进一步设想，这段代码将长时间运行，和进入lock()并调用wait()来比较的话。这意味着大部分时间用在等待进入锁和进入临界区的过程是用在wait()的等待中，而不是被阻塞在试图进入lock()方法中。  </p>
<p>同步块不会对等待进入的多个线程谁能获得访问做任何保障，同样当调用notify()时，也不会做保障一定能唤醒线程。因此这个的Lock类和doSynchronized()那个就保障公平性而言，没有任何区别。</p>
<p>但是，如果每个线程在不同的对象上调用wait()，那么只有一个线程会在该对象上调用wait()，Lock类可以决定哪个对象能对其调用notify()，因此能做到有效的选择唤醒哪个线程。</p>
<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>每一个调用lock()的线程都会进入一个队列，当解锁后，只有队列里的第一个线程被允许锁住Farlock实例，所有其它的线程都将处于等待状态，直到他们处于队列头部。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public class FairLock &#123;</div><div class="line">    private boolean           isLocked       = false;</div><div class="line">    private Thread            lockingThread  = null;</div><div class="line">    private List&lt;QueueObject&gt; waitingThreads = new ArrayList&lt;QueueObject&gt;();</div><div class="line"></div><div class="line">  public void lock() throws InterruptedException&#123;</div><div class="line">    QueueObject queueObject = new QueueObject();</div><div class="line">    boolean isLockedForThisThread = true;</div><div class="line">    synchronized(this)&#123;</div><div class="line">        waitingThreads.add(queueObject);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    while(isLockedForThisThread)&#123;</div><div class="line">      synchronized(this)&#123;</div><div class="line">        isLockedForThisThread =</div><div class="line">            isLocked || waitingThreads.get(0) != queueObject;</div><div class="line">        if(!isLockedForThisThread)&#123;</div><div class="line">          isLocked = true;</div><div class="line">           waitingThreads.remove(queueObject);</div><div class="line">           lockingThread = Thread.currentThread();</div><div class="line">           return;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      try&#123;</div><div class="line">        queueObject.doWait();</div><div class="line">      &#125;catch(InterruptedException e)&#123;</div><div class="line">        synchronized(this) &#123; waitingThreads.remove(queueObject); &#125;</div><div class="line">        throw e;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  public synchronized void unlock()&#123;</div><div class="line">    if(this.lockingThread != Thread.currentThread())&#123;</div><div class="line">      throw new IllegalMonitorStateException(</div><div class="line">        &quot;Calling thread has not locked this lock&quot;);</div><div class="line">    &#125;</div><div class="line">    isLocked      = false;</div><div class="line">    lockingThread = null;</div><div class="line">    if(waitingThreads.size() &gt; 0)&#123;</div><div class="line">      waitingThreads.get(0).doNotify();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class QueueObject &#123;</div><div class="line">  </div><div class="line">    private boolean isNotified = false;</div><div class="line">  </div><div class="line">    public synchronized void doWait() throws InterruptedException &#123;</div><div class="line"></div><div class="line">        while(!isNotified)&#123;</div><div class="line">            this.wait();</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        this.isNotified = false;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    public synchronized void doNotify() &#123;</div><div class="line">        this.isNotified = true;</div><div class="line">        this.notify();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public boolean equals(Object o) &#123;</div><div class="line">        return this == o;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>lock()方法不在声明为synchronized，取而代之的是对必需同步的代码，在synchronized中进行嵌套。  </p>
<p>FairLock新创建了一个QueueObject的实例，并对每个调用lock()的线程进行入队列。调用unlock()的线程将从队列头部获取QueueObject，并对其调用doNotify()，以唤醒在该对象上等待的线程。通过这种方式，在同一时间仅有一个等待线程获得唤醒，而不是所有的等待线程。这也是实现FairLock公平性的核心所在。  </p>
<p>请注意，在同一个同步块中，锁状态依然被检查和设置，以避免出现滑漏条件。  </p>
<p>还需注意到，QueueObject实际是一个semaphore。doWait()和doNotify()方法在QueueObject中保存着信号。这样做以避免一个线程在调用queueObject.doWait()之前被另一个调用unlock()并随之调用queueObject.doNotify()的线程重入，从而导致信号丢失。queueObject.doWait()调用放置在synchronized(this)块之外，以避免被monitor嵌套锁死，所以另外的线程可以解锁，只要当没有线程在lock方法的synchronized(this)块中执行即可。  </p>
<p>最后，注意到queueObject.doWait()在try – catch块中是怎样调用的。在InterruptedException抛出的情况下，线程得以离开lock()，并需让它从队列中移除。  </p>
<h3 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h3><p>如果比较Lock和FairLock类，你会注意到在FairLock类中lock()和unlock()还有更多需要深入的地方。这些额外的代码会导致FairLock的同步机制实现比Lock要稍微慢些。究竟存在多少影响，还依赖于应用在FairLock临界区执行的时长。执行时长越大，FairLock带来的负担影响就越小，当然这也和代码执行的频繁度相关。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;饥饿和公平&quot;&gt;&lt;a href=&quot;#饥饿和公平&quot; class=&quot;headerlink&quot; title=&quot;饥饿和公平&quot;&gt;&lt;/a&gt;饥饿和公平&lt;/h1&gt;&lt;p&gt;如果一个线程因为CPU时间全部被其他线程抢走而得不到CPU运行时间，这种状态被称之为“饥饿”。&lt;br&gt;而该线程被“饥
    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/"/>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>02_Java并发篇_线程状态_Java内存模型</title>
    <link href="http://yoursite.com/2017/07/29/Backend/Java/concurrence/02_Java%E5%B9%B6%E5%8F%91%E7%AF%87_%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81_Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2017/07/29/Backend/Java/concurrence/02_Java并发篇_线程状态_Java内存模型/</id>
    <published>2017-07-29T12:57:13.000Z</published>
    <updated>2017-07-29T12:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><p>Java中，线程的状态有以下6类：NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED。  </p>
<p><img src="http://i.imgur.com/6UG5qH5.png" alt="">  </p>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>Java内存模型把Java虚拟机内部划分为线程栈和堆。  </p>
<p>每一个运行在Java虚拟机里的线程都拥有自己的线程栈。  </p>
<p>一个线程仅能访问自己的线程栈。一个线程创建的本地变量对其它线程不可见，仅自己可见。  </p>
<p>即使两个线程执行同样的代码，这两个线程任然在在自己的线程栈中的代码来创建本地变量。因此，每个线程拥有每个本地变量的独有版本。  </p>
<p>所有原始类型的本地变量都存放在线程栈上，因此对其它线程不可见。一个线程可能向另一个线程传递一个原始类型变量的拷贝，但是它不能共享这个原始类型变量自身。  </p>
<p>堆上包含在Java程序中创建的所有对象，无论是哪一个对象创建的。这包括原始类型的对象版本。如果一个对象被创建然后赋值给一个局部变量，或者用来作为另一个对象的成员变量，这个对象任然是存放在堆上。  </p>
<p><img src="http://i.imgur.com/KkNgaH3.png" alt="">  </p>
<p>一个本地变量可能是原始类型，在这种情况下，它总是“呆在”线程栈上。  </p>
<p>一个本地变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。  </p>
<p>一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量任然存放在线程栈上，即使这些方法所属的对象存放在堆上。  </p>
<p><strong>一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。</strong>  </p>
<p><strong>静态成员变量跟随着类定义一起也存放在堆上。</strong></p>
<p>存放在堆上的对象可以被所有持有对这个对象引用的线程访问。<br>当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。<br>如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个本地变量的私有拷贝。<br><img src="http://i.imgur.com/P8Qadbg.png" alt="">  </p>
<h1 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a>硬件内存架构</h1><p><img src="http://i.imgur.com/N1SOkpH.png" alt="">  </p>
<p>每个CPU都包含一系列的寄存器，它们是CPU内内存的基础。CPU在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为CPU访问寄存器的速度远大于主存。  </p>
<p>每个CPU可能还有一个CPU缓存层。实际上，绝大多数的现代CPU都有一定大小的缓存层。  </p>
<p>共享对象被初始化在主存中。跑在CPU上的一个线程将这个共享对象读到CPU缓存中。然后修改了这个对象。只要CPU缓存没有被刷新会主存，对象修改后的版本对跑在其它CPU上的线程都是不可见的。这种方式可能导致每个线程拥有这个共享对象的私有拷贝，每个拷贝停留在不同的CPU缓存中。  </p>
<p>跑在左边CPU的线程拷贝这个共享对象到它的CPU缓存中，然后将count变量的值修改为2。这个修改对跑在右边CPU上的其它线程是不可见的，因为修改后的count的值还没有被刷新回主存中去。<br><img src="http://i.imgur.com/aIckfGe.png" alt=""><br>解决这个问题你可以使用Java中的volatile关键字。volatile关键字可以保证直接从主存中读取一个变量，如果这个变量被修改后，总是会被写回到主存中去。  </p>
<h2 id="Race-Conditions"><a href="#Race-Conditions" class="headerlink" title="Race Conditions"></a>Race Conditions</h2><p>如果两个或者更多的线程共享一个对象，多个线程在这个共享对象上更新变量，就有可能发生race conditions。</p>
<p>如果线程A读一个共享对象的变量count到它的CPU缓存中。线程B也做了同样的事情，但是往一个不同的CPU缓存中。现在线程A将count加1，线程B也做了同样的事情。现在count已经被增在了两个，每个CPU缓存中一次。</p>
<p>如果这些增加操作被顺序的执行，变量count应该被增加两次，然后原值+2被写回到主存中去。</p>
<p>然而，两次增加都是在没有适当的同步下并发执行的。无论是线程A还是线程B将count修改后的版本写回到主存中取，修改后的值仅会被原值大1，尽管增加了两次。</p>
<p><img src="http://i.imgur.com/zfLpW4r.png" alt="">  </p>
<p>解决这个问题可以使用Java同步块。<br><strong>一个同步块可以保证在同一时刻仅有一个线程可以进入代码的临界区。</strong><br>同步块还可以保证代码块中所有被访问的变量将会从主存中读入，当线程退出同步代码块时，所有被更新的变量都会被刷新回主存中去，不管这个变量是否被声明为volatile。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线程的状态&quot;&gt;&lt;a href=&quot;#线程的状态&quot; class=&quot;headerlink&quot; title=&quot;线程的状态&quot;&gt;&lt;/a&gt;线程的状态&lt;/h1&gt;&lt;p&gt;Java中，线程的状态有以下6类：NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WA
    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/"/>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>02_Java容器篇_ThreadLocal</title>
    <link href="http://yoursite.com/2017/07/29/Backend/Java/container/02_Java%E5%AE%B9%E5%99%A8%E7%AF%87_ThreadLocal/"/>
    <id>http://yoursite.com/2017/07/29/Backend/Java/container/02_Java容器篇_ThreadLocal/</id>
    <published>2017-07-29T12:57:13.000Z</published>
    <updated>2017-07-29T12:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p>
<h1 id="ThreadLocal类提供的方法："><a href="#ThreadLocal类提供的方法：" class="headerlink" title="ThreadLocal类提供的方法："></a>ThreadLocal类提供的方法：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public T get() &#123; &#125;</div><div class="line">public void set(T value) &#123; &#125;</div><div class="line">public void remove() &#123; &#125;</div><div class="line">protected T initialValue() &#123; &#125;</div></pre></td></tr></table></figure>
<p>get()方法是用来获取ThreadLocal在当前线程中保存的变量副本，<br>set()用来设置当前线程中变量的副本，<br>remove()用来移除当前线程中变量的副本，<br>initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法  </p>
<h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><p><img src="http://i.imgur.com/A9nfw1e.jpg" alt="">  </p>
<p>第一句是取得当前线程，然后通过getMap(t)方法获取到一个map，map的类型为ThreadLocalMap。然后接着下面获取到<key,value>键值对，注意这里获取键值对传进去的是  this，而不是当前线程t。  </key,value></p>
<p>如果获取成功，则返回value值。  </p>
<p>如果map为空，则调用setInitialValue方法返回value。  </p>
<p>getMap()<br><img src="http://i.imgur.com/OyctcgA.jpg" alt="">  </p>
<p>在getMap中，是调用当期线程t，返回当前线程t中的一个成员变量threadLocals。<br><img src="http://i.imgur.com/qPnpfOa.jpg" alt="">  </p>
<p>实际上就是一个ThreadLocalMap，这个类型是ThreadLocal类的一个内部类:<br><img src="http://i.imgur.com/2g2gaS2.jpg" alt=""><br>ThreadLocalMap的Entry继承了WeakReference，并且使用ThreadLocal作为键值。  </p>
<h2 id="setInitialValue"><a href="#setInitialValue" class="headerlink" title="setInitialValue()"></a>setInitialValue()</h2><p><img src="http://i.imgur.com/6ROXpdf.jpg" alt=""><br>如果map不为空，就设置键值对，为空，再创建Map<br><img src="http://i.imgur.com/gf3RhcN.jpg" alt="">  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。  </p>
<p>初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。  </p>
<p>然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。  </p>
<p>1）实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的；</p>
<p>2）为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个类型不同的threadLocal变量；</p>
<p>3）在进行get之前，必须先set，否则会报空指针异常；  </p>
<p>如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法。  </p>
<p>如果没有先set的话，即在map中查找不到对应的存储，则会通过调用setInitialValue方法返回i，而在setInitialValue方法中，有一个语句是T value = initialValue()， 而默认情况下，initialValue方法返回的是null</p>
<p><img src="http://i.imgur.com/7QdrQ0S.jpg" alt="">  </p>
<h1 id="ThreadLocal的应用场景"><a href="#ThreadLocal的应用场景" class="headerlink" title="ThreadLocal的应用场景"></a>ThreadLocal的应用场景</h1><p>最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ThreadLocal&quot;&gt;&lt;a href=&quot;#ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal&quot;&gt;&lt;/a&gt;ThreadLocal&lt;/h1&gt;&lt;p&gt;ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线
    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/"/>
    
      <category term="容器" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="Java容器" scheme="http://yoursite.com/tags/Java%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>01_Java容器篇_前言</title>
    <link href="http://yoursite.com/2017/07/29/Backend/Java/container/01_Java%E5%AE%B9%E5%99%A8%E7%AF%87_%E5%89%8D%E8%A8%80/"/>
    <id>http://yoursite.com/2017/07/29/Backend/Java/container/01_Java容器篇_前言/</id>
    <published>2017-07-29T12:57:13.000Z</published>
    <updated>2017-07-29T12:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>这几天一直在面试，跟一个面试官聊了挺多，其中有一点感悟特别深，也提点了我。</p>
<p>是啊，有些知识点可能永远也用不上，像ArrayList和LinkedList，源码这辈子不知道都没关系，可惜，用不到不能够是偷懒就不学的理由，积少成多才能质变。</p>
<p>所以从现在必须花时间看源码上。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天一直在面试，跟一个面试官聊了挺多，其中有一点感悟特别深，也提点了我。&lt;/p&gt;
&lt;p&gt;是啊，有些知识点可能永远也用不上，像ArrayList和LinkedList，源码这辈子不知道都没关系，可惜，用不到不能够是偷懒就不学的理由，积少成多才能质变。&lt;/p&gt;
&lt;p&gt;所以从现
    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/"/>
    
      <category term="容器" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="Java容器" scheme="http://yoursite.com/tags/Java%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>04_Java并发篇_死锁</title>
    <link href="http://yoursite.com/2017/07/29/Backend/Java/concurrence/04_Java%E5%B9%B6%E5%8F%91%E7%AF%87_%E6%AD%BB%E9%94%81/"/>
    <id>http://yoursite.com/2017/07/29/Backend/Java/concurrence/04_Java并发篇_死锁/</id>
    <published>2017-07-29T12:57:13.000Z</published>
    <updated>2017-07-29T12:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>死锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。  </p>
<p>例如：<br>如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这时死锁就发生了。<br>线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。  </p>
<h1 id="数据库的死锁"><a href="#数据库的死锁" class="headerlink" title="数据库的死锁"></a>数据库的死锁</h1><p>更加复杂的死锁场景发生在数据库事务中。一个数据库事务可能由多条SQL更新请求组成。<br><strong>当在一个事务中更新一条记录，这条记录就会被锁住避免其他事务的更新请求，直到第一个事务结束。</strong><br>同一个事务中每一个更新请求都可能会锁住一些记录。  </p>
<p>当多个事务同时需要对一些相同的记录做更新操作时，就很有可能发生死锁，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Transaction 1, request 1, locks record 1 for update</div><div class="line">Transaction 2, request 1, locks record 2 for update</div><div class="line">Transaction 1, request 2, tries to lock record 2 for update.</div><div class="line">Transaction 2, request 2, tries to lock record 1 for update.</div></pre></td></tr></table></figure></p>
<p>因为锁发生在不同的请求中，并且对于一个事务来说不可能提前知道所有它需要的锁，因此很难检测和避免数据库事务中的死锁。  </p>
<h1 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h1><p>在有些情况下死锁是可以避免的。  </p>
<ol>
<li>加锁顺序</li>
<li>加锁时限</li>
<li>死锁检测</li>
</ol>
<h2 id="加锁顺序"><a href="#加锁顺序" class="headerlink" title="加锁顺序"></a>加锁顺序</h2><p>当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。  </p>
<p>如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Thread 1:</div><div class="line">  lock A </div><div class="line">  lock B</div><div class="line">  </div><div class="line">Thread 2:</div><div class="line">   wait for A</div><div class="line">   lock C (when A locked)</div><div class="line">  </div><div class="line">Thread 3:</div><div class="line">   wait for A</div><div class="line">   wait for B</div><div class="line">   wait for C</div></pre></td></tr></table></figure></p>
<p>按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁(译者注：并对这些锁做适当的排序)，但总有些时候是无法预知的。  </p>
<h2 id="加锁时限"><a href="#加锁时限" class="headerlink" title="加锁时限"></a>加锁时限</h2><p>另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。<br>若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。  </p>
<p>这段随机的等待时间让其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行(注：加锁超时后可以先继续运行干点其它事情，再回头来重复之前加锁的逻辑)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Thread 1 locks A</div><div class="line">Thread 2 locks B</div><div class="line">  </div><div class="line">Thread 1 attempts to lock B but is blocked</div><div class="line">Thread 2 attempts to lock A but is blocked</div><div class="line">  </div><div class="line">Thread 1&apos;s lock attempt on B times out</div><div class="line">Thread 1 backs up and releases A as well</div><div class="line">Thread 1 waits randomly (e.g. 257 millis) before retrying.</div><div class="line">  </div><div class="line">Thread 2&apos;s lock attempt on A times out</div><div class="line">Thread 2 backs up and releases B as well</div><div class="line">Thread 2 waits randomly (e.g. 43 millis) before retrying.</div></pre></td></tr></table></figure></p>
<p>需要注意的是，由于存在锁的超时，所以我们不能认为这种场景就一定是出现了死锁。也可能是因为获得了锁的线程（导致其它线程超时）需要很长的时间去完成它的任务。  </p>
<p>此外，如果有非常多的线程同一时间去竞争同一批资源，就算有超时和回退机制，还是可能会导致这些线程重复地尝试但却始终得不到锁。如果只有两个线程，并且重试的超时时间设定为0到500毫秒之间，这种现象可能不会发生，但是如果是10个或20个线程情况就不同了。因为这些线程等待相等的重试时间的概率就高的多（或者非常接近以至于会出现问题）。  </p>
<h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><p>死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。  </p>
<p>每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。  </p>
<p>当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。例如，线程A请求锁7，但是锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前所持有的锁。如果线程B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线程B拥有锁7，请求锁1）。  </p>
<p>当然，死锁一般要比两个线程互相持有对方的锁这种情况要复杂的多。线程A等待线程B，线程B等待线程C，线程C等待线程D，线程D又在等待线程A。线程A为了检测死锁，它需要递进地检测所有被B请求的锁。从线程B所请求的锁开始，线程A找到了线程C，然后又找到了线程D，发现线程D请求的锁被线程A自己持有着。这是它就知道发生了死锁。  </p>
<p>可以被用来检测死锁的数据结构。<br><img src="http://i.imgur.com/wW4vN5G.png" alt="">  </p>
<p>那么当检测出死锁时，这些线程该做些什么呢？  </p>
<p>一个可行的做法是释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁（编者注：原因同超时类似，不能从根本上减轻竞争）。  </p>
<p>一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁&quot;&gt;&lt;/a&gt;死锁&lt;/h1&gt;&lt;p&gt;死锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。  &lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/"/>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>03_Java并发篇_Java同步块</title>
    <link href="http://yoursite.com/2017/07/29/Backend/Java/concurrence/03_Java%E5%B9%B6%E5%8F%91%E7%AF%87_Java%E5%90%8C%E6%AD%A5%E5%9D%97/"/>
    <id>http://yoursite.com/2017/07/29/Backend/Java/concurrence/03_Java并发篇_Java同步块/</id>
    <published>2017-07-29T12:57:13.000Z</published>
    <updated>2017-07-29T12:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-同步关键字（synchronized）"><a href="#Java-同步关键字（synchronized）" class="headerlink" title="Java 同步关键字（synchronized）"></a>Java 同步关键字（synchronized）</h1><p>Java中的同步块用synchronized标记。同步块在Java中是同步在某个对象上。所有同步在一个对象上的同步块在同时只能被一个线程进入并执行操作。所有其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出。  </p>
<p>有四种不同的同步块：  </p>
<ol>
<li>实例方法</li>
<li>静态方法</li>
<li>实例方法中的同步块</li>
<li>静态方法中的同步块</li>
</ol>
<h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><p>1、通过共享对象通信</p>
<p>2、忙等待</p>
<p>3、wait(),notify()和notifyAll()</p>
<p>4、丢失的信号</p>
<p>5、不要对常量字符串或全局对象调用wait()</p>
<h2 id="通过共享对象通信"><a href="#通过共享对象通信" class="headerlink" title="通过共享对象通信"></a>通过共享对象通信</h2><p>线程间发送信号的一个简单方式是在共享对象的变量里设置信号值。线程A在一个同步块里设置boolean型成员变量hasDataToProcess为true，线程B也在同步块里读取hasDataToProcess这个成员变量。这个简单的例子使用了一个持有信号的对象，并提供了set和check方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class MySignal&#123;</div><div class="line">  </div><div class="line">  protected boolean hasDataToProcess = false;</div><div class="line">  </div><div class="line">  public synchronized boolean hasDataToProcess()&#123;</div><div class="line">    return this.hasDataToProcess;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  public synchronized void setHasDataToProcess(boolean hasData)&#123;</div><div class="line">    this.hasDataToProcess = hasData;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>线程A和B必须获得指向一个MySignal共享实例的引用，以便进行通信。如果它们持有的引用指向不同的MySingal实例，那么彼此将不能检测到对方的信号。需要处理的数据可以存放在一个共享缓存区里，它和MySignal实例是分开存放的。</p>
<h2 id="忙等待-Busy-Wait"><a href="#忙等待-Busy-Wait" class="headerlink" title="忙等待(Busy Wait)"></a>忙等待(Busy Wait)</h2><p>准备处理数据的线程B正在等待数据变为可用。换句话说，它在等待线程A的一个信号，这个信号使hasDataToProcess()返回true。线程B运行在一个循环里，以等待这个信号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">protected MySignal sharedSignal = ...</div><div class="line">...</div><div class="line">while(!sharedSignal.hasDataToProcess())&#123;</div><div class="line">  //do nothing... busy waiting</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="wait-notify-和notifyAll"><a href="#wait-notify-和notifyAll" class="headerlink" title="wait(),notify()和notifyAll()"></a>wait(),notify()和notifyAll()</h2><p>忙等待没有对运行等待线程的CPU进行有效的利用。否则，让等待线程进入睡眠或者非运行状态更为明智，直到它接收到它等待的信号。</p>
<p>忙等待没有对运行等待线程的CPU进行有效的利用，除非平均等待时间非常短。否则，让等待线程进入睡眠或者非运行状态更为明智，直到它接收到它等待的信号。  </p>
<p>Java有一个内建的等待机制来允许线程在等待信号的时候变为非运行状态。java.lang.Object 类定义了三个方法，wait()、notify()和notifyAll()来实现这个等待机制。  </p>
<p>一个线程一旦调用了任意对象的wait()方法，就会变为非运行状态，直到另一个线程调用了同一个对象的notify()方法。为了调用wait()或者notify()，线程必须先获得那个对象的锁。也就是说，线程必须在同步块里调用wait()或者notify()。  </p>
<p>当一个线程调用一个对象的notify()方法，正在等待该对象的所有线程中将有一个线程被唤醒并允许执行（校注：这个将被唤醒的线程是随机的，不可以指定唤醒哪个线程）。同时也提供了一个notifyAll()方法来唤醒正在等待一个给定对象的所有线程。  </p>
<blockquote>
<p>JVM是这么实现的，当你调用wait时候它首先要检查下当前线程是否是锁的拥有者，不是则抛出IllegalMonitorStateExcept，参考JVM源码的 1422行。  </p>
</blockquote>
<p>一旦一个线程被唤醒，不能立刻就退出wait()的方法调用，直到调用notify()的线程退出了它自己的同步块。换句话说：被唤醒的线程必须重新获得监视器对象的锁，才可以退出wait()的方法调用，因为wait方法调用运行在同步块里面。如果多个线程被notifyAll()唤醒，那么在同一时刻将只有一个线程可以退出wait()方法，因为每个线程在退出wait()前必须获得监视器对象的锁。  </p>
<h2 id="丢失的信号（Missed-Signals）"><a href="#丢失的信号（Missed-Signals）" class="headerlink" title="丢失的信号（Missed Signals）"></a>丢失的信号（Missed Signals）</h2><p>notify()和notifyAll()方法不会保存调用它们的方法，因为当这两个方法被调用时，有可能没有线程处于等待状态。通知信号过后便丢弃了。因此，如果一个线程先于被通知线程调用wait()前调用了notify()，等待的线程将错过这个信号。这可能是也可能不是个问题。不过，在某些情况下，这可能使等待线程永远在等待，不再醒来，因为线程错过了唤醒信号。<br>为了避免丢失信号，必须把它们保存在信号类里。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class MyWaitNotify2&#123;</div><div class="line">  </div><div class="line">  MonitorObject myMonitorObject = new MonitorObject();</div><div class="line">  boolean wasSignalled = false;</div><div class="line">  </div><div class="line">  public void doWait()&#123;</div><div class="line">    synchronized(myMonitorObject)&#123;</div><div class="line">      if(!wasSignalled)&#123;</div><div class="line">        try&#123;</div><div class="line">          myMonitorObject.wait();</div><div class="line">         &#125; catch(InterruptedException e)&#123;...&#125;</div><div class="line">      &#125;</div><div class="line">      //clear signal and continue running.</div><div class="line">      wasSignalled = false;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  public void doNotify()&#123;</div><div class="line">    synchronized(myMonitorObject)&#123;</div><div class="line">      wasSignalled = true;</div><div class="line">      myMonitorObject.notify();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>留意doNotify()方法在调用notify()前把wasSignalled变量设为true。同时，留意doWait()方法在调用wait()前会检查wasSignalled变量。事实上，如果没有信号在前一次doWait()调用和这次doWait()调用之间的时间段里被接收到，它将只调用wait()。  </p>
<p>（为了避免信号丢失， 用一个变量来保存是否被通知过。在notify前，设置自己已经被通知过。在wait后，设置自己没有被通知过，需要等待通知。）  </p>
<h2 id="不要在字符串常量或全局对象中调用wait"><a href="#不要在字符串常量或全局对象中调用wait" class="headerlink" title="不要在字符串常量或全局对象中调用wait()"></a>不要在字符串常量或全局对象中调用wait()</h2><p>JVM/编译器内部会把常量字符串转换成同一个对象。这意味着，即使你有2个不同的MyWaitNotify实例，它们都引用了相同的空字符串实例。  </p>
<p>在wait()/notify()机制中，不要使用全局对象，字符串常量等。应该使用对应唯一的对象。  </p>
<p>管程 (Monitors，也称为监视器) 是对多个工作线程实现互斥访问共享资源的对象或模块。这些共享资源一般是硬件设备或一群变量。管程实现了在一个时间点，最多只有一个线程在执行它的某个子程序。与那些通过修改数据结构实现互斥访问的并发程序设计相比，管程很大程度上简化了程序设计。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-同步关键字（synchronized）&quot;&gt;&lt;a href=&quot;#Java-同步关键字（synchronized）&quot; class=&quot;headerlink&quot; title=&quot;Java 同步关键字（synchronized）&quot;&gt;&lt;/a&gt;Java 同步关键字（syn
    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/"/>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>01_Python基础</title>
    <link href="http://yoursite.com/2017/07/16/Backend/Python/Base/01_Python%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2017/07/16/Backend/Python/Base/01_Python基础/</id>
    <published>2017-07-16T07:23:07.000Z</published>
    <updated>2017-07-16T07:23:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python介绍"><a href="#Python介绍" class="headerlink" title="Python介绍"></a>Python介绍</h1><ul>
<li><p>Python适合的领域<br>Web网站和各种网络服务<br>系统工具和脚本<br>作为“胶水”语言把其它语言开发和模块包装起来方便使用  </p>
</li>
<li><p>Python不适合的领域<br>贴近硬件的代码（首选C）<br>移动开发：iOS/Android有各自的开发语言（ObjC,Swift/Java）<br>游戏开发：C/C++</p>
</li>
<li><p>Python和其它语言对比<br>|      |   类型   |   运行速度   |   代码量   |<br>| —- | —- | —- | —- |<br>|   C   |   编译为机器码   |   非常快   |   非常多   |<br>|   Java   |   编译为字节码   |   快   |   多   |<br>|   Python   |   解释执行       |   慢   |   少   |</p>
</li>
</ul>
<ul>
<li>Python源码不能加密  </li>
</ul>
<h1 id="Python文件类型"><a href="#Python文件类型" class="headerlink" title="Python文件类型"></a>Python文件类型</h1><p>Hello.py -&gt; python解释器 -&gt; 字节码文件 -&gt; python解释器 -&gt; 二进制文件 -&gt; 内存、运行 -&gt; 打印结果  </p>
<p>字节码文件：<br>.pyc<br>.pyo  </p>
<p>python -V  </p>
<p>生成pyc文件<br>python -m py_compile hello.py  </p>
<p>python hello.pyc  </p>
<p>生成pyo文件<br>python -o -m py_compile hello.py  </p>
<p>python hello.pyo  </p>
<p>ord(‘A’)<br>65  </p>
<p>chr(66)<br>‘B’  </p>
<p>‘ABC’.encode(‘ascii’)<br>b’ABC’  </p>
<p> b’ABC’.decode(‘ascii’)<br>‘ABC’  </p>
<p>len(‘ABC’)  </p>
<p>float(String)<br>int(String)<br>str(integer)<br>str(float)  </p>
<p>type(var)  </p>
<p><code># -*- coding: utf-8 -*-</code>  </p>
<h1 id="str"><a href="#str" class="headerlink" title="str"></a>str</h1><p>想要分几行输入字符串，并且希望行尾的换行符自动包含到字符串当中，可以使用三对引号：”””…””” 或 ‘’’…’’’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print(&quot;&quot;&quot;\</div><div class="line">... Usage: thingy [OPTIONS]</div><div class="line">...      -h                        Display this usage message</div><div class="line">...      -H hostname               Hostname to connect to</div><div class="line">... &quot;&quot;&quot;)</div><div class="line">Usage: thingy [OPTIONS]</div><div class="line">     -h                        Display this usage message</div><div class="line">     -H hostname               Hostname to connect to</div></pre></td></tr></table></figure></p>
<p>方法 title() 返回字符串的标题版本，即单词首字母大写其余字母小写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;shi yan lou&quot;</div><div class="line">&gt;&gt;&gt; s.title()</div><div class="line">&apos;Shi Yan Lou&apos;</div></pre></td></tr></table></figure></p>
<p>方法 upper() 返回字符串全部大写的版本，反之 lower() 返回字符串的全部小写版本。<br>方法 swapcase() 返回字符串大小写交换后的版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;I am A pRoGraMMer&quot;</div><div class="line">&gt;&gt; s.swapcase()</div><div class="line">&apos;i AM a PrOgRAmmER&apos;</div></pre></td></tr></table></figure></p>
<p>方法 isalnum() 检查所有字符是否为字母数字，字符串 s 中包含空格字符，所以返回 False。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;jdwb 2323bjb&quot;</div><div class="line">&gt;&gt;&gt; s.isalnum()</div><div class="line">False</div><div class="line">&gt;&gt;&gt; s = &quot;jdwb2323bjb&quot;</div><div class="line">&gt;&gt;&gt; s.isalnum()</div><div class="line">True</div></pre></td></tr></table></figure></p>
<p>方法 isalpha() 检查字符串之中是否只有字母。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;SankarshanSir&quot;</div><div class="line">&gt;&gt;&gt; s.isalpha()</div><div class="line">True</div><div class="line">&gt;&gt;&gt; s = &quot;Sankarshan Sir&quot;</div><div class="line">&gt;&gt;&gt; s.isalpha()</div><div class="line">False</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;1234&quot;</div><div class="line">&gt;&gt;&gt; s.isdigit() # 检查字符串是否所有字符为数字</div><div class="line">True</div><div class="line">&gt;&gt;&gt; s = &quot;ShiYanLou is coming&quot;</div><div class="line">&gt;&gt;&gt; s.islower() # 检查字符串是否所有字符为小写</div><div class="line">False</div><div class="line">&gt;&gt;&gt; s = &quot;Shiyanlou Is Coming&quot;</div><div class="line">&gt;&gt;&gt; s.istitle() # To 检查字符串是否为标题样式</div><div class="line">True</div><div class="line">&gt;&gt;&gt; s = &quot;CHINA&quot;</div><div class="line">&gt;&gt;&gt; s.isupper() # 检查字符串是否所有字符为大写</div><div class="line">True</div></pre></td></tr></table></figure>
<p>使用 split() 分割任意字符串，split() 允许有一个参数，用来指定字符串以什么字符分隔（默认为 “ “），它返回一个包含所有分割后的字符串的列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;We all love Python&quot;</div><div class="line">&gt;&gt;&gt; s.split()</div><div class="line">[&apos;We&apos;, &apos;all&apos;, &apos;love&apos;, &apos;Python&apos;]</div><div class="line">&gt;&gt;&gt; x = &quot;shiyanlou:is:waiting&quot;</div><div class="line">&gt;&gt;&gt; x.split(&apos;:&apos;)</div><div class="line">[&apos;shiyanlou&apos;, &apos;is&apos;, &apos;waiting&apos;]</div></pre></td></tr></table></figure></p>
<p>方法 join() 使用指定字符连接多个字符串，它需要一个包含字符串元素的列表作为输入然后连接列表内的字符串元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; &quot;-&quot;.join(&quot;GNU/Linux is great&quot;.split())</div><div class="line">&apos;GNU/Linux-is-great&apos;</div></pre></td></tr></table></figure></p>
<p>strip(chars)，用来剥离字符串首尾中指定的字符，它允许有一个字符串参数，这个参数为剥离哪些字符提供依据。不指定参数则默认剥离掉首尾的空格和换行符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;  a bc\n &quot;</div><div class="line">&gt;&gt;&gt; s.strip()</div><div class="line">&apos;a bc&apos;</div></pre></td></tr></table></figure></p>
<p>使用 lstrip(chars) 或 rstrip(chars) 只对字符串左或右剥离。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;www.foss.in&quot; </div><div class="line">&gt;&gt;&gt; s.lstrip(&quot;cwsd.&quot;) #删除在字符串左边出现的&apos;c&apos;,&apos;w&apos;,&apos;s&apos;,&apos;d&apos;,&apos;.&apos;字符</div><div class="line">&apos;foss.in&apos;</div><div class="line">&gt;&gt;&gt; s.rstrip(&quot;cnwdi.&quot;) #删除在字符串右边出现的&apos;c&apos;,&apos;n&apos;,&apos;w&apos;,&apos;d&apos;,&apos;i&apos;,&apos;.&apos;字符</div><div class="line">&apos;www.foss&apos;</div></pre></td></tr></table></figure></p>
<p>文本搜索<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;faulty for a reason&quot;</div><div class="line">&gt;&gt;&gt; s.find(&quot;for&quot;)</div><div class="line">7</div><div class="line">&gt;&gt;&gt; s.find(&quot;fora&quot;)</div><div class="line">-1</div><div class="line">&gt;&gt;&gt; s.startswith(&quot;fa&quot;) # 检查字符串是否以 fa 开头</div><div class="line">True</div><div class="line">&gt;&gt;&gt; s.endswith(&quot;reason&quot;) # 检查字符串是否以 reason 结尾</div><div class="line">True</div></pre></td></tr></table></figure></p>
<p>回文是一种无论从左还是从右读都一样的字符序列。比如 “madam”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python3</div><div class="line">s = input(&quot;Please enter a string: &quot;)</div><div class="line">z = s[::-1]</div><div class="line">if s == z:</div><div class="line">    print(&quot;The string is a palindrome&quot;)</div><div class="line">else:</div><div class="line">    print(&quot;The string is not a palindrome&quot;)</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python3</div><div class="line">s = input(&quot;Enter a line: &quot;)</div><div class="line">print(&quot;The number of words in the line are %d&quot; % (len(s.split(&quot; &quot;))))</div></pre></td></tr></table></figure>
<p>%d    整数<br>%f    浮点数<br>%s    字符串<br>%x    十六进制整数  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; &apos;Hello, %s&apos; % &apos;world&apos;</div><div class="line">&apos;Hello, world&apos;</div><div class="line">&gt;&gt;&gt; &apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000)</div><div class="line">&apos;Hi, Michael, you have $1000000.&apos;</div><div class="line"></div><div class="line">&gt;&gt;&gt; &apos;%2d-%02d&apos; % (3, 1)</div><div class="line">&apos; 3-01&apos;</div><div class="line">&gt;&gt;&gt; &apos;%.2f&apos; % 3.1415926</div><div class="line">&apos;3.14&apos;</div><div class="line"></div><div class="line">&gt;&gt;&gt; &apos;Age: %s. Gender: %s&apos; % (25, True)</div><div class="line">&apos;Age: 25. Gender: True&apos;</div><div class="line"></div><div class="line">&gt;&gt;&gt; &apos;growth rate: %d %%&apos; % 7</div><div class="line">&apos;growth rate: 7 %&apos;</div></pre></td></tr></table></figure>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; classmates = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</div><div class="line">&gt;&gt;&gt; classmates</div><div class="line">[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</div><div class="line"></div><div class="line">&gt;&gt;&gt; classmates[0]</div><div class="line">&apos;Michael&apos;</div><div class="line">&gt;&gt;&gt; classmates[1]</div><div class="line">&apos;Bob&apos;</div></pre></td></tr></table></figure>
<p>len(list)  </p>
<p>list.append(‘ABC’)</p>
<p>list.insert(0, 111)<br>在列表索引 0 位置添加元素 111  </p>
<p>list.pop()<br>list.pop(i)  </p>
<p>list.count(‘ABC’)<br>列表方法 count(s) 会返回列表元素中 s 的数量。  </p>
<p>list.remove(‘ABC’)<br>在列表中移除任意指定值  </p>
<p>del a[-1]<br>也能使用 del 关键字删除指定位置的列表元素。</p>
<p>list.reverse()<br>反转整个列表  </p>
<p>b=[45, 56, 90]<br>list.extend(b)<br>将一个列表的所有元素添加到另一个列表的末尾  </p>
<p>a.sort()<br>给列表排序，排序的前提是列表的元素是可比较的  </p>
<p>squares = list(map(lambda x: x<strong>2, range(10)))<br>等价于下面的列表推导式。<br>squares = [x</strong>2 for x in range(10)]  </p>
<p>列表推导式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]</div><div class="line">[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]</div></pre></td></tr></table></figure></p>
<h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>元组是由数个逗号分割的值组成。  </p>
<p>tuple一旦初始化就不能修改  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; classmates = (&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;)</div><div class="line">&gt;&gt;&gt; t = (1, 2)</div><div class="line">&gt;&gt;&gt; t</div><div class="line">(1, 2)</div></pre></td></tr></table></figure>
<p>定义一个空的tuple<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; t = ()</div><div class="line">&gt;&gt;&gt; t</div><div class="line">()</div></pre></td></tr></table></figure></p>
<p>定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。</p>
<p>所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; t = (1,)</div><div class="line">&gt;&gt;&gt; t</div><div class="line">(1,)</div><div class="line">```</div></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>t = (‘a’, ‘b’, [‘A’, ‘B’])<br>t[2][0] = ‘X’<br>t[2][1] = ‘Y’<br>t<br>(‘a’, ‘b’, [‘X’, ‘Y’])<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## if</div></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
</blockquote>
<p>if &lt;条件判断1&gt;:<br>    &lt;执行1&gt;<br>elif &lt;条件判断2&gt;:<br>    &lt;执行2&gt;<br>elif &lt;条件判断3&gt;:<br>    &lt;执行3&gt;<br>else:<br>    &lt;执行4&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">int(str) 字符串转数字  </div><div class="line"></div><div class="line">replace</div></pre></td></tr></table></figure></p>
<blockquote>
<blockquote>
<blockquote>
<p>a = ‘abc’<br>b = a.replace(‘a’, ‘A’)<br>b<br>‘Abc’<br>a<br>‘abc’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## for</div></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
</blockquote>
<p>names = [‘Michael’, ‘Bob’, ‘Tracy’]<br>for name in names:<br>    print(name)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">range()函数，可以生成一个整数序列，再通过list()函数可以转换为list</div></pre></td></tr></table></figure></p>
<blockquote>
<blockquote>
<blockquote>
<p>list(range(5))<br>[0, 1, 2, 3, 4]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## while</div></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
</blockquote>
<p>sum = 0<br>n = 99<br>while n &gt; 0:<br>    sum = sum + n<br>    n = n - 2<br>print(sum)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">break  </div><div class="line"></div><div class="line">continue  </div><div class="line"></div><div class="line"></div><div class="line">## dict</div><div class="line">无序的键值对（key:value）集合，同一个字典内的键必须是互不相同的。  </div><div class="line"></div><div class="line">一对大括号 &#123;&#125; 创建一个空字典。</div></pre></td></tr></table></figure></p>
<blockquote>
<blockquote>
<blockquote>
<p>d = {‘Michael’: 95, ‘Bob’: 75, ‘Tracy’: 85}<br>d[‘Michael’]<br>95<br>d[‘test’]=’50’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">dict() 可以从包含键值对的元组中创建字典。</div></pre></td></tr></table></figure></p>
<p>dict(((‘Indian’,’Delhi’),(‘Bangladesh’,’Dhaka’)))<br>{‘Indian’: ‘Delhi’, ‘Bangladesh’: ‘Dhaka’}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">如果你想要遍历一个字典，使用字典的 items() 方法。</div></pre></td></tr></table></figure></p>
<p>data = {‘kushal’:’Fedora’, ‘kart<em>‘:’Debian’, ‘Jace’:’Mac’}<br>for x, y in data.items():<br>…     print(“{} uses {}”.format(x, y))<br>…<br>Kushal uses Fedora<br>Jace uses Mac<br>kart</em> uses Debian<br>parthan uses Ubuntu<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">如果key不存在，dict就会报错：</div><div class="line"></div><div class="line"></div><div class="line">要避免key不存在的错误，有两种办法：</div><div class="line"></div><div class="line">一是通过in判断key是否存在：</div><div class="line">in</div></pre></td></tr></table></figure></p>
<p>‘Thomas’ in d<br>False<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">二是通过dict提供的get方法，如果key不存在，可以返回None，或者自己指定的value：</div><div class="line">get</div></pre></td></tr></table></figure></p>
<p>d.get(‘Thomas’)<br>d.get(‘Thomas’, -1)<br>-1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">pop</div></pre></td></tr></table></figure></p>
<p>d.pop(‘Bob’)<br>75<br>d<br>{‘Michael’: 95, ‘Tracy’: 85}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">使用 del 关键字删除任意指定的键值对：</div></pre></td></tr></table></figure></p>
<p>del d[‘test’]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">必须知道的是，字典中的键必须是不可变类型，比如你不能使用列表作为键。  </div><div class="line"></div><div class="line">dict.setdefault(key, default)  </div><div class="line">往字典中的元素添加数据，我们首先要判断这个元素是否存在，不存在则创建一个默认值。</div></pre></td></tr></table></figure></p>
<p>data = {}<br>data.setdefault(‘names’, []).append(‘Ruby’)<br>data<br>{‘names’: [‘Ruby’]}<br>data.setdefault(‘names’, []).append(‘Python’)<br>data<br>{‘names’: [‘Ruby’, ‘Python’]}<br>data.setdefault(‘names’, []).append(‘C’)<br>data<br>{‘names’: [‘Ruby’, ‘Python’, ‘C’]}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">试图索引一个不存在的键将会抛出一个 keyError 错误。我们可以使用 dict.get(key, default) 来索引键，如果键不存在，那么返回指定的 default 值。</div></pre></td></tr></table></figure></p>
<p>data[‘foo’]<br>Traceback (most recent call last):<br>File “<stdin>“, line 1, in <module><br>KeyError: ‘foo’<br>data.get(‘foo’, 0)<br>0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在遍历列表（或任何序列类型）的同时获得元素索引值，你可以使用 enumerate()。</div></pre></td></tr></table></figure></module></stdin></p>
<p>for i, j in enumerate([‘a’, ‘b’, ‘c’]):<br>…     print(i, j)<br>…<br>0 a<br>1 b<br>2 c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">同时遍历两个序列类型，可以使用 zip() 函数。</div></pre></td></tr></table></figure></p>
<p>a = [‘Pradeepto’, ‘Kushal’]<br>b = [‘OpenSUSE’, ‘Fedora’]<br>for x, y in zip(a, b):<br>…     print(“{} uses {}”.format(x, y))<br>…<br>Pradeepto uses OpenSUSE<br>Kushal uses Fedora<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## set</div><div class="line">set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。  </div><div class="line"></div><div class="line">大括号或 set() 函数可以用来创建集合。注意：想要创建空集合，你必须使用 set() 而不是 &#123;&#125;。  </div><div class="line">  </div><div class="line">要创建一个set，需要提供一个list作为输入集合：</div></pre></td></tr></table></figure></p>
<p>s = set([1, 1, 2, 2, 3, 3])<br>s<br>{1, 2, 3}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">add</div></pre></td></tr></table></figure></p>
<p>s.add(4)<br>s<br>{1, 2, 3, 4}<br>s.add(4)<br>s<br>{1, 2, 3, 4}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">pop</div></pre></td></tr></table></figure></p>
<p>s.pop()<br>1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">remove</div></pre></td></tr></table></figure></p>
<p>s.remove(4)<br>s<br>{1, 2, 3}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">&amp;   |</div></pre></td></tr></table></figure></p>
<p>s1 = set([1, 2, 3])<br>s2 = set([2, 3, 4])<br>s1 &amp; s2<br>{2, 3}<br>s1 | s2<br>{1, 2, 3, 4}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">演示对两个单词中的字母进行集合操作</div></pre></td></tr></table></figure></p>
<p>a = set(‘abracadabra’)<br>b = set(‘alacazam’)<br>a                                  # a 去重后的字母<br>{‘a’, ‘r’, ‘b’, ‘c’, ‘d’}<br>a - b                              # a 有而 b 没有的字母<br>{‘r’, ‘d’, ‘b’}<br>a | b                              # 存在于 a 或 b 的字母<br>{‘a’, ‘c’, ‘r’, ‘d’, ‘b’, ‘m’, ‘z’, ‘l’}<br>a &amp; b                              # a 和 b 都有的字母<br>{‘a’, ‘c’}<br>a ^ b                              # 存在于 a 或 b 但不同时存在的字母<br>{‘r’, ‘d’, ‘b’, ‘m’, ‘z’, ‘l’}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">in</div></pre></td></tr></table></figure></p>
<p>basket = {‘apple’, ‘orange’, ‘apple’, ‘pear’, ‘orange’, ‘banana’}<br>print(basket)                      # 你可以看到重复的元素被去除<br>{‘orange’, ‘banana’, ‘pear’, ‘apple’}<br>‘orange’ in basket<br>True<br>‘crabgrass’ in basket<br>False<br>```</p>
</blockquote>
</blockquote>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python介绍&quot;&gt;&lt;a href=&quot;#Python介绍&quot; class=&quot;headerlink&quot; title=&quot;Python介绍&quot;&gt;&lt;/a&gt;Python介绍&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Python适合的领域&lt;br&gt;Web网站和各种网络服务&lt;br&gt;系统工具和脚
    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Python/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Python/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>02_Python函数</title>
    <link href="http://yoursite.com/2017/07/16/Backend/Python/Base/02_%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2017/07/16/Backend/Python/Base/02_函数/</id>
    <published>2017-07-16T07:23:07.000Z</published>
    <updated>2017-07-16T07:23:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python内置函数"><a href="#Python内置函数" class="headerlink" title="Python内置函数"></a>Python内置函数</h1><p><a href="http://docs.python.org/3/library/functions.html#abs" target="_blank" rel="external">http://docs.python.org/3/library/functions.html#abs</a>  </p>
<p>以在交互式命令行通过help(abs)查看abs函数的帮助信息。  </p>
<p>abs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; abs(100)</div><div class="line">100</div><div class="line">&gt;&gt;&gt; abs(-20)</div><div class="line">20</div><div class="line">&gt;&gt;&gt; abs(12.34)</div><div class="line">12.34</div></pre></td></tr></table></figure></p>
<p>max<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; max(1, 2)</div><div class="line">2</div><div class="line">&gt;&gt;&gt; max(2, 3, 1, -5)</div><div class="line">3</div></pre></td></tr></table></figure></p>
<h1 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; int(&apos;123&apos;)</div><div class="line">123</div><div class="line">&gt;&gt;&gt; int(12.34)</div><div class="line">12</div><div class="line">&gt;&gt;&gt; float(&apos;12.34&apos;)</div><div class="line">12.34</div><div class="line">&gt;&gt;&gt; str(1.23)</div><div class="line">&apos;1.23&apos;</div><div class="line">&gt;&gt;&gt; str(100)</div><div class="line">&apos;100&apos;</div><div class="line">&gt;&gt;&gt; bool(1)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; bool(&apos;&apos;)</div><div class="line">False</div></pre></td></tr></table></figure>
<p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = abs # 变量a指向abs函数</div><div class="line">&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数</div><div class="line">1</div></pre></td></tr></table></figure></p>
<h1 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h1><p>在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def my_abs(x):</div><div class="line">    if x &gt;= 0:</div><div class="line">        return x</div><div class="line">    else:</div><div class="line">        return -x</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。  </p>
</blockquote>
<p>如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。  </p>
<p>return None可以简写为return  </p>
<p>如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python解释器，用from abstest import my_abs来导入my_abs()函数，注意abstest是文件名（不含.py扩展名）：</p>
<h1 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h1><p>如果想定义一个什么事也不做的空函数，可以用pass语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def nop():</div><div class="line">    pass</div></pre></td></tr></table></figure></p>
<p>实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。</p>
<p>pass还可以用在其他语句里，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if age &gt;= 18:</div><div class="line">    pass</div></pre></td></tr></table></figure></p>
<p>缺少了pass，代码运行就会有语法错误。</p>
<h1 id="参数检查"><a href="#参数检查" class="headerlink" title="参数检查"></a>参数检查</h1><p>调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError：</p>
<p>如果参数类型不对，Python解释器就无法帮我们检查。试试my_abs和内置函数abs的差别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; my_abs(&apos;A&apos;)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 2, in my_abs</div><div class="line">TypeError: unorderable types: str() &gt;= int()</div><div class="line">&gt;&gt;&gt; abs(&apos;A&apos;)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">TypeError: bad operand type for abs(): &apos;str&apos;</div></pre></td></tr></table></figure></p>
<p>数据类型检查可以用内置函数isinstance()实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def my_abs(x):</div><div class="line">    if not isinstance(x, (int, float)):</div><div class="line">        raise TypeError(&apos;bad operand type&apos;)</div><div class="line">    if x &gt;= 0:</div><div class="line">        return x</div><div class="line">    else:</div><div class="line">        return -x</div></pre></td></tr></table></figure></p>
<p>如果传入错误的参数类型，函数就可以抛出一个错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; my_abs(&apos;A&apos;)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 3, in my_abs</div><div class="line">TypeError: bad operand type</div></pre></td></tr></table></figure></p>
<h1 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import math</div><div class="line"></div><div class="line">def move(x, y, step, angle=0):</div><div class="line">    nx = x + step * math.cos(angle)</div><div class="line">    ny = y - step * math.sin(angle)</div><div class="line">    return nx, ny</div></pre></td></tr></table></figure>
<p>import math语句表示导入math包，并允许后续代码引用math包里的sin、cos等函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)</div><div class="line">&gt;&gt;&gt; print(x, y)</div><div class="line">151.96152422706632 70.0</div></pre></td></tr></table></figure>
<p>Python函数返回的仍然是单一值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)</div><div class="line">&gt;&gt;&gt; print(r)</div><div class="line">(151.96152422706632, 70.0)</div></pre></td></tr></table></figure></p>
<p>返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。  </p>
<h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def power(x, n=2):</div><div class="line">    s = 1</div><div class="line">    while n &gt; 0:</div><div class="line">        n = n - 1</div><div class="line">        s = s * x</div><div class="line">    return s</div></pre></td></tr></table></figure>
<p>设置默认参数时，有几点要注意：</p>
<ol>
<li><p>必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；  </p>
</li>
<li><p>如何设置默认参数。<br>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</p>
</li>
</ol>
<p>默认参数很有用，但使用不当，也会掉坑里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">def add_end(L=[]):</div><div class="line">    L.append(&apos;END&apos;)</div><div class="line">    return L</div><div class="line">  </div><div class="line">&gt;&gt;&gt; add_end([1, 2, 3])</div><div class="line">[1, 2, 3, &apos;END&apos;]</div><div class="line">&gt;&gt;&gt; add_end([&apos;x&apos;, &apos;y&apos;, &apos;z&apos;])</div><div class="line">[&apos;x&apos;, &apos;y&apos;, &apos;z&apos;, &apos;END&apos;]</div><div class="line">  </div><div class="line">&gt;&gt;&gt; add_end()</div><div class="line">[&apos;END&apos;]</div><div class="line">  </div><div class="line">&gt;&gt;&gt; add_end()</div><div class="line">[&apos;END&apos;, &apos;END&apos;]</div><div class="line">&gt;&gt;&gt; add_end()</div><div class="line">[&apos;END&apos;, &apos;END&apos;, &apos;END&apos;]</div></pre></td></tr></table></figure></p>
<p>原因解释如下：  </p>
<p>Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。  </p>
<p>所以，定义默认参数要牢记一点：默认参数必须指向不变对象！  </p>
<p>可以用None这个不变对象来实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def add_end(L=None):</div><div class="line">    if L is None:</div><div class="line">        L = []</div><div class="line">    L.append(&apos;END&apos;)</div><div class="line">    return L</div></pre></td></tr></table></figure></p>
<h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><p>参数个数可变  </p>
<p>组装出一个list或tuple：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">def calc(numbers):</div><div class="line">    sum = 0</div><div class="line">    for n in numbers:</div><div class="line">        sum = sum + n * n</div><div class="line">    return sum</div><div class="line">  </div><div class="line">&gt;&gt;&gt; calc([1, 2, 3])</div><div class="line">14</div><div class="line">&gt;&gt;&gt; calc((1, 3, 5, 7))</div><div class="line">84</div></pre></td></tr></table></figure></p>
<p>可变参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def calc(*numbers):</div><div class="line">    sum = 0</div><div class="line">    for n in numbers:</div><div class="line">        sum = sum + n * n</div><div class="line">    return sum</div></pre></td></tr></table></figure></p>
<p>定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：  </p>
<p>如果已经有一个list或者tuple，要调用一个可变参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; nums = [1, 2, 3]</div><div class="line">&gt;&gt;&gt; calc(nums[0], nums[1], nums[2])</div><div class="line">14</div></pre></td></tr></table></figure></p>
<p>Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; nums = [1, 2, 3]</div><div class="line">&gt;&gt;&gt; calc(*nums)</div><div class="line">14</div></pre></td></tr></table></figure></p>
<h1 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h1><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">def person(name, age, **kw):</div><div class="line">    print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw)</div><div class="line">  </div><div class="line">&gt;&gt;&gt; person(&apos;Michael&apos;, 30)</div><div class="line">name: Michael age: 30 other: &#123;&#125;</div><div class="line">  </div><div class="line">&gt;&gt;&gt; person(&apos;Bob&apos;, 35, city=&apos;Beijing&apos;)</div><div class="line">name: Bob age: 35 other: &#123;&apos;city&apos;: &apos;Beijing&apos;&#125;</div><div class="line">&gt;&gt;&gt; person(&apos;Adam&apos;, 45, gender=&apos;M&apos;, job=&apos;Engineer&apos;)</div><div class="line">name: Adam age: 45 other: &#123;&apos;gender&apos;: &apos;M&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</div><div class="line">  </div><div class="line">&gt;&gt;&gt; extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</div><div class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, city=extra[&apos;city&apos;], job=extra[&apos;job&apos;])</div><div class="line">name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</div><div class="line">  </div><div class="line">&gt;&gt;&gt; extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</div><div class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, **extra)</div><div class="line">name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</div></pre></td></tr></table></figure>
<p><code>**extra</code>表示把extra这个dict的所有key-value用关键字参数传入到函数的<code>**kw</code>参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。</p>
<h1 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h1><p>如果要限制关键字参数的名字，就可以用命名关键字参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def person(name, age, *, city, job):</div><div class="line">    print(name, age, city, job)</div><div class="line">  </div><div class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, city=&apos;Beijing&apos;, job=&apos;Engineer&apos;)</div><div class="line">Jack 24 Beijing Engineer</div></pre></td></tr></table></figure></p>
<p>和关键字参数<em>*kw不同，命名关键字参数需要一个特殊分隔符</em>，*后面的参数被视为命名关键字参数。  </p>
<p>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：  </p>
<p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def person(name, age, *args, city, job):</div><div class="line">    print(name, age, args, city, job)</div></pre></td></tr></table></figure></p>
<p>命名关键字参数可以有缺省值，从而简化调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def person(name, age, *, city=&apos;Beijing&apos;, job):</div><div class="line">    print(name, age, city, job)</div><div class="line">  </div><div class="line"># 命名关键字参数city具有默认值，调用时，可不传入city参数  </div><div class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, job=&apos;Engineer&apos;)</div><div class="line">Jack 24 Beijing Engineer</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def person(name, age, city, job):</div><div class="line">    # 缺少 *，city和job被视为位置参数</div><div class="line">    pass</div></pre></td></tr></table></figure>
<h1 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h1><p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。  </p>
<p>但是请注意，参数定义的顺序必须是：<br><strong>必选参数、默认参数、可变参数、命名关键字参数和关键字参数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def f1(a, b, c=0, *args, **kw):</div><div class="line">    print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;args =&apos;, args, &apos;kw =&apos;, kw)</div><div class="line"></div><div class="line">def f2(a, b, c=0, *, d, **kw):</div><div class="line">    print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;d =&apos;, d, &apos;kw =&apos;, kw)</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; f1(1, 2)</div><div class="line">a = 1 b = 2 c = 0 args = () kw = &#123;&#125;</div><div class="line">&gt;&gt;&gt; f1(1, 2, c=3)</div><div class="line">a = 1 b = 2 c = 3 args = () kw = &#123;&#125;</div><div class="line">&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;)</div><div class="line">a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = &#123;&#125;</div><div class="line">&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;, x=99)</div><div class="line">a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = &#123;&apos;x&apos;: 99&#125;</div><div class="line">&gt;&gt;&gt; f2(1, 2, d=99, ext=None)</div><div class="line">a = 1 b = 2 c = 0 d = 99 kw = &#123;&apos;ext&apos;: None&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; args = (1, 2, 3, 4)</div><div class="line">&gt;&gt;&gt; kw = &#123;&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;&#125;</div><div class="line">&gt;&gt;&gt; f1(*args, **kw)</div><div class="line">a = 1 b = 2 c = 3 args = (4,) kw = &#123;&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;&#125;</div><div class="line">&gt;&gt;&gt; args = (1, 2, 3)</div><div class="line">&gt;&gt;&gt; kw = &#123;&apos;d&apos;: 88, &apos;x&apos;: &apos;#&apos;&#125;</div><div class="line">&gt;&gt;&gt; f2(*args, **kw)</div><div class="line">a = 1 b = 2 c = 3 d = 88 kw = &#123;&apos;x&apos;: &apos;#&apos;&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python内置函数&quot;&gt;&lt;a href=&quot;#Python内置函数&quot; class=&quot;headerlink&quot; title=&quot;Python内置函数&quot;&gt;&lt;/a&gt;Python内置函数&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://docs.python.org/3/libr
    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Python/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Python/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>11_Linux 正则表达式</title>
    <link href="http://yoursite.com/2017/07/07/Linux/Base/11_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F(grep,sed,awk)/"/>
    <id>http://yoursite.com/2017/07/07/Linux/Base/11_正则表达式(grep,sed,awk)/</id>
    <published>2017-07-07T12:59:47.000Z</published>
    <updated>2017-07-07T12:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><blockquote>
<p>正则表达式，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法（英语：Regular Expression，在代码中常简写为 regex、regexp 或 RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。</p>
<p>许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在 Perl 中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由 UNIX 中的工具软件（例如sed和grep）普及开的。正则表达式通常缩写成“regex”，单数有 regexp、regex，复数有 regexps、regexes、regexen。</p>
</blockquote>
<p>简单的说形式和功能上正则表达式和通配符很像，不过它们之间又有很大差别，特别在于一些特殊的匹配字符的含义上，注意不要将两者弄混淆。</p>
<h1 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h1><p>一个正则表达式通常被称为一个模式（pattern），为用来描述或者匹配一系列符合某个句法规则的字符串。  </p>
<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>|竖直分隔符表示选择，例如”boy|girl”可以匹配”boy”或者”girl”  </p>
<h2 id="数量限定"><a href="#数量限定" class="headerlink" title="数量限定"></a>数量限定</h2><p>数量限定除了我们举例用的*,还有+加号,?问号,如果在一个模式中不加数量限定符则表示出现一次且仅出现一次：  </p>
<p><code>+</code>表示前面的字符必须出现至少一次(1次或多次)，例如，”goo+gle”,可以匹配”gooogle”,”goooogle”等；  </p>
<p><code>?</code>表示前面的字符最多出现一次(0次或1次)，例如，”colou?r”,可以匹配”color”或者”colour”;  </p>
<p><code>*</code>星号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次），例如，“0*42”可以匹配42、042、0042、00042等。  </p>
<h2 id="范围和优先级"><a href="#范围和优先级" class="headerlink" title="范围和优先级"></a>范围和优先级</h2><p>()圆括号可以用来定义模式字符串的范围和优先级，这可以简单的理解为是否将括号内的模式串作为一个整体。例如，”gr(a|e)y”等价于”gray|grey”，（这里体现了优先级，竖直分隔符用于选择a或者e而不是gra和ey），”(grand)?father”匹配father和grandfather（这里体验了范围，?将圆括号内容作为一个整体匹配）。</p>
<h2 id="语法（部分）"><a href="#语法（部分）" class="headerlink" title="语法（部分）"></a>语法（部分）</h2><p>正则表达式有多种不同的风格，下面列举一些常用的作为 PCRE 子集的适用于perl和python编程语言及grep或egrep的正则表达式匹配规则：(由于markdown表格解析的问题，下面的竖直分隔符用全角字符代替，实际使用时请换回半角字符)</p>
<blockquote>
<p>PCRE（Perl Compatible Regular Expressions中文含义：perl语言兼容正则表达式）是一个用 C 语言编写的正则表达式函数库，由菲利普.海泽(Philip Hazel)编写。PCRE是一个轻量级的函数库，比Boost 之类的正则表达式库小得多。PCRE 十分易用，同时功能也很强大，性能超过了 POSIX 正则表达式库和一些经典的正则表达式库。</p>
</blockquote>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\</td>
<td>将下一个字符标记为一个特殊字符、或一个原义字符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。序列“\”匹配“\”而“(”则匹配“(”。</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字符串的开始位置。</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串的结束位置。</td>
</tr>
<tr>
<td>{n}</td>
<td>n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。</td>
</tr>
<tr>
<td>{n,}</td>
<td>n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次。例如，zo<em>能匹配“z”、“zo”以及“zoo”。</em>等价于{0,}。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。</td>
</tr>
<tr>
<td>?</td>
<td>当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。</td>
</tr>
<tr>
<td>.</td>
<td>匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“(.｜\n)”的模式。</td>
</tr>
<tr>
<td>(pattern)</td>
<td>匹配pattern并获取这一匹配的子字符串。该子字符串用于向后引用。要匹配圆括号字符，请使用“(”或“)”。</td>
</tr>
<tr>
<td>x｜y</td>
<td>匹配x或y。例如，“z｜food”能匹配“z”或“food”。“(z｜f)ood”则匹配“zood”或“food”。</td>
</tr>
<tr>
<td>[xyz]</td>
<td>字符集合（character class）。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。其中特殊字符仅有反斜线\保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符^如果出现在首位则表示负值字符集合；如果出现在字符串中间就仅作为普通字符。连字符 - 如果出现在字符串中间表示字符范围描述；如果如果出现在首位则仅作为普通字符。</td>
</tr>
<tr>
<td>[^xyz]</td>
<td>排除型（negate）字符集合。匹配未列出的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。</td>
</tr>
<tr>
<td>[a-z]</td>
<td>字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。</td>
</tr>
<tr>
<td>[^a-z]</td>
<td>排除型的字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。</td>
</tr>
</tbody>
</table>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>优先级为从上到下从左到右，依次降低：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\</td>
<td>转义符</td>
</tr>
<tr>
<td>(), (?:), (?=), []</td>
<td>括号和中括号</td>
</tr>
<tr>
<td>*、+、?、{n}、{n,}、{n,m}</td>
<td>限定符</td>
</tr>
<tr>
<td>^、$、\任何元字符</td>
<td>定位点和序列</td>
</tr>
<tr>
<td>｜</td>
<td>选择</td>
</tr>
</tbody>
</table>
<p><img src="http://i.imgur.com/nLrwGjl.png" alt="">  </p>
<h1 id="grep模式匹配命令"><a href="#grep模式匹配命令" class="headerlink" title="grep模式匹配命令"></a>grep模式匹配命令</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>grep命令用于打印输出文本中匹配的模式串，它使用正则表达式作为模式匹配的条件。grep支持三种正则表达式引擎，分别用三个参数指定：  </p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-E</td>
<td>POSIX扩展正则表达式，ERE</td>
</tr>
<tr>
<td>-G</td>
<td>POSIX基本正则表达式，BRE</td>
</tr>
<tr>
<td>-P</td>
<td>Perl正则表达式，PCRE</td>
</tr>
</tbody>
</table>
<p>常用参数：<br>|   参数   |   说明   |<br>| —- | —- |<br>|   -b   |   将二进制文件作为文本来进行匹配   |<br>|   -c   |   统计以模式匹配的数目   |<br>|   -i   |   忽略大小写   |<br>|   -n   |   显示匹配文本所在行的行号   |<br>|   -v   |   反选，输出不匹配行的内容   |<br>|   -r   |   递归匹配查找   |<br>|   -A n   |   n为正整数，表示after的意思，除了列出匹配行之外，还列出后面的n行   |<br>|   -B n   |   n为正整数，表示before的意思，除了列出匹配行之外，还列出前面的n行   |<br>|   –color=auto       |   将输出中的匹配项设置为自动颜色显示   |</p>
<blockquote>
<p>注：在大多数发行版中是默认设置了grep的颜色的，你可以通过参数指定或修改GREP_COLOR环境变量。</p>
</blockquote>
<p><img src="http://i.imgur.com/6HItTj4.png" alt="">  </p>
<h2 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h2><p>使用基本正则表达式，BRE</p>
<ul>
<li>位置<br>查找/etc/group文件中以”shiyanlou”为开头的行<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ grep &apos;shiyanlou&apos; /etc/group</div><div class="line">$ grep &apos;^shiyanlou&apos; /etc/group</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://i.imgur.com/rcxB4jB.png" alt="">  </p>
<ul>
<li>数量<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 将匹配以&apos;z&apos;开头以&apos;o&apos;结尾的所有字符串</div><div class="line">$ echo &apos;zero\nzo\nzoo&apos; | grep &apos;z.*o&apos;</div><div class="line"># 将匹配以&apos;z&apos;开头以&apos;o&apos;结尾，中间包含一个任意字符的字符串</div><div class="line">$ echo &apos;zero\nzo\nzoo&apos; | grep &apos;z.o&apos;</div><div class="line"># 将匹配以&apos;z&apos;开头,以任意多个&apos;o&apos;结尾的字符串</div><div class="line">$ echo &apos;zero\nzo\nzoo&apos; | grep &apos;zo*&apos;</div><div class="line">注意：其中\n为换行符</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>注意：其中\n为换行符</p>
</blockquote>
<p><img src="http://i.imgur.com/n9CXqfL.png" alt="">  </p>
<ul>
<li>选择<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># grep默认是区分大小写的，这里将匹配所有的小写字母</div><div class="line">$ echo &apos;1234\nabcd&apos; | grep &apos;[a-z]&apos;</div><div class="line"># 将匹配所有的数字</div><div class="line">$ echo &apos;1234\nabcd&apos; | grep &apos;[0-9]&apos;</div><div class="line"># 将匹配所有的数字</div><div class="line">$ echo &apos;1234\nabcd&apos; | grep &apos;[[:digit:]]&apos;</div><div class="line"># 将匹配所有的小写字母</div><div class="line">$ echo &apos;1234\nabcd&apos; | grep &apos;[[:lower:]]&apos;</div><div class="line"># 将匹配所有的大写字母</div><div class="line">$ echo &apos;1234\nabcd&apos; | grep &apos;[[:upper:]]&apos;</div><div class="line"># 将匹配所有的字母和数字，包括0-9,a-z,A-Z</div><div class="line">$ echo &apos;1234\nabcd&apos; | grep &apos;[[:alnum:]]&apos;</div><div class="line"># 将匹配所有的字母</div><div class="line">$ echo &apos;1234\nabcd&apos; | grep &apos;[[:alpha:]]&apos;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://i.imgur.com/PQ21eYo.png" alt="">  </p>
<p>下面包含完整的特殊符号及说明：  </p>
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[:alnum:]</code></td>
<td>代表英文大小写字节及数字，亦即 0-9, A-Z, a-z</td>
</tr>
<tr>
<td><code>[:alpha:]</code></td>
<td>代表任何英文大小写字节，亦即 A-Z, a-z</td>
</tr>
<tr>
<td><code>[:blank:]</code></td>
<td>代表空白键与 [Tab] 按键两者</td>
</tr>
<tr>
<td><code>[:cntrl:]</code></td>
<td>代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等</td>
</tr>
<tr>
<td><code>[:digit:]</code></td>
<td>代表数字而已，亦即 0-9</td>
</tr>
<tr>
<td><code>[:graph:]</code></td>
<td>除了空白字节 (空白键与 [Tab] 按键) 外的其他所有按键</td>
</tr>
<tr>
<td><code>[:lower:]</code></td>
<td>代表小写字节，亦即 a-z</td>
</tr>
<tr>
<td><code>[:print:]</code></td>
<td>代表任何可以被列印出来的字节</td>
</tr>
<tr>
<td><code>[:punct:]</code></td>
<td>代表标点符号 (punctuation symbol)，亦即：” ‘ ? ! ; : # $…</td>
</tr>
<tr>
<td><code>[:upper:]</code></td>
<td>代表大写字节，亦即 A-Z</td>
</tr>
<tr>
<td><code>[:space:]</code></td>
<td>任何会产生空白的字节，包括空白键, [Tab], CR 等等</td>
</tr>
<tr>
<td><code>[:xdigit:]</code></td>
<td>代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字节</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：之所以要使用特殊符号，是因为上面的[a-z]不是在所有情况下都管用，这还与主机当前的语系有关，即设置在LANG环境变量的值，zh_CN.UTF-8的话[a-z]，即为所有小写字母，其它语系可能是大小写交替的如，”a A b B…z Z”，[a-z]中就可能包含大写字母。所以在使用[a-z]时请确保当前语系的影响，使用[:lower:]则不会有这个问题。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 排除字符</div><div class="line">$ echo &apos;geek|good&apos; | grep &apos;[^o]&apos;</div><div class="line">注意:当^放到中括号内为排除字符，否则表示行首。</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/vAUHquV.png" alt="">  </p>
<h2 id="使用扩展正则表达式，ERE"><a href="#使用扩展正则表达式，ERE" class="headerlink" title="使用扩展正则表达式，ERE"></a>使用扩展正则表达式，ERE</h2><p>要通过grep使用扩展正则表达式需要加上-E参数，或使用egrep。</p>
<ul>
<li>数量<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 只匹配&quot;zo&quot;</div><div class="line">$ echo &apos;zero\nzo\nzoo&apos; | grep -E &apos;zo&#123;1&#125;&apos;</div><div class="line"># 匹配以&quot;zo&quot;开头的所有单词</div><div class="line">$ echo &apos;zero\nzo\nzoo&apos; | grep -E &apos;zo&#123;1,&#125;&apos;</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>注意：推荐掌握{n,m}即可，+,?,*，这几个不太直观，且容易弄混淆。  </p>
</blockquote>
<ul>
<li>选择<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 匹配&quot;www.shiyanlou.com&quot;和&quot;www.google.com&quot;</div><div class="line">$ echo &apos;www.shiyanlou.com\nwww.baidu.com\nwww.google.com&apos; | grep -E &apos;www\.(shiyanlou|google)\.com&apos;</div><div class="line"># 或者匹配不包含&quot;baidu&quot;的内容</div><div class="line">$ echo &apos;www.shiyanlou.com\nwww.baidu.com\nwww.google.com&apos; | grep -Ev &apos;www\.baidu\.com&apos;</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>注意：因为.号有特殊含义，所以需要转义。  </p>
</blockquote>
<h1 id="sed-流编辑器"><a href="#sed-流编辑器" class="headerlink" title="sed 流编辑器"></a>sed 流编辑器</h1><p>sed工具在 man 手册里面的全名为”sed - stream editor for filtering and transforming text”，意即，用于过滤和转换文本的流编辑器。</p>
<p>在 Linux/UNIX 的世界里敢称为编辑器的工具，大都非等闲之辈，比如前面的”vi/vim(编辑器之神)”,”emacs(神的编辑器)”,”gedit”这些个编辑器。sed与上述的最大不同之处在于它是一个非交互式的编辑器。</p>
<h2 id="sed常用参数介绍"><a href="#sed常用参数介绍" class="headerlink" title="sed常用参数介绍"></a>sed常用参数介绍</h2><p>sed 命令基本格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sed [参数]... [执行命令] [输入文件]...</div><div class="line"># 形如：</div><div class="line">$ sed -i &apos;1s/sad/happy/&apos; test # 表示将test文件中第一行的&quot;sad&quot;替换为&quot;happy&quot;</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-n</td>
<td>安静模式，只打印受影响的行，默认打印输入数据的全部内容</td>
</tr>
<tr>
<td>-e</td>
<td>用于在脚本中添加多个执行命令一次执行，在命令行中执行多个命令通常不需要加该参数</td>
</tr>
<tr>
<td>-f filename</td>
<td>指定执行filename文件中的命令</td>
</tr>
<tr>
<td>-r</td>
<td>使用扩展正则表达式，默认为标准正则表达式</td>
</tr>
<tr>
<td>-i</td>
<td>将直接修改输入文件内容，而不是打印到标准输出设备</td>
</tr>
</tbody>
</table>
<h2 id="sed编辑器的执行命令"><a href="#sed编辑器的执行命令" class="headerlink" title="sed编辑器的执行命令"></a>sed编辑器的执行命令</h2><p>sed执行命令格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[n1][,n2]command</div><div class="line">[n1][~step]command</div><div class="line"># 其中一些命令可以在后面加上作用范围，形如：</div><div class="line">$ sed -i &apos;s/sad/happy/g&apos; test # g表示全局范围</div><div class="line">$ sed -i &apos;s/sad/happy/4&apos; test # 4表示指定行中的第四个匹配字符串</div></pre></td></tr></table></figure></p>
<p>其中n1,n2表示输入内容的行号，它们之间为,逗号则表示从n1到n2行，如果为～波浪号则表示从n1开始以step为步进的所有行；command为执行动作，下面为一些常用动作指令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s</td>
<td>行内替换</td>
</tr>
<tr>
<td>c</td>
<td>整行替换</td>
</tr>
<tr>
<td>a</td>
<td>插入到指定行的后面</td>
</tr>
<tr>
<td>i</td>
<td>插入到指定行的前面</td>
</tr>
<tr>
<td>p</td>
<td>打印指定行，通常与-n参数配合使用</td>
</tr>
<tr>
<td>d</td>
<td>删除指定行</td>
</tr>
</tbody>
</table>
<h2 id="sed操作举例"><a href="#sed操作举例" class="headerlink" title="sed操作举例"></a>sed操作举例</h2><p>先找一个用于练习的文本文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cp /etc/passwd ~\</div></pre></td></tr></table></figure></p>
<p><strong>打印指定行</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 打印2-5行</div><div class="line">$ nl passwd | sed -n &apos;2,5p&apos;</div><div class="line"># 打印奇数行</div><div class="line">$ nl passwd | sed -n &apos;1~2p&apos;</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/QtzEtzP.png" alt="">  </p>
<p><strong>行内替换</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 将输入文本中&quot;shiyanlou&quot; 全局替换为&quot;hehe&quot;,并只打印替换的那一行，注意这里不能省略最后的&quot;p&quot;命令</div><div class="line">$ sed -n &apos;s/shiyanlou/hehe/gp&apos; passwd</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意： 行内替换可以结合正则表达式使用。</p>
</blockquote>
<p><strong>行间替换</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ nl passwd | grep &quot;shiyanlou&quot;</div><div class="line"># 删除第21行</div><div class="line">$ sed -n &apos;21c\www.shiyanlou.com&apos; passwd</div><div class="line">（这里我们只把要删的行打印出来了，并没有真正的删除，如果要删除的话，请使用-i参数）</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/UImKOok.png" alt="">  </p>
<h1 id="行间替换"><a href="#行间替换" class="headerlink" title="行间替换"></a>行间替换</h1><h2 id="awk介绍"><a href="#awk介绍" class="headerlink" title="awk介绍"></a>awk介绍</h2><blockquote>
<p>AWK是一种优良的文本处理工具，Linux及Unix环境中现有的功能最强大的数据处理引擎之一.其名称得自于它的创始人Alfred Aho（阿尔佛雷德·艾侯）、Peter Jay Weinberger（彼得·温伯格）和Brian Wilson Kernighan（布莱恩·柯林汉)姓氏的首个字母.AWK程序设计语言，三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。最简单地说，AWK是一种用于处理文本的编程语言工具。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ll /usr/bin/awk</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/5BGW3xD.png" alt="">  </p>
<blockquote>
<p>nawk： 在 20 世纪 80 年代中期，对 awk语言进行了更新，并不同程度地使用一种称为 nawk(new awk) 的增强版本对其进行了替换。许多系统中仍然存在着旧的awk 解释器，但通常将其安装为 oawk (old awk) 命令，而 nawk 解释器则安装为主要的 awk 命令，也可以使用 nawk 命令。Dr. Kernighan 仍然在对 nawk 进行维护，与 gawk 一样，它也是开放源代码的，并且可以免费获得;</p>
<p>gawk： 是 GNU Project 的awk解释器的开放源代码实现。尽管早期的 GAWK 发行版是旧的 AWK 的替代程序，但不断地对其进行了更新，以包含 NAWK 的特性;</p>
<p>mawk 也是awk编程语言的一种解释器，mawk遵循 POSIX 1003.2 （草案 11.3）定义的 AWK 语言，包含了一些没有在AWK 手册中提到的特色，同时 mawk 提供一小部分扩展,另外据说mawk是实现最快的awk</p>
</blockquote>
<h2 id="awk的一些基础概念"><a href="#awk的一些基础概念" class="headerlink" title="awk的一些基础概念"></a>awk的一些基础概念</h2><p>awk所有的操作都是基于pattern(模式)—action(动作)对来完成的，如下面的形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pattern &#123;action&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到就如同很多编程语言一样，它将所有的动作操作用一对{}花括号包围起来。其中pattern通常是是表示用于匹配输入的文本的“关系式”或“正则表达式”，action则是表示匹配后将执行的动作。在一个完整awk操作中，这两者可以只有其中一个，如果没有pattern则默认匹配输入的全部文本，如果没有action则默认为打印匹配内容到屏幕。</p>
<p>awk处理文本的方式，是将文本分割成一些“字段”，然后再对这些字段进行处理，默认情况下，awk以空格作为一个字段的分割符，不过这不是固定了，可以任意指定分隔符。</p>
<h2 id="awk命令基本格式"><a href="#awk命令基本格式" class="headerlink" title="awk命令基本格式"></a>awk命令基本格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk [-F fs] [-v var=value] [-f prog-file | &apos;program text&apos;] [file...]</div></pre></td></tr></table></figure>
<p>其中-F参数用于预先指定前面提到的字段分隔符（还有其他指定字段的方式） ，-v用于预先为awk程序指定变量，-f参数用于指定awk命令要执行的程序文件，或者在不加-f参数的情况下直接将程序语句放在这里，最后为awk需要处理的文本输入，且可以同时输入多个文本文件。现在我们还是直接来具体体验一下吧。</p>
<h2 id="awk操作体验"><a href="#awk操作体验" class="headerlink" title="awk操作体验"></a>awk操作体验</h2><p>先用vim新建一个文本文档<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim test</div></pre></td></tr></table></figure></p>
<p>包含如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">I like linux</div><div class="line">www.shiyanlou.com</div></pre></td></tr></table></figure></p>
<p>使用awk将文本内容打印到终端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># &quot;quote&gt;&quot; 不用输入</div><div class="line">$ awk &apos;&#123;</div><div class="line"> print</div><div class="line"> &#125;&apos; test</div><div class="line"># 或者写到一行</div><div class="line">$ awk &apos;&#123;print&#125;&apos; test</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/jWXToAR.png" alt="">  </p>
<p>说明:在这个操作中我是省略了pattern，所以awk会默认匹配输入文本的全部内容，然后在”{}”花括号中执行动作，即print打印所有匹配项，这里是全部文本内容</p>
<ul>
<li>将test的第一行的每个字段单独显示为一行</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;&#123;</div><div class="line">&gt; if(NR==1)&#123;</div><div class="line">&gt; print $1 &quot;\n&quot; $2 &quot;\n&quot; $3</div><div class="line">&gt; &#125; else &#123;</div><div class="line">&gt; print&#125;</div><div class="line">&gt; &#125;&apos; test</div><div class="line">  </div><div class="line"># 或者</div><div class="line">$ awk &apos;&#123;</div><div class="line">&gt; if(NR==1)&#123;</div><div class="line">&gt; OFS=&quot;\n&quot;</div><div class="line">&gt; print $1, $2, $3</div><div class="line">&gt; &#125; else &#123;</div><div class="line">&gt; print&#125;</div><div class="line">&gt; &#125;&apos; test</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://i.imgur.com/qkbUmYo.png" alt="">  </p>
<blockquote>
<p>说明:你首先应该注意的是，这里我使用了awk语言的分支选择语句if,它的使用和很多高级语言如C/C++语言基本一致，如果你有这些语言的基础，这里将很好理解。另一个你需要注意的是NR与OFS，这两个是awk内建的变量，NR表示当前读入的记录数，你可以简单的理解为当前处理的行数，OFS表示输出时的字段分隔符，默认为” “空格，如上图所见，我们将字段分隔符设置为\n换行符，所以第一行原本以空格为字段分隔的内容就分别输出到单独一行了。然后是$N其中N为相应的字段号，这也是awk的内建变量，它表示引用相应的字段，因为我们这里第一行只有三个字段，所以只引用到了$3。除此之外另一个这里没有出现的$0，它表示引用当前记录（当前行）的全部内容。</p>
</blockquote>
<ul>
<li>将test的第二行的以点为分段的字段换成以空格为分隔<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ awk -F&apos;.&apos; &apos;&#123;</div><div class="line">&gt; if(NR==2)&#123;</div><div class="line">&gt; print $1 &quot;\t&quot; $2 &quot;\t&quot; $3</div><div class="line">&gt; &#125;&#125;&apos; test</div><div class="line">  </div><div class="line"># 或者</div><div class="line">$ awk &apos;</div><div class="line">&gt; BEGIN&#123;</div><div class="line">&gt; FS=&quot;.&quot;</div><div class="line">&gt; OFS=&quot;\t&quot;  # 如果写为一行，两个动作语句之间应该以&quot;;&quot;号分开  </div><div class="line">&gt; &#125;&#123;</div><div class="line">&gt; if(NR==2)&#123;</div><div class="line">&gt; print $1, $2, $3</div><div class="line">&gt; &#125;&#125;&apos; test</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://i.imgur.com/INxnT3y.png" alt="">  </p>
<p>说明：这里的-F参数，前面已经介绍过，它是用来预先指定待处理记录的字段分隔符。我们需要注意的是除了指定OFS我们还可以在print 语句中直接打印特殊符号如这里的\t，print打印的非变量内容都需要用””一对引号包围起来。上面另一个版本，展示了实现预先指定变量分隔符的另一种方式，即使用BEGIN，就这个表达式指示了，其后的动作将在所有动作之前执行，这里是FS赋值了新的”.”点号代替默认的” “空格</p>
<h2 id="awk常用的内置变量"><a href="#awk常用的内置变量" class="headerlink" title="awk常用的内置变量"></a>awk常用的内置变量</h2><table>
<thead>
<tr>
<th>变量名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>FILENAME</td>
<td>当前输入文件名，若有多个文件，则只表示第一个。如果输入是来自标准输入，则为空字符串</td>
</tr>
<tr>
<td>$0</td>
<td>当前记录的内容</td>
</tr>
<tr>
<td>$N</td>
<td>N表示字段号，最大值为NF变量的值</td>
</tr>
<tr>
<td>FS</td>
<td>字段分隔符，由正则表达式表示，默认为” “空格</td>
</tr>
<tr>
<td>RS</td>
<td>输入记录分隔符，默认为”\n”，即一行为一个记录</td>
</tr>
<tr>
<td>NF</td>
<td>当前记录字段数</td>
</tr>
<tr>
<td>NR</td>
<td>已经读入的记录数</td>
</tr>
<tr>
<td>FNR</td>
<td>当前输入文件的记录数，请注意它与NR的区别</td>
</tr>
<tr>
<td>OFS</td>
<td>输出字段分隔符，默认为” “空格</td>
</tr>
<tr>
<td>ORS</td>
<td>输出记录分隔符，默认为”\n”</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;正则表达式，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法（英语：Regu
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Linux/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux基础" scheme="http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>14_Linux 进程的查看</title>
    <link href="http://yoursite.com/2017/07/07/Linux/Base/14_Linux%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86(top,ps,pstree)/"/>
    <id>http://yoursite.com/2017/07/07/Linux/Base/14_Linux 进程管理(top,ps,pstree)/</id>
    <published>2017-07-07T12:59:47.000Z</published>
    <updated>2017-07-07T12:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程的查看"><a href="#进程的查看" class="headerlink" title="进程的查看"></a>进程的查看</h1><p>可以通过 top 实时得查看进程的状态，以及系统的一些信息（如 CPU、内存信息等），我们还可以通过 ps 来静态查看当前的进程信息，同时我们还可以使用 pstree 来查看当前活跃进程的树形结构。</p>
<h2 id="top-工具的使用"><a href="#top-工具的使用" class="headerlink" title="top 工具的使用"></a>top 工具的使用</h2><p>top 工具是我们常用的一个查看工具，能实时的查看我们系统的一些关键信息的变化:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">top</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/zUBIXpi.png" alt="">  </p>
<p>top 是一个在前台执行的程序，所以执行后便进入到这样的一个交互界面，正是因为交互界面我们才可以实时的获取到系统与进程的信息。在交互界面中我们可以通过一些指令来操作和筛选。在此之前我们先来了解显示了哪些信息。  </p>
<p>我们看到 top 显示的第一排，</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>top</td>
<td>表示当前程序的名称</td>
</tr>
<tr>
<td>11:05:18</td>
<td>表示当前的系统的时间</td>
</tr>
<tr>
<td>up 8 days,17:12</td>
<td>表示该机器已经启动了多长时间</td>
</tr>
<tr>
<td>1 user</td>
<td>表示当前系统中只有一个用户</td>
</tr>
<tr>
<td>load average: 0.29,0.20,0.25</td>
<td>分别对应1、5、15分钟内cpu的平均负载</td>
</tr>
</tbody>
</table>
<p>load average 在 wikipedia 中的解释是 the system load is a measure of the amount of work that a computer system is doing 也就是对当前 CPU 工作量的度量，具体来说也就是指运行队列的平均长度，也就是等待 CPU 的平均进程数相关的一个计算值。  </p>
<p>我们该如何看待这个load average 数据呢？  </p>
<p>假设我们的系统是单 CPU、单内核的，把它比喻成是一条单向的桥，把CPU任务比作汽车。  </p>
<ul>
<li>load = 0 的时候意味着这个桥上并没有车，cpu 没有任何任务；</li>
<li>load &lt; 1 的时候意味着桥上的车并不多，一切都还是很流畅的，cpu 的任务并不多，资源还很充足；</li>
<li>load = 1 的时候就意味着桥已经被车给沾满了，没有一点空隙，cpu 的已经在全力工作了，所有的资源都被用完了，当然还好，这还在能力范围之内，只是有点慢而已；</li>
<li>load &gt; 1 的时候就意味着不仅仅是桥上已经被车占满了，就连桥外都被占满了，cpu 已经在全力的工作了，系统资源的用完了，但是还是有大量的进程在请求，在等待。若是这个值大于２，大于３，超过 CPU 工作能力的 2，３。而若是这个值 &gt; 5 说明系统已经在超负荷运作了。【注释1】</li>
</ul>
<p>这是单个 CPU 单核的情况，而实际生活中我们需要将得到的这个值除以我们的核数来看。我们可以通过一下的命令来查看 CPU 的个数与核心数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#查看物理CPU的个数</div><div class="line">#cat /proc/cpuinfo |grep &quot;physical id&quot;|sort |uniq|wc -l</div><div class="line"></div><div class="line">#每个cpu的核心数</div><div class="line">cat /proc/cpuinfo |grep &quot;physical id&quot;|grep &quot;0&quot;|wc -l</div></pre></td></tr></table></figure></p>
<p>通过上面的指数我们可以得知 load 的临界值为 1 ，但是在实际生活中，比较有经验的运维或者系统管理员会将临界值定为0.7。这里的指数都是除以核心数以后的值，不要混淆了</p>
<ul>
<li>若是 load &lt; 0.7 并不会去关注他；</li>
<li>若是 0.7&lt; load &lt; 1 的时候我们就需要稍微关注一下了，虽然还可以应付但是这个值已经离临界不远了；</li>
<li>若是 load = 1 的时候我们就需要警惕了，因为这个时候已经没有更多的资源的了，已经在全力以赴了；</li>
<li>若是 load &gt; 5 的时候系统已经快不行了，这个时候你需要加班解决问题了</li>
</ul>
<p>通常我们都会先看 15 分钟的值来看这个大体的趋势，然后再看 5 分钟的值对比来看是否有下降的趋势。</p>
<p>查看 busybox 的代码可以知道，数据是每 5 秒钟就检查一次活跃的进程数，然后计算出该值，然后 load 从 /proc/loadavg 中读取的。而这个 load 的值是如何计算的呢，这是 load 的计算的源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#define FSHIFT      11          /* nr of bits of precision */</div><div class="line">#define FIXED_1     (1&lt;&lt;FSHIFT) /* 1.0 as fixed-point(定点) */</div><div class="line">#define LOAD_FREQ   (5*HZ)      /* 5 sec intervals，每隔5秒计算一次平均负载值 */</div><div class="line">#define CALC_LOAD(load, exp, n)     \</div><div class="line">         load *= exp;               \</div><div class="line">         load += n*(FIXED_1 - exp); \</div><div class="line">         load &gt;&gt;= FSHIFT;</div><div class="line"></div><div class="line">unsigned long avenrun[3];</div><div class="line"></div><div class="line">EXPORT_SYMBOL(avenrun);</div><div class="line"></div><div class="line">/*</div><div class="line">* calc_load - given tick count, update the avenrun load estimates.</div><div class="line">* This is called while holding a write_lock on xtime_lock.</div><div class="line">*/</div><div class="line">static inline void calc_load(unsigned long ticks)</div><div class="line">&#123;</div><div class="line">        unsigned long active_tasks; /* fixed-point */</div><div class="line">        static int count = LOAD_FREQ;</div><div class="line">        count -= ticks;</div><div class="line">        if (count &lt; 0) &#123;</div><div class="line">                count += LOAD_FREQ;</div><div class="line">                active_tasks = count_active_tasks();</div><div class="line">                CALC_LOAD(avenrun[0], EXP_1, active_tasks);</div><div class="line">                CALC_LOAD(avenrun[1], EXP_5, active_tasks);</div><div class="line">                CALC_LOAD(avenrun[2], EXP_15, active_tasks);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>来看 top 的第二行数据，基本上第二行是进程的一个情况统计</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tasks: 26 total</td>
<td>进程总数</td>
</tr>
<tr>
<td>1 running</td>
<td>1个正在运行的进程数</td>
</tr>
<tr>
<td>25 sleeping</td>
<td>25个睡眠的进程数</td>
</tr>
<tr>
<td>0 stopped</td>
<td>没有停止的进程数</td>
</tr>
<tr>
<td>0 zombie</td>
<td>没有僵尸进程数</td>
</tr>
</tbody>
</table>
<p>来看 top 的第三行数据，这一行基本上是 CPU 的一个使用情况的统计了</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cpu(s): 1.0%us</td>
<td>用户空间进程占用CPU百分比</td>
</tr>
<tr>
<td>1.0% sy</td>
<td>内核空间运行占用CPU百分比</td>
</tr>
<tr>
<td>0.0%ni</td>
<td>用户进程空间内改变过优先级的进程占用CPU百分比</td>
</tr>
<tr>
<td>97.9%id</td>
<td>空闲CPU百分比</td>
</tr>
<tr>
<td>0.0%wa</td>
<td>等待输入输出的CPU时间百分比</td>
</tr>
<tr>
<td>0.1%hi</td>
<td>硬中断(Hardware IRQ)占用CPU的百分比</td>
</tr>
<tr>
<td>0.0%si</td>
<td>软中断(Software IRQ)占用CPU的百分比</td>
</tr>
<tr>
<td>0.0%st</td>
<td>(Steal time) 是 hypervisor 等虚拟服务中，虚拟 CPU 等待实际 CPU 的时间的百分比</td>
</tr>
</tbody>
</table>
<p>CPU 利用率是对一个时间段内 CPU 使用状况的统计，通过这个指标可以看出在某一个时间段内 CPU 被占用的情况，而 Load Average 是 CPU 的 Load，它所包含的信息不是 CPU 的使用率状况，而是在一段时间内 CPU 正在处理以及等待 CPU 处理的进程数情况统计信息，这两个指标并不一样。  </p>
<p>来看 top 的第四行数据，这一行基本上是内存的一个使用情况的统计了：</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>8176740 total</td>
<td>物理内存总量</td>
</tr>
<tr>
<td>8032104 used</td>
<td>使用的物理内存总量</td>
</tr>
<tr>
<td>144636 free</td>
<td>空闲内存总量</td>
</tr>
<tr>
<td>313088 buffers</td>
<td>用作内核缓存的内存量</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意<br>系统的中可用的物理内存最大值并不是 free 这个单一的值，而是 free + buffers + swap 中的 cached 的和</p>
</blockquote>
<p>来看 top 的第五行数据，这一行基本上是交换区的一个使用情况的统计了</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>total</td>
<td>交换区总量</td>
</tr>
<tr>
<td>used</td>
<td>使用的交换区总量</td>
</tr>
<tr>
<td>free</td>
<td>空闲交换区总量</td>
</tr>
<tr>
<td>cached</td>
<td>缓冲的交换区总量,内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>在下面就是进程的一个情况了</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>PID</td>
<td>进程id</td>
</tr>
<tr>
<td>USER</td>
<td>该进程的所属用户</td>
</tr>
<tr>
<td>PR</td>
<td>该进程执行的优先级 priority 值</td>
</tr>
<tr>
<td>NI</td>
<td>该进程的 nice 值</td>
</tr>
<tr>
<td>VIRT</td>
<td>该进程任务所使用的虚拟内存的总数</td>
</tr>
<tr>
<td>RES</td>
<td>该进程所使用的物理内存数，也称之为驻留内存数</td>
</tr>
<tr>
<td>SHR</td>
<td>该进程共享内存的大小</td>
</tr>
<tr>
<td>S</td>
<td>该进程进程的状态: S=sleep R=running Z=zombie</td>
</tr>
<tr>
<td>%CPU</td>
<td>该进程CPU的利用率</td>
</tr>
<tr>
<td>%MEM</td>
<td>该进程内存的利用率</td>
</tr>
<tr>
<td>TIME+</td>
<td>该进程活跃的总时间</td>
</tr>
<tr>
<td>COMMAND</td>
<td>该进程运行的名字</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意</p>
<p>NICE 值叫做静态优先级，是用户空间的一个优先级值，其取值范围是-20至19。这个值越小，表示进程”优先级”越高，而值越大“优先级”越低。nice值中的 -20 到 19，中 -20 优先级最高， 0 是默认的值，而 19 优先级最低</p>
<p>PR 值表示 Priority 值叫动态优先级，是进程在内核中实际的优先级值，进程优先级的取值范围是通过一个宏定义的，这个宏的名称是 MAX_PRIO，它的值为 140。Linux 实际上实现了 140 个优先级范围，取值范围是从 0-139，这个值越小，优先级越高。而这其中的 0 - 99 是实时进程的值，而 100 - 139 是给用户的。</p>
<p>其中 PR 中的 100 to 139 值部分有这么一个对应 PR = 20 + (-20 to +19)，这里的 -20 to +19 便是nice值，所以说两个虽然都是优先级，而且有千丝万缕的关系，但是他们的值，他们的作用范围并不相同</p>
<p>VIRT 任务所使用的虚拟内存的总数，其中包含所有的代码，数据，共享库和被换出 swap空间的页面等所占据空间的总数</p>
</blockquote>
<p>在上文我们曾经说过 top 是一个前台程序，所以是一个可以交互的</p>
<table>
<thead>
<tr>
<th>常用交互命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>q</td>
<td>退出程序</td>
</tr>
<tr>
<td>I</td>
<td>切换显示平均负载和启动时间的信息</td>
</tr>
<tr>
<td>P</td>
<td>根据CPU使用百分比大小进行排序</td>
</tr>
<tr>
<td>M</td>
<td>根据驻留内存大小进行排序</td>
</tr>
<tr>
<td>i</td>
<td>忽略闲置和僵死的进程，这是一个开关式命令</td>
</tr>
<tr>
<td>k</td>
<td>终止一个进程，系统提示输入 PID 及发送的信号值。一般终止进程用 15 信号，不能正常结束则使用 9 信号。安全模式下该命令被屏蔽。</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h2 id="ps-工具的使用"><a href="#ps-工具的使用" class="headerlink" title="ps 工具的使用"></a>ps 工具的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps aux</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/uS7vjWp.png" alt="">  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps axjf</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/x9j1F7j.png" alt="">  </p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>F</td>
<td>进程的标志（process flags），当 flags 值为 1 则表示此子程序只是 fork 但没有执行 exec，为 4 表示此程序使用超级管理员 root 权限</td>
</tr>
<tr>
<td>USER</td>
<td>进程的拥有用户</td>
</tr>
<tr>
<td>PID</td>
<td>进程的 ID</td>
</tr>
<tr>
<td>PPID</td>
<td>其父进程的 PID</td>
</tr>
<tr>
<td>SID</td>
<td>session 的 ID</td>
</tr>
<tr>
<td>TPGID</td>
<td>前台进程组的 ID</td>
</tr>
<tr>
<td>%CPU</td>
<td>进程占用的 CPU 百分比</td>
</tr>
<tr>
<td>%MEM</td>
<td>占用内存的百分比</td>
</tr>
<tr>
<td>NI</td>
<td>进程的 NICE 值</td>
</tr>
<tr>
<td>VSZ</td>
<td>进程使用虚拟内存大小</td>
</tr>
<tr>
<td>RSS</td>
<td>驻留内存中页的大小</td>
</tr>
<tr>
<td>TTY</td>
<td>终端 ID</td>
</tr>
<tr>
<td>S or STAT</td>
<td>进程状态</td>
</tr>
<tr>
<td>WCHAN</td>
<td>正在等待的进程资源</td>
</tr>
<tr>
<td>START</td>
<td>启动进程的时间</td>
</tr>
<tr>
<td>TIME</td>
<td>进程消耗CPU的时间</td>
</tr>
<tr>
<td>COMMAND</td>
<td>命令的名称和参数　</td>
</tr>
</tbody>
</table>
<blockquote>
<p>TPGID栏写着-1的都是没有控制终端的进程，也就是守护进程</p>
</blockquote>
<p>STAT表示进程的状态，而进程的状态有很多，如下表所示</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>R</td>
<td>Running.运行中</td>
</tr>
<tr>
<td>S</td>
<td>Interruptible Sleep.等待调用</td>
</tr>
<tr>
<td>D</td>
<td>Uninterruptible Sleep.不可中断睡眠</td>
</tr>
<tr>
<td>T</td>
<td>Stoped.暂停或者跟踪状态</td>
</tr>
<tr>
<td>X</td>
<td>Dead.即将被撤销</td>
</tr>
<tr>
<td>Z</td>
<td>Zombie.僵尸进程</td>
</tr>
<tr>
<td>W</td>
<td>Paging.内存交换</td>
</tr>
<tr>
<td>N</td>
<td>优先级低的进程</td>
</tr>
<tr>
<td>&lt;</td>
<td>优先级高的进程</td>
</tr>
<tr>
<td>s</td>
<td>进程的领导者</td>
</tr>
<tr>
<td>L</td>
<td>锁定状态</td>
</tr>
<tr>
<td>l</td>
<td>多线程状态</td>
</tr>
<tr>
<td>+</td>
<td>前台进程</td>
</tr>
</tbody>
</table>
<blockquote>
<p>其中的 D 是不能被中断睡眠的状态，处在这种状态的进程不接受外来的任何 signal，所以无法使用 kill 命令杀掉处于D状态的进程，无论是 kill，kill -9 还是 kill -15，一般处于这种状态可能是进程 I/O 的时候出问题了。</p>
</blockquote>
<ul>
<li>使用 -l 参数可以显示自己这次登陆的 bash 相关的进程信息罗列出来<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -l</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://i.imgur.com/hxy6SN8.png" alt="">  </p>
<ul>
<li>罗列出所有的进程信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps aux</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://i.imgur.com/Ka02pI8.png" alt="">  </p>
<ul>
<li>若是查找其中的某个进程的话，还可以配合着 grep 和正则表达式一起使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps aux | grep zsh</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://i.imgur.com/nvI05AN.png" alt="">  </p>
<ul>
<li>查看时，将连同部分的进程呈树状显示出来<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps axjf</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://i.imgur.com/2KYIPZf.png" alt="">  </p>
<h2 id="pstree-工具的使用"><a href="#pstree-工具的使用" class="headerlink" title="pstree 工具的使用"></a>pstree 工具的使用</h2><p>通过 pstree 可以很直接的看到相同的进程数量，最主要的还是我们可以看到所有进程的之间的相关性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pstree</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/FhiQitW.png" alt="">  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">pstree -up</div><div class="line"></div><div class="line">#参数选择：</div><div class="line">#-A  ：各程序树之间以 ASCII 字元來連接；</div><div class="line">#-p  ：同时列出每个 process 的 PID；</div><div class="line">#-u  ：同时列出每个 process 的所屬账户名称。</div></pre></td></tr></table></figure>
<h1 id="进程的管理"><a href="#进程的管理" class="headerlink" title="进程的管理"></a>进程的管理</h1><h2 id="kill-命令的掌握"><a href="#kill-命令的掌握" class="headerlink" title="kill 命令的掌握"></a>kill 命令的掌握</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#首先我们使用图形界面打开了 gedit、gvim，用 ps 可以查看到</div><div class="line">ps aux</div><div class="line">  </div><div class="line">#使用9这个信号强制结束 gedit 进程</div><div class="line">kill -9 1608</div><div class="line">  </div><div class="line">#我们在查找这个进程的时候就找不到了</div><div class="line">ps aux | grep gedit</div></pre></td></tr></table></figure>
<h1 id="进程的执行顺序"><a href="#进程的执行顺序" class="headerlink" title="进程的执行顺序"></a>进程的执行顺序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#打开一个程序放在后台，或者用图形界面打开</div><div class="line">nice -n -5 vim &amp;</div><div class="line"></div><div class="line">#用 ps 查看其优先级</div><div class="line">ps -afxo user,ppid,pid,stat,pri,ni,time,command | grep vim</div></pre></td></tr></table></figure>
<p>还可以用 renice 来修改已经存在的进程的优先级，同样因为权限的原因在实验环境中无法尝试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">renice -5 pid</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;进程的查看&quot;&gt;&lt;a href=&quot;#进程的查看&quot; class=&quot;headerlink&quot; title=&quot;进程的查看&quot;&gt;&lt;/a&gt;进程的查看&lt;/h1&gt;&lt;p&gt;可以通过 top 实时得查看进程的状态，以及系统的一些信息（如 CPU、内存信息等），我们还可以通过 ps 来静态查
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Linux/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux基础" scheme="http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>15_Linux 日志系统</title>
    <link href="http://yoursite.com/2017/07/07/Linux/Base/15_Linux%20%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2017/07/07/Linux/Base/15_Linux 日志系统/</id>
    <published>2017-07-07T12:59:47.000Z</published>
    <updated>2017-07-07T12:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见的日志"><a href="#常见的日志" class="headerlink" title="常见的日志"></a>常见的日志</h1><p>在 Linux 中大部分的发行版都内置使用 syslog 系统日志，常见的日志一般存放在 /var/log 中，我们来看看其中有哪些日志</p>
<p><img src="http://i.imgur.com/8nYxtpg.png" alt="">  </p>
<p>根据服务对象粗略的将日志分为两类</p>
<ul>
<li>系统日志</li>
<li>应用日志</li>
</ul>
<p>系统日志主要是存放系统内置程序或系统内核之类的日志信息如 alternatives.log 、btmp 等等，应用日志主要是我们装的第三方应用所产生的日志如 tomcat7 、apache2 等等。  </p>
<p>常见的系统日志</p>
<table>
<thead>
<tr>
<th>日志名称</th>
<th>记录信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>alternatives.log</td>
<td>系统的一些更新替代信息记录</td>
</tr>
<tr>
<td>apport.log</td>
<td>应用程序崩溃信息记录</td>
</tr>
<tr>
<td>apt/history.log</td>
<td>使用 apt-get 安装卸载软件的信息记录</td>
</tr>
<tr>
<td>apt/term.log</td>
<td>使用 apt-get 时的具体操作，如 package 的下载、打开等</td>
</tr>
<tr>
<td>auth.log</td>
<td>登录认证的信息记录</td>
</tr>
<tr>
<td>boot.log</td>
<td>系统启动时的程序服务的日志信息</td>
</tr>
<tr>
<td>btmp</td>
<td>错误登陆的信息记录</td>
</tr>
<tr>
<td>Consolekit/history</td>
<td>控制台的信息记录</td>
</tr>
<tr>
<td>dist-upgrade</td>
<td>dist-upgrade这种更新方式的信息记录</td>
</tr>
<tr>
<td>dmesg</td>
<td>启动时，显示屏幕上内核缓冲信息,与硬件有关的信息</td>
</tr>
<tr>
<td>dpkg.log    dpkg</td>
<td>命令管理包的日志。</td>
</tr>
<tr>
<td>faillog</td>
<td>用户登录失败详细信息记录</td>
</tr>
<tr>
<td>fontconfig.log</td>
<td>与字体配置有关的信息记录</td>
</tr>
<tr>
<td>kern.log</td>
<td>内核产生的信息记录，在自己修改内核时有很大帮助</td>
</tr>
<tr>
<td>lastlog</td>
<td>用户的最近信息记录</td>
</tr>
<tr>
<td>wtmp</td>
<td>登录信息的记录。wtmp可以找出谁正在登陆进入系统，谁使用命令显示这个文件或信息等</td>
</tr>
<tr>
<td>syslog</td>
<td>系统信息记录</td>
</tr>
</tbody>
</table>
<p>来看 alternatives.log 中的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">update-alternatives 2016-07-02 13:36:16: run with --install /usr/bin/x-www-browser x-www-browser /usr/bin/google-chrome-stable 200</div><div class="line">update-alternatives 2016-07-02 13:36:16: run with --install /usr/bin/gnome-www-browser gnome-www-browser /usr/bin/google-chrome-stable 200</div><div class="line">update-alternatives 2016-07-02 13:36:16: run with --install /usr/bin/google-chrome google-chrome /usr/bin/google-chrome-stable 200</div></pre></td></tr></table></figure></p>
<p>从中得到信息有程序作用，日期，命令，成功与否的返回码</p>
<p>来看看 auth.log 中的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">less auth.log</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/hBaYC0S.png" alt="">  </p>
<p>从中得到的信息有日期与 ip 地址的来源以及登陆的用户与工具</p>
<p>在 apt 文件夹中的日志信息，其中有两个日志文件 history.log 与 term.log，两个日志文件的区别在于 history.log 主要记录了进行了那个操作，相关的依赖有哪些，而 term.log 则是较为具体的一些操作，主要就是下载包，打开包，安装包等等的细节操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">less /var/log/apt/history.log</div><div class="line">  </div><div class="line">less /var/log/apt/term.log</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/whmmuPD.png" alt="">  </p>
<h1 id="配置的日志"><a href="#配置的日志" class="headerlink" title="配置的日志"></a>配置的日志</h1><p>可以通过两种方式：  </p>
<ul>
<li>一种是由软件开发商自己来自定义日志格式然后指定输出日志位置；  </li>
<li>一种方式就是 Linux 提供的日志服务程序，而我们这里系统日志是通过 syslog 来实现，提供日志管理服务。  </li>
</ul>
<p>syslog 是一个系统日志记录程序，在早期的大部分 Linux 发行版都是内置 syslog，让其作为系统的默认日志收集工具，虽然时代的进步与发展，syslog 已经年老体衰跟不上时代的需求，所以他被 rsyslog 所代替了，较新的 Ubuntu、Fedora 等等都是默认使用 rsyslog 作为系统的日志收集工具  </p>
<p>rsyslog的全称是 rocket-fast system for log，它提供了高性能，高安全功能和模块化设计。rsyslog 能够接受从各种各样的来源，将其输入，输出的结果到不同的目的地。rsyslog 可以提供超过每秒一百万条消息给目标文件。  </p>
<p>这样能实时收集日志信息的程序是有其守护进程的，如 rsyslog 的守护进程便是 rsyslogd  </p>
<p>可以手动开启这项服务，然后来查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo service rsyslog start</div><div class="line">  </div><div class="line">ps aux | grep syslog</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/U8FBXoO.png" alt="">  </p>
<p>既然它是一个服务，那么它便是可以配置，为我们提供一些我们自定义的服务  </p>
<p>首先我们来看 rsyslog 的配置文件是什么样子的，而 rsyslog 的配置文件有两个，  </p>
<ul>
<li>一个是 /etc/rsyslog.conf</li>
<li>一个是 /etc/rsyslog.d/50-default.conf。</li>
</ul>
<p>第一个主要是配置的环境，也就是 rsyslog 的加载什么模块，文件的所属者等；而第二个主要是配置的 Filter Conditions<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vim /etc/rsyslog.conf </div><div class="line">  </div><div class="line">vim /etc/rsyslog.d/50-default.conf</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#首先将syslog启动起来</div><div class="line">sudo service rsyslog start</div><div class="line"></div><div class="line">#向 syslog 写入数据</div><div class="line">ping 127.0.0.1 | logger -it logger_test -p local3.notice &amp;</div><div class="line"></div><div class="line">#查看是否有数据写入</div><div class="line">tail -f /var/log/syslog</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常见的日志&quot;&gt;&lt;a href=&quot;#常见的日志&quot; class=&quot;headerlink&quot; title=&quot;常见的日志&quot;&gt;&lt;/a&gt;常见的日志&lt;/h1&gt;&lt;p&gt;在 Linux 中大部分的发行版都内置使用 syslog 系统日志，常见的日志一般存放在 /var/log 中，我们
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Linux/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux基础" scheme="http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>13_Linux 进程与程序</title>
    <link href="http://yoursite.com/2017/07/07/Linux/Base/13_Linux%20%E8%BF%9B%E7%A8%8B(pstree,&amp;,jobs,fg,bg,kill)/"/>
    <id>http://yoursite.com/2017/07/07/Linux/Base/13_Linux 进程(pstree,&amp;,jobs,fg,bg,kill)/</id>
    <published>2017-07-07T12:59:47.000Z</published>
    <updated>2017-07-07T12:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程与程序"><a href="#进程与程序" class="headerlink" title="进程与程序"></a>进程与程序</h1><blockquote>
<p>程序（procedure）：不太精确地说，程序就是执行一系列有逻辑、有顺序结构的指令，帮我们达成某个结果。就如我们去餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，最后我们得到了这么一盘牛肉盖浇饭。它需要去执行，不然它就像一本武功秘籍，放在那里等人翻看。  </p>
<p>进程（process）：进程是程序在一个数据集合上的一次执行过程，在早期的UNIX、Linux 2.4及更早的版本中，它是系统进行资源分配和调度的独立基本单位。同上一个例子，就如我们去了餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，而里面做饭的是一个进程，做牛肉汤汁的是一个进程，把牛肉汤汁与饭混合在一起的是一个进程，把饭端上桌的是一个进程。它就像是我们在看武功秘籍这么一个过程，然后一个篇章一个篇章地去练。  </p>
</blockquote>
<p>程序只是一些列指令的集合，是一个静止的实体，而进程不同，进程有以下的特性：  </p>
<ul>
<li>动态性：进程的实质是一次程序执行的过程，有创建、撤销等状态的变化。而程序是一个静态的实体。</li>
<li>并发性：进程可以做到在一个时间段内，有多个程序在运行中。程序只是静态的实体，所以不存在并发性。</li>
<li>独立性：进程可以独立分配资源，独立接受调度，独立地运行。</li>
<li>异步性：进程以不可预知的速度向前推进。</li>
<li>结构性：进程拥有代码段、数据段、PCB（进程控制块，进程存在的唯一标志）。也正是因为有结构性，进程才可以做到独立地运行。</li>
</ul>
<blockquote>
<p>并发：在一个时间段内，宏观来看有多个程序都在活动，有条不紊的执行（每一瞬间只有一个在执行，只是在一段时间有多个程序都执行过）</p>
<p>并行：在每一个瞬间，都有多个程序都在同时执行，这个必须有多个 CPU 才行</p>
</blockquote>
<p>引入进程是因为传统意义上的程序已经不足以描述 OS 中各种活动之间的动态性、并发性、独立性还有相互制约性。程序就像一个公司，只是一些证书，文件的堆积（静态实体）。而当公司运作起来就有各个部门的区分，财务部，技术部，销售部等等，就像各个进程，各个部门之间可以独立运做，也可以有交互（独立性、并发性）。  </p>
<p>而随着程序的发展越做越大，又会继续细分，从而引入了线程的概念，当代多数操作系统、Linux 2.6及更新的版本中，进程本身不是基本运行单位，而是线程的容器。就像上述所说的，每个部门又会细分为各个工作小组（线程），而工作小组需要的资源需要向上级（进程）申请。  </p>
<blockquote>
<p>线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。因为线程中几乎不包含系统资源，所以执行更快、更有效率。</p>
</blockquote>
<p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p>
<p><img src="http://i.imgur.com/srhDdXb.png" alt=""></p>
<h1 id="进程的属性"><a href="#进程的属性" class="headerlink" title="进程的属性"></a>进程的属性</h1><h2 id="进程的分类"><a href="#进程的分类" class="headerlink" title="进程的分类"></a>进程的分类</h2><p>大概明白进程是个什么样的存在后，我们需要进一步了解的就是进程分类。可以从两个角度来分：</p>
<ul>
<li>以进程的功能与服务的对象来分；</li>
<li>以应用程序的服务类型来分；</li>
</ul>
<p>第一个角度来看，我们可以分为用户进程与系统进程：</p>
<ul>
<li>用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。</li>
<li>系统进程：通过执行系统内核程序而产生的进程，比如可以执行内存资源分配和进程切换等相对底层的工作；而且该进程的运行不受用户的干预，即使是 root 用户也不能干预系统进程的运行。</li>
</ul>
<p>第二角度来看，我们可以将进程分为交互进程、批处理进程、守护进程</p>
<ul>
<li>交互进程：由一个 shell 终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。</li>
<li>批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。</li>
<li>守护进程：守护进程是一直运行的一种进程，在 Linux 系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如 httpd 进程，一直处于运行状态，等待用户的访问。还有经常用的 cron（在 centOS 系列为 crond）进程，这个进程为 crontab 的守护进程，可以周期性的执行用户设定的某些任务。</li>
</ul>
<h2 id="进程的衍生"><a href="#进程的衍生" class="headerlink" title="进程的衍生"></a>进程的衍生</h2><p>比如我们启动了终端，就是启动了一个 bash 进程，我们可以在 bash 中再输入 bash 则会再启动一个 bash 的进程，此时第二个 bash 进程就是由第一个 bash 进程创建出来的，他们直接又是个什么关系？  </p>
<p>我们一般称呼第一个 bash 进程是第二 bash 进程的父进程，第二 bash 进程是第一个 bash 进程的子进程，这层关系是如何得来的呢？  </p>
<p>关于父进程与子进程便会提及这两个系统调用 fork() 与 exec()  </p>
<blockquote>
<p>fork-exec是由 Dennis M. Ritchie 创造的</p>
<p>fork() 是一个系统调用（system call），它的主要作用就是为当前的进程创建一个新的进程，这个新的进程就是它的子进程，这个子进程除了父进程的返回值和 PID 以外其他的都一模一样，如进程的执行代码段，内存信息，文件描述，寄存器状态等等</p>
<p>exec() 也是系统调用，作用是切换子进程中的执行程序也就是替换其从父进程复制过来的代码段与数据段</p>
</blockquote>
<p>子进程就是父进程通过系统调用 fork() 而产生的复制品，fork() 就是把父进程的 PCB 等进程的数据结构信息直接复制过来，只是修改了 PID，所以一模一样，只有在执行 exec() 之后才会不同，而早先的 fork() 比较消耗资源后来进化成 vfork(),效率高了不少。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">pid_t p;</div><div class="line">  </div><div class="line">p = fork();</div><div class="line">if (p == (pid_t) -1)</div><div class="line">        /* ERROR */</div><div class="line">else if (p == 0)</div><div class="line">        /* CHILD */</div><div class="line">else</div><div class="line">        /* PARENT */</div></pre></td></tr></table></figure>
<p>既然子进程是通过父进程而衍生出来的，那么子进程的退出与资源的回收定然与父进程有很大的相关性。当一个子进程要正常的终止运行时，或者该进程结束时它的主函数 main() 会执行 exit(n); 或者 return n，这里的返回值 n 是一个信号，系统会把这个 SIGCHLD 信号传给其父进程，当然若是异常终止也往往是因为这个信号。  </p>
<p>在将要结束时的子进程代码执行部分已经结束执行了，系统的资源也基本归还给系统了，但若是其进程的进程控制块（PCB）仍驻留在内存中，而它的 PCB 还在，代表这个进程还存在（因为 PCB 就是进程存在的唯一标志，里面有 PID 等消息），并没有消亡，这样的进程称之为僵尸进程（Zombie）。  </p>
<p>如图中第四列标题是 S，S 表示的是进程的状态，而在下属的第三行的 Z 表示的是 Zombie 的意思。（ ps 命令将在后续详解）  </p>
<p><img src="http://i.imgur.com/fwSfuhx.png" alt="">  </p>
<p>正常情况下，父进程会收到两个返回值：exit code（SIGCHLD 信号）与 reason for termination 。之后，父进程会使用 wait(&amp;status) 系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的 PCB；而如若父进程没有这么做的话，子进程的 PCB 就会一直驻留在内存中，一直留在系统中成为僵尸进程（Zombie）。  </p>
<p>虽然僵尸进程是已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，在进程列表中保留一个位置，记载该进程的退出状态等信息供其父进程收集，从而释放它。但是 Linux 系统中能使用的 PID 是有限的，如果系统中存在有大量的僵尸进程，系统将会因为没有可用的 PID 从而导致不能产生新的进程。  </p>
<p>另外如果父进程结束（非正常的结束），未能及时收回子进程，子进程仍在运行，这样的子进程称之为孤儿进程。在 Linux 系统中，孤儿进程一般会被 init 进程所“收养”，成为 init 的子进程。由 init 来做善后处理，所以它并不至于像僵尸进程那样无人问津，不管不顾，大量存在会有危害。  </p>
<p>进程 0 是系统引导时创建的一个特殊进程，也称之为内核初始化，其最后一个动作就是调用 fork() 创建出一个子进程运行 /sbin/init 可执行文件,而该进程就是 PID=1 的进程 1，而进程 0 就转为交换进程（也被称为空闲进程），进程 1 （init 进程）是第一个用户态的进程，再由它不断调用 fork() 来创建系统里其他的进程，所以它是所有进程的父进程或者祖先进程。同时它是一个守护程序，直到计算机关机才会停止。  </p>
<p>通过以下的命令我们可以很明显的看到这样的结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pstree</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/4Y1j8Bn.png" alt="">  </p>
<p>或者从此图可以更加形象的看清子父进程的关系</p>
<p><img src="http://i.imgur.com/AR8rlHI.png" alt="">  </p>
<p>通过以上的显示结果我们可以看的很清楚，init 为所有进程的父进程或者说是祖先进程  </p>
<p>我们还可以使用这样一个命令来看，其中 pid 就是该进程的一个唯一编号，ppid 就是该进程的父进程的 pid，command 表示的是该进程通过执行什么样的命令或者脚本而产生的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps －fxo user,ppid,pid,pgid,command</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/kYJ2idS.png" alt="">  </p>
<p>可以在图中看见我们执行的 ps 就是由 zsh 通过 fork-exec 创建的子进程而执行的</p>
<p>使用这样的一个命令我们也能清楚的看见 init 如上文所说是由进程 0 这个初始化进程来创建而出的子进程,而其他的进程基本是由 init 创建的子进程，或者是由它的子进程创建出来的子进程。所以 init 是用户进程的第一个进程也是所有用户进程的父进程或者祖先进程。（ps 命令将在后续课程详解）</p>
<p>就像一个树状图，而 init 进程就是这棵树的根，其他进程由根不断的发散，开枝散叶</p>
<h2 id="进程组与-Sessions"><a href="#进程组与-Sessions" class="headerlink" title="进程组与 Sessions"></a>进程组与 Sessions</h2><p>每一个进程都会是一个进程组的成员，而且这个进程组是唯一存在的，他们是依靠 PGID（process group ID）来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。  </p>
<p>一般情况，进程组的 PGID 等同于进程组的第一个成员的 PID，并且这样的进程称为该进程组的领导者,也就是领导进程，进程一般通过使用 getpgrp() 系统调用来寻找其所在组的 PGID，领导进程可以先终结，此时进程组依然存在，并持有相同的PGID，直到进程组中最后一个进程终结。  </p>
<p>与进程组类似，每当一个进程被创建的时候，它便会成为其父进程所在 Session 中的一员，每一个进程组都会在一个 Session 中，并且这个 Session 是唯一存在的，  </p>
<p>Session 主要是针对一个 tty 建立，Session 中的每个进程都称为一个工作(job)。每个会话可以连接一个终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。Session 意义在于将多个 jobs 囊括在一个终端，并取其中的一个 job 作为前台，来直接接收该终端的输入输出以及终端信号。 其他 jobs 在后台运行。  </p>
<blockquote>
<p>前台（foreground）就是在终端中运行，能与你有交互的</p>
<p>后台（background）就是在终端中运行，但是你并不能与其任何的交互，也不会显示其执行的过程</p>
</blockquote>
<h2 id="工作管理"><a href="#工作管理" class="headerlink" title="工作管理"></a>工作管理</h2><p>bash(Bourne-Again shell)支持工作控制（job control）,而 sh（Bourne shell）并不支持。  </p>
<p>并且每个终端或者说 bash 只能管理当前终端的中的 job，不能管理其他终端中的 job。比如我当前存在两个 bash 分别为 bash1、bash2，bash1 只能管理其自己里面的 job 并不能管理 bash2 里面的 job  </p>
<p>我们都知道当一个进程在前台运作时我们可以用 ctrl + c 来终止它，但是若是在后台的话就不行了。  </p>
<p>我们可以通过 &amp; 这个符号，让我们的命令在后台中运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls &amp;</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/t6njbEZ.png" alt="">  </p>
<p>图中所显示的 [1] 236分别是该 job 的 job number 与该进程的 PID，而最后一行的 Done 表示该命令已经在后台执行完毕。  </p>
<p>我们还可以通过 ctrl + z 使我们的当前工作停止并丢到后台中去  </p>
<p><img src="http://i.imgur.com/mme7wlc.png" alt="">  </p>
<p>被停止并放置在后台的工作我们可以使用这个命令来查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jobs</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/UtOmOw4.png" alt="">  </p>
<p>其中第一列显示的为被放置后台 job 的编号，而第二列的 ＋ 表示最近(刚刚、最后)被放置后台的 job，同时也表示预设的工作，也就是若是有什么针对后台 job 的操作，首先对预设的 job，- 表示倒数第二（也就是在预设之前的一个）被放置后台的工作，倒数第三个（再之前的）以后都不会有这样的符号修饰，第三列表示它们的状态，而最后一列表示该进程执行的命令  </p>
<p>我们可以通过这样的一个命令将后台的工作拿到前台来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#后面不加参数提取预设工作，加参数提取指定工作的编号</div><div class="line">#ubuntu 在 zsh 中需要 %，在 bash 中不需要 %</div><div class="line">fg [%jobnumber]</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/TTxSjQC.png" alt=""><br><img src="http://i.imgur.com/wWiI1wb.png" alt="">  </p>
<p>之前我们通过 ctrl + z 使得工作停止放置在后台，若是我们想让其在后台运作我们就使用这样一个命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#与fg类似，加参则指定，不加参则取预设</div><div class="line">bg [%jobnumber]</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/ZsVKHUW.png" alt="">  </p>
<p>既然有方法将被放置在后台的工作提至前台或者让它从停止变成继续运行在后台，当然也有方法删除一个工作，或者重启等等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#kill的使用格式如下</div><div class="line">kill -signal %jobnumber</div><div class="line">  </div><div class="line">#signal从1-64个信号值可以选择，可以这样查看</div><div class="line">kill －l</div></pre></td></tr></table></figure></p>
<p>其中常用的有这些信号值  </p>
<table>
<thead>
<tr>
<th>信号值</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-1</td>
<td>重新读取参数运行，类似与restart</td>
</tr>
<tr>
<td>-2</td>
<td>如同 ctrl+c 的操作退出</td>
</tr>
<tr>
<td>-9</td>
<td>强制终止该任务</td>
</tr>
<tr>
<td>-15</td>
<td>正常的方式终止该任务</td>
</tr>
</tbody>
</table>
<p><img src="http://i.imgur.com/ooBuH04.png" alt="">  </p>
<blockquote>
<p>注意:</p>
<p>若是在使用kill＋信号值然后直接加 pid，你将会对 pid 对应的进程进行操作</p>
<p>若是在使用kill+信号值然后 ％jobnumber，这时所操作的对象是 job，这个数字就是就当前 bash 中后台的运行的 job 的 ID</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;进程与程序&quot;&gt;&lt;a href=&quot;#进程与程序&quot; class=&quot;headerlink&quot; title=&quot;进程与程序&quot;&gt;&lt;/a&gt;进程与程序&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;程序（procedure）：不太精确地说，程序就是执行一系列有逻辑、有顺序结构的指令，帮我
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Linux/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux基础" scheme="http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>12_Linux 软件安装</title>
    <link href="http://yoursite.com/2017/07/07/Linux/Base/12_Linux%20%E4%B8%8B%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85(apt-get,dpkg)/"/>
    <id>http://yoursite.com/2017/07/07/Linux/Base/12_Linux 下软件安装(apt-get,dpkg)/</id>
    <published>2017-07-07T12:59:47.000Z</published>
    <updated>2017-07-07T12:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-下软件安装"><a href="#Linux-下软件安装" class="headerlink" title="Linux 下软件安装"></a>Linux 下软件安装</h1><p>通常 Linux 上的软件安装主要有四种方式：</p>
<ul>
<li>在线安装</li>
<li>从磁盘安装deb软件包</li>
<li>从二进制软件包安装</li>
<li>从源代码编译安装</li>
</ul>
<p>在不同的linux发行版上面在线安装方式会有一些差异包括使用的命令及它们的包管理工具  </p>
<h1 id="apt-包管理工具介绍"><a href="#apt-包管理工具介绍" class="headerlink" title="apt 包管理工具介绍"></a>apt 包管理工具介绍</h1><blockquote>
<p>APT是Advance Packaging Tool（高级包装工具）的缩写，是Debian及其派生发行版的软件包管理器，APT可以自动下载，配置，安装二进制或者源代码格式的软件包，因此简化了Unix系统上管理软件的过程。APT最早被设计成dpkg的前端，用来处理deb格式的软件包。现在经过APT-RPM组织修改，APT已经可以安装在支持RPM的系统管理RPM包。这个包管理器包含以 apt- 开头的的多个工具，如 apt-get apt-cache apt-cdrom 等，在Debian系列的发行版中使用。</p>
</blockquote>
<p>当你在执行安装操作时，首先apt-get 工具会在本地的一个数据库中搜索关于 w3m 软件的相关信息，并根据这些信息在相关的服务器上下载软件安装</p>
<ul>
<li>软件源镜像服务器</li>
<li>软件源</li>
</ul>
<p>我们需要定期从服务器上下载一个软件包列表，使用 <code>sudo apt-get update</code> 命令来保持本地的软件包列表是最新的（有时你也需要手动执行这个操作，比如更换了软件源），而这个表里会有软件依赖信息的记录，对于软件依赖，举个例子：安装 w3m 软件的时候，而这个软件需要 libgc1c2 这个软件包才能正常工作，这个时候 apt-get 在安装软件的时候会一并替我们安装了，以保证 w3m 能正常的工作。</p>
<h1 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h1><p>apt-get 是用于处理 apt包的公用程序集，可以用它来在线安装、卸载和升级软件包等，下面列出一些apt-get包含的常用的一些工具：</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>install</td>
<td>其后加上软件包名，用于安装一个软件包</td>
</tr>
<tr>
<td>update</td>
<td>从软件源镜像服务器上下载/更新用于更新本地软件源的软件包列表</td>
</tr>
<tr>
<td>upgrade</td>
<td>升级本地可更新的全部软件包，但存在依赖问题时将不会升级，通常会在更新之前执行一次update</td>
</tr>
<tr>
<td>dist-upgrade</td>
<td>解决依赖关系并升级(存在一定危险性)</td>
</tr>
<tr>
<td>remove</td>
<td>移除已安装的软件包，包括与被移除软件包有依赖关系的软件包，但不包含软件包的配置文件</td>
</tr>
<tr>
<td>autoremove</td>
<td>移除之前被其他软件包依赖，但现在不再被使用的软件包</td>
</tr>
<tr>
<td>purge</td>
<td>与remove相同，但会完全移除软件包，包含其配置文件</td>
</tr>
<tr>
<td>clean</td>
<td>移除下载到本地的已经安装的软件包，默认保存在/var/cache/apt/archives/</td>
</tr>
<tr>
<td>autoclean</td>
<td>移除已安装的软件的旧版本软件包</td>
</tr>
</tbody>
</table>
<p>下面是一些apt-get常用的参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-y</td>
<td>自动回应是否安装软件包的选项，在一些自动化安装脚本中使用这个参数将十分有用</td>
</tr>
<tr>
<td>-s</td>
<td>模拟安装</td>
</tr>
<tr>
<td>-q</td>
<td>静默安装方式，指定多个q或者-q=#,#表示数字，用于设定静默级别，这在你不想要在安装软件包时屏幕输出过多时很有用</td>
</tr>
<tr>
<td>-f</td>
<td>修复损坏的依赖关系</td>
</tr>
<tr>
<td>-d</td>
<td>只下载不安装</td>
</tr>
<tr>
<td>–reinstall</td>
<td>重新安装已经安装但可能存在问题的软件包</td>
</tr>
<tr>
<td>–install-suggests</td>
<td>同时安装APT给出的建议安装的软件包</td>
</tr>
</tbody>
</table>
<h2 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install &lt;软件包名&gt;</div></pre></td></tr></table></figure>
<p>重新安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get --reinstall install w3m</div></pre></td></tr></table></figure></p>
<p>软件升级<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 更新软件源</div><div class="line">$ sudo apt-get update</div><div class="line"># 升级没有依赖问题的软件包</div><div class="line">$ sudo apt-get upgrade</div><div class="line"># 升级并解决依赖关系</div><div class="line">$ sudo apt-get dist-upgrade</div></pre></td></tr></table></figure></p>
<p>卸载软件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get remove w3m</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 不保留配置文件的移除</div><div class="line">$ sudo apt-get purge w3m</div><div class="line"># 或者 sudo apt-get --purge remove</div><div class="line"># 移除不再需要的被依赖的软件包</div><div class="line">$ sudo apt-get autoremove</div></pre></td></tr></table></figure>
<p>软件搜索<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-cache search softname1 softname2 softname3……</div></pre></td></tr></table></figure></p>
<p>apt-cache 命令则是针对本地数据进行相关操作的工具，search 顾名思义在本地的数据库中寻找有关 softname1 softname2 ……   </p>
<h1 id="使用-dpkg"><a href="#使用-dpkg" class="headerlink" title="使用 dpkg"></a>使用 dpkg</h1><p>使用 dpkg 从本地磁盘安装 deb 软件包</p>
<h2 id="dpkg-介绍"><a href="#dpkg-介绍" class="headerlink" title="dpkg 介绍"></a>dpkg 介绍</h2><blockquote>
<p>dpkg 是 Debian 软件包管理器的基础，它被伊恩·默多克创建于 1993 年。dpkg 与 RPM 十分相似，同样被用于安装、卸载和供给和 .deb 软件包相关的信息。</p>
<p>dpkg 本身是一个底层的工具。上层的工具，像是 APT，被用于从远程获取软件包以及处理复杂的软件包关系。”dpkg”是”Debian Package”的简写。</p>
</blockquote>
<p>以deb形式打包的软件包，就需要使用dpkg命令来安装。</p>
<p>dpkg常用参数介绍：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-i</td>
<td>安装指定deb包</td>
</tr>
<tr>
<td>-R</td>
<td>后面加上目录名，用于安装该目录下的所有deb安装包</td>
</tr>
<tr>
<td>-r</td>
<td>remove，移除某个已安装的软件包</td>
</tr>
<tr>
<td>-I</td>
<td>显示deb包文件的信息</td>
</tr>
<tr>
<td>-s</td>
<td>显示已安装软件的信息</td>
</tr>
<tr>
<td>-S</td>
<td>搜索已安装的软件包</td>
</tr>
<tr>
<td>-L</td>
<td>显示已安装软件包的目录信息</td>
</tr>
</tbody>
</table>
<h2 id="使用dpkg安装deb软件包"><a href="#使用dpkg安装deb软件包" class="headerlink" title="使用dpkg安装deb软件包"></a>使用dpkg安装deb软件包</h2><p><img src="http://i.imgur.com/0vwHZuF.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 使用dpkg安装</div><div class="line">$ sudo dpkg -i emacs24_24.3+1-4ubuntu1_amd64.deb</div></pre></td></tr></table></figure></p>
<p>dpkg并不能为你解决依赖关系。用apt-get了，使用它的-f参数了，修复依赖关系的安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get -f install</div></pre></td></tr></table></figure></p>
<h2 id="查看已安装软件包的安装目录"><a href="#查看已安装软件包的安装目录" class="headerlink" title="查看已安装软件包的安装目录"></a>查看已安装软件包的安装目录</h2><p>使用dpkg -L查看deb包目录信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo dpkg -L emacs</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-下软件安装&quot;&gt;&lt;a href=&quot;#Linux-下软件安装&quot; class=&quot;headerlink&quot; title=&quot;Linux 下软件安装&quot;&gt;&lt;/a&gt;Linux 下软件安装&lt;/h1&gt;&lt;p&gt;通常 Linux 上的软件安装主要有四种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Linux/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux基础" scheme="http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>01_用户及文件权限管理</title>
    <link href="http://yoursite.com/2017/07/07/Linux/Base/01_%E7%94%A8%E6%88%B7%E5%8F%8A%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86(sudo,su%20-,su,groups,ls,chown,chmod,%20adduser,useradd,deluser,userdel)/"/>
    <id>http://yoursite.com/2017/07/07/Linux/Base/01_用户及文件权限管理(sudo,su -,su,groups,ls,chown,chmod, adduser,useradd,deluser,userdel)/</id>
    <published>2017-07-07T12:59:47.000Z</published>
    <updated>2017-07-07T12:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用户及文件权限管理"><a href="#用户及文件权限管理" class="headerlink" title="用户及文件权限管理"></a>用户及文件权限管理</h1><h2 id="Linux用户管理"><a href="#Linux用户管理" class="headerlink" title="Linux用户管理"></a>Linux用户管理</h2><h3 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">who am i  </div><div class="line">liaoyujian pts/0 2017-11-19 17:10(:1.0)</div></pre></td></tr></table></figure>
<p>输出的第一列表示打开当前伪终端的用户的用户名（要查看当前登录用户的用户名，去掉空格直接使用 whoami 即可），第二列的 pts/0 中 pts 表示伪终端，所谓伪是相对于 /dev/tty 设备而言的，还记得上一节讲终端时的那七个使用 [Ctrl]+[Alt]+[F1]～[F7] 进行切换的 /dev/tty 设备么,这是“真终端”，伪终端就是当你在图形用户界面使用 /dev/tty7 时每打开一个终端就会产生一个伪终端， pts/0 后面那个数字就表示打开的伪终端序号，你可以尝试再打开一个终端，然后在里面输入 who am i ，看第二列是不是就变成 pts/1 了，第三列则表示当前伪终端的启动时间。  </p>
<p>who 命令其它常用参数  </p>
<p>参数    说明<br>-a    打印能打印的全部<br>-d    打印死掉的进程<br>-m    同am i,mom likes<br>-q    打印当前登录用户数及用户名<br>-u    打印当前登录用户登录信息<br>-r    打印运行等级  </p>
<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>在 Linux 系统里， root 账户拥有整个系统至高无上的权利，比如 新建/添加 用户。  </p>
<blockquote>
<p>root 权限，系统权限的一种，与 SYSTEM 权限可以理解成一个概念，但高于 Administrator 权限，root 是 Linux 和 UNIX 系统中的超级管理员用户帐户，该帐户拥有整个系统至高无上的权力，所有对象他都可以操作，所以很多黑客在入侵系统的时候，都要把权限提升到 root 权限，用 Windows 的方法理解也就是将自己的非法帐户添加到 Administrators 用户组。更比如安卓操作系统中（基于 Linux 内核）获得 root 权限之后就意味着已经获得了手机的最高权限，这时候你可以对手机中的任何文件（包括系统文件）执行所有增、删、改、查的操作。</p>
</blockquote>
<p>我们一般登录系统时都是以普通账户的身份登录的，要创建用户需要 root 权限，这里就要用到 sudo 这个命令了。不过使用这个命令有两个大前提，一是你要知道当前登录用户的密码，二是当前用户必须在 sudo 用户组。shiyanlou 用户也属于 sudo 用户组（稍后会介绍如何查看和添加用户组）。  </p>
<p><strong>su ， su - 与 sudo</strong><br>su <user> 可以切换到用户 user，执行时需要输入目标用户的密码，<br>sudo <cmd> 可以以特权级别运行 cmd 命令，需要当前用户属于 sudo 组，且需要输入当前用户的密码。<br>su - <user> 命令也是切换用户，同时环境变量也会跟着改变成目标用户的环境变量。  </user></cmd></user></p>
<p><strong>新建用户</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo adduser lilei</div></pre></td></tr></table></figure></p>
<p>这个命令不但可以添加用户到系统，同时也会默认为新用户创建 home 目录  </p>
<blockquote>
<p>adduser 和 useradd 的区别是什么？</p>
</blockquote>
<p>答：adduser 会创建用户，创建目录，创建密码（提示你设置），做这一系列的操作。useradd 只创建用户，创建完了用 passwd lilei 去设置新用户的密码。其实 useradd、userdel 这类操作更像是一种命令，执行完了就返回。而 adduser 更像是一种程序，需要你输入、确定等一系列操作。</p>
<p><strong>切换登录用户</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">su -l lilei</div></pre></td></tr></table></figure></p>
<p>退出当前用户跟退出终端一样可以使用 exit 命令或者使用快捷键 Ctrl+d。  </p>
<h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><p>在 Linux 里面每个用户都有一个归属（用户组），用户组简单地理解就是一组用户的集合，它们共享一些资源和权限，同时拥有私有资源，就跟家的形式差不多，你的兄弟姐妹（不同的用户）属于同一个家（用户组），你们可以共同拥有这个家（共享资源），爸妈对待你们都一样（共享权限），你偶尔写写日记，其他人未经允许不能查看（私有资源和权限）。当然一个用户是可以属于多个用户组的，正如你既属于家庭，又属于学校或公司。  </p>
<p>查看自己属于哪些用户组  </p>
<p><strong>方法一：使用 groups 命令</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">groups lilei</div><div class="line">lilei : lilei</div></pre></td></tr></table></figure></p>
<p>其中冒号之前表示用户，后面表示该用户所属的用户组。这里可以看到 lilei 用户属于 lilei 用户组，每次新建用户如果不指定用户组的话，默认会自动创建一个与用户名相同的用户组（差不多就相当于家长的意思，或者说是老总）。默认情况下在 sudo 用户组里的可以使用 sudo 命令获得 root 权限。lilei 用户也可以使用 sudo 命令，为什么这里没有显示在 sudo 用户组里呢？可以查看下 /etc/sudoers.d/lilei 文件，我们在 /etc/sudoers.d 目录下创建了这个文件，从而给 lilei 用户赋予了 sudo 权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo cat /etc/sudoers.d/lilei</div><div class="line">lilei ALL=(ALL) NOPASSWD: ALL</div><div class="line">Defaults:lilei !requiretty</div></pre></td></tr></table></figure></p>
<p><strong>方法二：查看 /etc/group 文件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /etc/group | sort</div></pre></td></tr></table></figure></p>
<p>这里 cat 命令用于读取指定文件的内容并打印到终端输出，后面会详细讲它的使用。 | sort 表示将读取的文本进行一个字典排序再输出，然后你将看到如下一堆输出，可以在看到 lilei 的用户组信息  </p>
<p>使用命令过滤掉一些你不想看到的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cat /etc/group | grep -E &quot;lilei&quot;</div><div class="line">lilei:x:5000:</div></pre></td></tr></table></figure></p>
<p>etc/group 文件格式说明  </p>
<p>/etc/group 的内容包括用户组（Group）、用户组口令、GID 及该用户组所包含的用户（User），每个用户组一条记录。格式如下：  </p>
<blockquote>
<p>group_name:password:GID:user_list  </p>
</blockquote>
<p>上面的 password 字段为一个 x 并不是说密码就是它，只是表示密码不可见而已。  </p>
<p><strong>将其它用户加入 sudo 用户组</strong>  </p>
<p>默认情况下新创建的用户是不具有 root 权限的，也不在 sudo 用户组  </p>
<p>使用 usermod 命令可以为用户添加用户组，同样使用该命令你必需有 root 权限，你可以直接使用 root 用户为其它用户添加用户组，或者用其它已经在 sudo 用户组的用户使用 sudo 命令获取权限来执行该命令。</p>
<p>这里我用 shiyanlou 用户执行 sudo 命令将 lilei 添加到 sudo 用户组，让它也可以使用 sudo 命令获得 root 权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">su shiyanlou</div><div class="line">groups lilei</div><div class="line">sudo usermod -G sudo lilei</div><div class="line">groups lilei</div></pre></td></tr></table></figure></p>
<h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo deluser lilei --remove-home</div></pre></td></tr></table></figure>
<h2 id="Linux文件权限"><a href="#Linux文件权限" class="headerlink" title="Linux文件权限"></a>Linux文件权限</h2><h3 id="查看文件权限"><a href="#查看文件权限" class="headerlink" title="查看文件权限"></a>查看文件权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -l</div></pre></td></tr></table></figure>
<p><img src="http://i.imgur.com/9rWx5HJ.png" alt=""><br><img src="http://i.imgur.com/xDJurAX.png" alt="">  </p>
<ul>
<li><p>文件类型<br>关于文件类型，这里有一点你必需时刻牢记 <strong>Linux 里面一切皆文件</strong>，正因为这一点才有了设备文件（ /dev 目录下有各种设备文件，大都跟具体的硬件设备相关）。 socket：网络套接字。pipe 管道。软链接文件：链接文件是分为两种的，另一种当然是“硬链接”（硬链接不常用，而软链接等同于 Windows 上的快捷方式,你记住这一点就够了）。</p>
</li>
<li><p>文件权限<br>读权限，表示你可以使用 cat <file name=""> 之类的命令来读取某个文件的内容；<br>写权限，表示你可以编辑和修改某个文件；<br>执行权限，通常指可以运行的二进制程序文件或者脚本文件，如同 Windows 上的 exe 后缀的文件，不过 Linux 上不是通过文件后缀名来区分文件的类型。<br>需要注意的一点是，一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息。</file></p>
</li>
<li><p>链接数<br>链接到该文件所在的 inode 结点的文件名数目。  </p>
</li>
<li><p>文件大小  </p>
<blockquote>
<p>以 inode 结点大小为单位来表示的文件大小，可以给 ls 加上 -lh 参数来更直观的查看文件的大小。  </p>
</blockquote>
</li>
</ul>
<p>显示除了 .（当前目录）和 ..（上一级目录）之外的所有文件，包括隐藏文件（Linux 下以 . 开头的文件为隐藏文件）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -A</div></pre></td></tr></table></figure></p>
<p>查看某一个目录的完整属性，而不是显示目录里面的文件属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -dl &lt;目录名&gt;</div></pre></td></tr></table></figure></p>
<p>显示所有文件大小，并以普通人类能看懂的方式呈现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -AsSh</div></pre></td></tr></table></figure></p>
<p>其中小 s 为显示文件大小，大 S 为按文件大小排序，若需要知道如何按其它方式排序，请使用“man”命令查询。</p>
<h3 id="变更文件所有者"><a href="#变更文件所有者" class="headerlink" title="变更文件所有者"></a>变更文件所有者</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chown shiyanlou test.txt</div></pre></td></tr></table></figure>
<h3 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><p><strong>方式一：二进制数字表示</strong>  </p>
<p><img src="http://i.imgur.com/6tKnGVZ.png" alt="">  </p>
<p>每个文件的三组权限（拥有者，所属用户组，其他用户，记住这个顺序是一定的）对应一个 “ rwx “，也就是一个 “ 7 ”  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod 700 test.txt</div></pre></td></tr></table></figure>
<p><strong>方式二：加减赋值操作</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod go-rw test.txt</div></pre></td></tr></table></figure></p>
<p>g、o 还有 u 分别表示 group、others 和 user，+ 和 - 分别表示增加和去掉相应的权限。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;用户及文件权限管理&quot;&gt;&lt;a href=&quot;#用户及文件权限管理&quot; class=&quot;headerlink&quot; title=&quot;用户及文件权限管理&quot;&gt;&lt;/a&gt;用户及文件权限管理&lt;/h1&gt;&lt;h2 id=&quot;Linux用户管理&quot;&gt;&lt;a href=&quot;#Linux用户管理&quot; class
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Linux/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux基础" scheme="http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>02_Linux 目录结构</title>
    <link href="http://yoursite.com/2017/07/07/Linux/Base/02_Linux%20%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%8F%8A%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C(tree,cd,pwd,touch,mkdir,cp,rm,mv,rename,cat,tac,nl,more,less,head,tail)/"/>
    <id>http://yoursite.com/2017/07/07/Linux/Base/02_Linux 目录结构及文件基本操作(tree,cd,pwd,touch,mkdir,cp,rm,mv,rename,cat,tac,nl,more,less,head,tail)/</id>
    <published>2017-07-07T12:59:47.000Z</published>
    <updated>2017-07-07T12:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-目录结构"><a href="#Linux-目录结构" class="headerlink" title="Linux 目录结构"></a>Linux 目录结构</h1><p>在讲 Linux 目录结构之前，你首先要清楚一点，那就是 Linux 的目录与 Windows 的目录的区别，或许对于一般操作上的感受来说没有多大不同，但从它们的实现机制来说是完全不同的。  </p>
<p>一种不同是体现在目录与存储介质（磁盘，内存，DVD 等）的关系上，以往的 Windows 一直是以存储介质为主的，主要以盘符（C 盘，D 盘…）及分区来实现文件管理，然后之下才是目录，目录就显得不是那么重要，除系统文件之外的用户文件放在任何地方任何目录也是没有多大关系。所以通常 Windows 在使用一段时间后，磁盘上面的文件目录会显得杂乱无章（少数善于整理的用户除外吧）。然而 UNIX/Linux 恰好相反，UNIX 是以目录为主的，Linux 也继承了这一优良特性。 Linux 是以树形目录结构的形式来构建整个系统的，可以理解为树形目录是一个用户可操作系统的骨架。虽然本质上无论是目录结构还是操作系统内核都是存储在磁盘上的，但从逻辑上来说 Linux 的磁盘是“挂在”（挂载在）目录上的，每一个目录不仅能使用本地磁盘分区的文件系统，也可以使用网络上的文件系统。举例来说，可以利用网络文件系统（Network File System，NFS）服务器载入某特定目录等。  </p>
<ol>
<li>FHS 标准  </li>
</ol>
<p>Linux 的目录结构说复杂很复杂，说简单也很简单。复杂在于，因为系统的正常运行是以目录结构为基础的，对于初学者来说里面大部分目录都不知道其作用，重要与否，特别对于那些曾经的重度 Windows 用户，他们会纠结很长时间，关于我安装的软件在哪里这类问题。说它简单是因为，其中大部分目录结构是规定好了的（FHS 标准），是死的，当你掌握后，你在里面的一切操作都会变得井然有序。  </p>
<p>FHS（英文：Filesystem Hierarchy Standard 中文：文件系统层次结构标准），多数 Linux 版本采用这种文件组织形式，FHS 定义了系统中每个区域的用途、所需要的最小构成的文件和目录同时还给出了例外处理与矛盾处理。<br>FHS 定义了两层规范，第一层是， / 下面的各个目录应该要放什么文件数据，例如 /etc 应该放置设置文件，/bin 与 /sbin 则应该放置可执行文件等等。  </p>
<p>第二层则是针对 /usr 及 /var 这两个目录的子目录来定义。例如 /var/log 放置系统登录文件，/usr/share 放置共享数据等等。  </p>
<p><img src="http://i.imgur.com/DcLyTb0.png" alt="">  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tree /</div></pre></td></tr></table></figure>
<p>关于上面提到的 FHS，这里还有个很重要的内容你一定要明白，FHS 是根据以往无数 Linux 用户和开发者的经验总结出来的，并且会维持更新，FHS 依据文件系统使用的频繁与否以及是否允许用户随意改动（注意，不是不能，学习过程中，不要怕这些），将目录定义为四种交互作用的形态，如下表所示：</p>
<p><img src="http://i.imgur.com/Tg0PZPn.png" alt="">  </p>
<ol>
<li>目录路径</li>
</ol>
<p>路径</p>
<p>使用 cd 命令可以切换目录，在 Linux 里面使用 . 表示当前目录，.. 表示上一级目录（注意，以 . 开头的文件都是隐藏文件，所以这两个目录必然也是隐藏的，你可以使用 ls -a 命令查看隐藏文件）, - 表示上一次所在目录，～ 通常表示当前用户的 home 目录。使用 pwd 命令可以获取当前所在路径（绝对路径）。</p>
<p>进入上一级目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd ..</div></pre></td></tr></table></figure></p>
<p>进入当前用户的 home 目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ~</div><div class="line"># 或者 cd /home/&lt;你的用户名&gt;</div></pre></td></tr></table></figure></p>
<p>使用 pwd 获取当前路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pwd</div></pre></td></tr></table></figure></p>
<p><strong>绝对路径</strong></p>
<p>关于绝对路径，简单地说就是以根” / “目录为起点的完整路径，以你所要到的目录为终点，表现形式如：</p>
<p>/usr/local/bin，表示根目录下的 usr 目录中的 local 目录中的 bin 目录。</p>
<p><strong>相对路径</strong></p>
<p>相对路径，也就是相对于你当前的目录的路径，相对路径是以当前目录 . 为起点，以你所要到的目录为终点，表现形式如：</p>
<p>usr/local/bin （这里假设你当前目录为根目录）。你可能注意到，我们表示相对路径实际并没有加上表示当前目录的那个 . ，而是直接以目录名开头，因为这个 usr 目录为 / 目录下的子目录，是可以省略这个 . 的（以后会讲到一个类似不能省略的情况）；如果是当前目录的上一级目录，则需要使用 .. ，比如你当前目录为 home 目录，根目录就应该表示为 ../../ ，表示上一级目录（ home 目录）的上一级目录（ / 目录）。</p>
<h1 id="Linux-文件的基本操作"><a href="#Linux-文件的基本操作" class="headerlink" title="Linux 文件的基本操作"></a>Linux 文件的基本操作</h1><ol>
<li>新建</li>
</ol>
<p><strong>新建空白文件</strong>  </p>
<p>使用 touch 命令创建空白文件，关于 touch 命令，其主要作用是来更改已有文件的时间戳的（比如，最近访问时间，最近修改时间），但其在不加任何参数的情况下，只指定一个文件名，则可以创建一个指定文件名的空白文件（不会覆盖已有同名文件），当然你也可以同时指定该文件的时间戳。  </p>
<p><strong>新建目录</strong>  </p>
<p>使用 mkdir（make directories） 命令可以创建一个空目录，也可同时指定创建目录的权限属性。  </p>
<p>使用 -p 参数，同时创建父目录（如果不存在该父目录），如下我们同时创建一个多级目录（这在安装软件、配置安装路径时非常有用）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir -p father/son/grandson</div></pre></td></tr></table></figure></p>
<p>后面的目录路径，以绝对路径的方式表示也是可以的。  </p>
<ol>
<li>复制</li>
</ol>
<p><strong>复制文件</strong>  </p>
<p>使用 cp（copy）命令复制一个文件到指定目录。  </p>
<p>将之前创建的“ test.txt ”文件复制到“ /home/shiyanlou/father/son/grandson ”目录中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cp test.txt father/son/grandson</div></pre></td></tr></table></figure></p>
<p><strong>复制目录</strong><br>要成功复制目录需要加上 -r 或者 -R 参数，表示递归复制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp -r father family</div></pre></td></tr></table></figure></p>
<ol>
<li>删除</li>
</ol>
<p><strong>删除文件</strong>  </p>
<p>使用 rm（remove files or directories）命令删除一个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm text.txt</div></pre></td></tr></table></figure></p>
<p>使用 -f 参数强制删除：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm -f test.txt</div></pre></td></tr></table></figure></p>
<p><strong>删除目录</strong><br>跟复制目录一样，要删除一个目录，也需要加上 -r 或 -R 参数  </p>
<ol>
<li>移动文件与文件重命名</li>
</ol>
<p><strong>移动文件</strong><br>使用 mv（move or rename files）命令移动文件（剪切）。  </p>
<p>mv 源目录文件 目的目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mkdir Documents  </div><div class="line">$ mv file1 Documents</div></pre></td></tr></table></figure></p>
<p><strong>重命名文件</strong><br>mv 旧的文件名 新的文件名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mv oldname newname</div></pre></td></tr></table></figure></p>
<p><strong>批量重命名</strong></p>
<p>要实现批量重命名，mv 命令就有点力不从心了，我们可以使用一个看起来更专业的命令 rename 来实现。不过它要用 perl 正则表达式来作为参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 使用通配符批量创建 5 个文件:</div><div class="line">$ touch file&#123;1..5&#125;.txt</div><div class="line"></div><div class="line"># 批量将这 5 个后缀为 .txt 的文本文件重命名为以 .c 为后缀的文件:</div><div class="line">$ rename &apos;s/\.txt/\.c/&apos; *.txt</div><div class="line"></div><div class="line"># 批量将这 5 个文件，文件名改为大写:</div><div class="line">$ rename &apos;y/a-z/A-Z/&apos; *.c</div></pre></td></tr></table></figure>
<p>简单解释一下上面的命令，rename 是先使用第二个参数的通配符匹配所有后缀为 .txt 的文件，然后使用第一个参数提供的正则表达式将匹配的这些文件的 .txt 后缀替换为 .c  </p>
<ol>
<li>查看文件</li>
</ol>
<p>使用 cat，tac 和 nl 命令查看文件</p>
<p>前两个命令都是用来打印文件内容到标准输出（终端）， cat 为正序显示，tac 为倒序显示。  </p>
<p>标准输入输出：当我们执行一个 shell 命令行时通常会自动打开三个标准文件，即标准输入文件（stdin），默认对应终端的键盘、标准输出文件（stdout）和标准错误输出文件（stderr），后两个文件都对应被重定向到终端的屏幕，以便我们能直接看到输出内容。进程将从标准输入文件中得到输入数据，将正常输出数据输出到标准输出文件，而将错误信息送到标准错误文件中。  </p>
<p>比如我们要查看之前从 /etc 目录下拷贝来的 passwd 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat passwd</div></pre></td></tr></table></figure></p>
<p>可以加上 -n 参数显示行号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat -n passwd</div></pre></td></tr></table></figure></p>
<p>nl 命令，添加行号并打印，这是个比 cat -n 更专业的行号打印命令。  </p>
<p>这里简单列举它的常用的几个参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">-b : 指定添加行号的方式，主要有两种：  </div><div class="line">    -b a:表示无论是否为空行，同样列出行号(&quot;cat -n&quot;就是这种方式)  </div><div class="line">    -b t:只列出非空行的编号并列出（默认为这种方式）  </div><div class="line">-n : 设置行号的样式，主要有三种：  </div><div class="line">    -n ln:在行号字段最左端显示  </div><div class="line">    -n rn:在行号字段最右边显示，且不加 0  </div><div class="line">    -n rz:在行号字段最右边显示，且加 0  </div><div class="line">-w : 行号字段占用的位数(默认为 6 位)</div></pre></td></tr></table></figure></p>
<p><strong>使用 more 和 less 命令分页查看文件</strong>  </p>
<p>如果说上面的 cat 是用来快速查看一个文件的内容的，那么这个 more 和 less 就是天生用来”阅读”一个文件的内容的，比如说 man 手册内部就是使用的 less 来显示内容。其中 more 命令比较简单，只能向一个方向滚动，而 less 为基于 more 和 vi 开发，功能更强大。less 的使用基本和 more 一致。  </p>
<p>使用 more 命令打开 passwd 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ more test.txt</div></pre></td></tr></table></figure></p>
<p>打开后默认只显示一屏内容，终端底部显示当前阅读的进度。可以使用 Enter 键向下滚动一行，使用 Space 键向下滚动一屏，按下 h 显示帮助，q 退出。  </p>
<p><strong>使用 head 和 tail 命令查看文件</strong>  </p>
<p>只查看文件的头几行（默认为 10 行，不足 10 行则显示全部）和尾几行。还是拿 passwd 文件举例，比如当我们想要查看最近新增加的用户，那么我们可以查看这个 /etc/passwd 文件。因为系统新增加一个用户，会将用户的信息添加到 passwd 文件的最后，那么这时候我们就可以使用 tail 命令了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tail /etc/passwd</div></pre></td></tr></table></figure></p>
<p>甚至更直接的只看一行， 加上 -n 参数，后面紧跟行数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tail -n 1 /etc/passwd</div></pre></td></tr></table></figure></p>
<p>关于 tail 命令，不得不提的还有它一个很牛的参数 -f，这个参数可以实现不停地读取某个文件的内容并显示。这可以让我们动态查看日志，达到实时监视的目的。  </p>
<ol>
<li>查看文件类型</li>
</ol>
<p>在 Linux 中文件的类型不是根据文件后缀来判断的，我们通常使用 file 命令查看文件的类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">file /bin/ls</div><div class="line">/bin/ls: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=...., stripped</div></pre></td></tr></table></figure></p>
<p>说明这是一个可执行文件，运行在 64 位平台，并使用了动态链接文件（共享库）。</p>
<ol>
<li>编辑文件</li>
</ol>
<p>在 Linux 下面编辑文件通常我们会直接使用专门的命令行编辑器比如（emacs，vim，nano），由于涉及 Linux 上的编辑器的内容比较多，且非常重要。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux-目录结构&quot;&gt;&lt;a href=&quot;#Linux-目录结构&quot; class=&quot;headerlink&quot; title=&quot;Linux 目录结构&quot;&gt;&lt;/a&gt;Linux 目录结构&lt;/h1&gt;&lt;p&gt;在讲 Linux 目录结构之前，你首先要清楚一点，那就是 Linux 的目录
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Linux/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux基础" scheme="http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>10_Linux 数据流重定向</title>
    <link href="http://yoursite.com/2017/07/07/Linux/Base/10_%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>http://yoursite.com/2017/07/07/Linux/Base/10_数据流重定向/</id>
    <published>2017-07-07T12:59:47.000Z</published>
    <updated>2017-07-07T12:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据流重定向"><a href="#数据流重定向" class="headerlink" title="数据流重定向"></a>数据流重定向</h1><p>Linux 默认提供了三个特殊设备，用于终端的显示和输出，分别为stdin（标准输入,对应于你在终端的输入），stdout（标准输出，对应于终端的输出），stderr（标准错误输出，对应于终端的输出）。  </p>
<p>Linux 默认提供了三个特殊设备，用于终端的显示和输出，分别为stdin（标准输入,对应于你在终端的输入），stdout（标准输出，对应于终端的输出），stderr（标准错误输出，对应于终端的输出）。  </p>
<table>
<thead>
<tr>
<th>文件描述符</th>
<th>设备文件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>/dev/stdin</td>
<td>标准输入</td>
</tr>
<tr>
<td>1</td>
<td>/dev/stdout</td>
<td>标准输出</td>
</tr>
<tr>
<td>2</td>
<td>/dev/stderr</td>
<td>标准错误</td>
</tr>
</tbody>
</table>
<blockquote>
<p>文件描述符：文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。  </p>
</blockquote>
<p>另外还有一个符号-,它可以同时作为前一个命令的。  </p>
<p>我们可以这样使用这些文件描述符：  </p>
<p>默认使用终端的标准输入作为命令的输入和标准输出作为命令的输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cat </div><div class="line">（按Ctrl+C退出）\</div></pre></td></tr></table></figure></p>
<p>将cat的连续输出（heredoc方式）重定向到一个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ mkdir Documents</div><div class="line">$ cat &gt; Documents/test.c &lt;&lt;EOF</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    printf(&quot;hello world\n&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<p>将一个文件作为命令的输入，标准输出作为命令的输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat Documents/test.c</div></pre></td></tr></table></figure></p>
<p>将echo命令通过管道传过来的数据作为cat命令的输入，将标准输出作为命令的输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ echo &apos;hi&apos; | cat</div></pre></td></tr></table></figure></p>
<p>将echo命令的输出从默认的标准输出重定向到一个普通文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ echo &apos;hello shiyanlou&apos; &gt; redirect</div><div class="line">$ cat redirect</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/qvu4wha.png" alt="">  </p>
<p>不要将管道和重定向混淆，管道默认是连接前一个命令的输出到下一个命令的输入，而重定向通常是需要一个文件来建立两个命令的连接，你可以仔细体会一下上述第三个操作和最后两个操作的异同点。  </p>
<h1 id="标准错误重定向"><a href="#标准错误重定向" class="headerlink" title="标准错误重定向"></a>标准错误重定向</h1><p>重定向标准输出到文件，这是一个很实用的操作，另一个很实用的操作是将标准错误重定向，标准输出和标准错误都被指向伪终端的屏幕显示，所以我们经常看到的一个命令的输出通常是同时包含了标准输出和标准错误的结果的。比如下面的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 使用cat 命令同时读取两个文件，其中一个存在，另一个不存在</div><div class="line">$ cat Documents/test.c hello.c</div><div class="line"># 你可以看到除了正确输出了前一个文件的内容，还在末尾出现了一条错误信息</div><div class="line"># 下面我们将输出重定向到一个文件，根据我们前面的经验，这里将在看不到任何输出了</div><div class="line">$ cat Documents/test.c hello.c &gt; somefile</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/fwOu6Ag.png" alt="">  </p>
<p>标准输出和标准错误虽然都指向终端屏幕，实际它们并不一样。  </p>
<p>隐藏某些错误或者警告<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 将标准错误重定向到标准输出，再将标准输出重定向到文件，注意要将重定向到文件写到前面</div><div class="line">$ cat Documents/test.c hello.c &gt;somefile  2&gt;&amp;1</div><div class="line"># 或者只用bash提供的特殊的重定向符号&quot;&amp;&quot;将标准错误和标准输出同时重定向到文件</div><div class="line">$ cat Documents/test.c hello.c &amp;&gt;somefilehell</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意你应该在输出重定向文件描述符前加上&amp;,否则shell会当做重定向到一个文件名为1的文件中</p>
</blockquote>
<p><img src="http://i.imgur.com/DgADysY.png" alt="">  </p>
<h1 id="使用tee命令同时重定向到多个文件"><a href="#使用tee命令同时重定向到多个文件" class="headerlink" title="使用tee命令同时重定向到多个文件"></a>使用tee命令同时重定向到多个文件</h1><p>经常可能还有这样的需求，除了将需要将输出重定向到文件之外也需要将信息打印在终端，那么你可以使用tee命令来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ echo &apos;hello shiyanlou&apos; | tee hello</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/nZsrUeT.png" alt="">  </p>
<h1 id="永久重定向"><a href="#永久重定向" class="headerlink" title="永久重定向"></a>永久重定向</h1><p>前面的重定向操作都只是临时性的，即只对当前命令有效，如何做到“永久”有效呢，比如在一个脚本中，你需要某一部分的命令的输出全部进行重定向，难道要在每个命令上面加上临时重定向的操作嘛，当然不需要，可以使用exec命令实现“永久”重定向。exec命令的作用是使用指定的命令替换当前的 Shell，及使用一个进程替换当前进程，或者指定新的重定向：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 先开启一个子 Shell</div><div class="line">$ zsh</div><div class="line"># 使用exec替换当前进程的重定向，将标准输出重定向到一个文件</div><div class="line">$ exec 1&gt;somefile</div><div class="line"># 后面你执行的命令的输出都将被重定向到文件中,直到你退出当前子shell，或取消exec的重定向（后面将告诉你怎么做）</div><div class="line">$ ls</div><div class="line">$ exit</div><div class="line">$ cat somefile</div></pre></td></tr></table></figure></p>
<p><img src="http://i.imgur.com/44lTnGF.png" alt="">  </p>
<h1 id="创建输出文件描述符"><a href="#创建输出文件描述符" class="headerlink" title="创建输出文件描述符"></a>创建输出文件描述符</h1><p>默认在 Shell 中可以有9个打开的文件描述符，上面使用了也是它默认提供的0,1,2号文件描述符，另外还可以使用3-8的文件描述符，只是它们默认没有打开而已，可以使用下面命令查看当前 Shell 进程中打开的文件描述符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cd /dev/fd/;ls -Al</div></pre></td></tr></table></figure></p>
<p>同样使用exec命令可以创建新的文件描述符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ zsh</div><div class="line">$ exec 3&gt;somefile</div><div class="line"># 先进入目录，再查看，否则你可能不能得到正确的结果，然后再回到上一次的目录</div><div class="line">$ cd /dev/fd/;ls -Al;cd -</div><div class="line"># 注意下面的命令&gt;与&amp;之间不应该有空格，如果有空格则会出错</div><div class="line">$ echo &quot;this is test&quot; &gt;&amp;3</div><div class="line">$ cat somefile</div><div class="line">$ exit</div></pre></td></tr></table></figure></p>
<h1 id="关闭文件描述符"><a href="#关闭文件描述符" class="headerlink" title="关闭文件描述符"></a>关闭文件描述符</h1><p>如上面打开的3号文件描述符，可以使用如下操作将它关闭：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ exec 3&gt;&amp;-</div><div class="line">$ cd /dev/fd;ls -Al;cd -</div></pre></td></tr></table></figure></p>
<h1 id="完全屏蔽命令的输出"><a href="#完全屏蔽命令的输出" class="headerlink" title="完全屏蔽命令的输出"></a>完全屏蔽命令的输出</h1><p>在 Linux 中有一个被称为“黑洞”的设备文件,所以导入它的数据都将被“吞噬”。</p>
<p>在类 UNIX 系统中，/dev/null，或称空设备，是一个特殊的设备文件，它通常被用于丢弃不需要的输出流，或作为用于输入流的空文件，这些操作通常由重定向完成。读取它则会立即得到一个EOF。<br>我们可以利用设个/dev/null屏蔽命令的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat Documents/test.c nefile 1&gt;/dev/null 2&gt;&amp;1</div></pre></td></tr></table></figure></p>
<p>上面这样的操作将使你得不到任何输出结果。</p>
<h1 id="使用-xargs-分割参数列表"><a href="#使用-xargs-分割参数列表" class="headerlink" title="使用 xargs 分割参数列表"></a>使用 xargs 分割参数列表</h1><p>xargs 是一条 UNIX 和类 UNIX 操作系统的常用命令。它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。<br>这个命令在有些时候十分有用，特别是当用来处理产生大量输出结果的命令如 find，locate 和 grep 的结果，详细用法请参看 man 文档。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cut -d: -f1 &lt; /etc/passwd | sort | xargs echo</div></pre></td></tr></table></figure></p>
<p>上面这个命令用于将/etc/passwd文件按:分割取第一个字段排序后，使用echo命令生成一个列表。</p>
<h1 id="使用文本处理"><a href="#使用文本处理" class="headerlink" title="使用文本处理"></a>使用文本处理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat data1 | cut -c 8- | sort|uniq -dc|sort -rn -k1 |head -3 &gt; /home/shiyanlou/result</div></pre></td></tr></table></figure>
<p>解释:</p>
<ol>
<li><p>cut -c 8- 取出每行的第八个字符以后的所有字符</p>
</li>
<li><p>sort将文件/文本的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。</p>
</li>
<li><p>uniq -dc 只显示重复行，并在输出行前面加上每行在输入文件中出现的次数</p>
</li>
<li><p>sort -rn -k1 把3的结果反向按照数字进行排序 -k1是取第一个区间进行排序(第一个区间即是每行出现的次数)</p>
</li>
<li><p>head -3 把排序好的结果取前三个即为出现频率最高的三个</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据流重定向&quot;&gt;&lt;a href=&quot;#数据流重定向&quot; class=&quot;headerlink&quot; title=&quot;数据流重定向&quot;&gt;&lt;/a&gt;数据流重定向&lt;/h1&gt;&lt;p&gt;Linux 默认提供了三个特殊设备，用于终端的显示和输出，分别为stdin（标准输入,对应于你在终端的输入）
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Linux/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux基础" scheme="http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>03_Linux 环境变量</title>
    <link href="http://yoursite.com/2017/07/07/Linux/Base/03_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE(PATH,whereis,locate,which,find)/"/>
    <id>http://yoursite.com/2017/07/07/Linux/Base/03_环境变量与文件查找(PATH,whereis,locate,which,find)/</id>
    <published>2017-07-07T12:59:47.000Z</published>
    <updated>2017-07-07T12:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>要解释环境变量，得先明白变量是什么，准确的说应该是 Shell 变量，所谓变量就是计算机中用于记录一个值（不一定是数值，也可以是字符或字符串）的符号，而这些符号将用于不同的运算处理中。通常变量与值是一对一的关系，可以通过表达式读取它的值并赋值给其它变量，也可以直接指定数值赋值给任意变量。为了便于运算和处理，大部分的编程语言会区分变量的类型，用于分别记录数值、字符或者字符串等等数据类型。Shell 中的变量也基本如此，有不同类型（但不用专门指定类型名），可以参与运算，有作用域限定。</p>
<blockquote>
<p>变量的作用域即变量的有效范围（比如一个函数中、一个源文件中或者全局范围），在该范围内只能有一个同名变量。一旦离开则该变量无效，如同不存在这个变量一般。  </p>
</blockquote>
<p>使用 declare 命令创建一个变量名为 tmp 的变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">declare tmp</div><div class="line"># 使用 = 号赋值运算符，将变量 tmp 赋值为 lilei</div><div class="line">tmp=lilei</div></pre></td></tr></table></figure></p>
<p>读取变量的值，使用 echo 命令和 $ 符号（$ 符号用于表示引用一个变量的值，初学者经常忘记输入）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo $tmp</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：并不是任何形式的变量名都是可用的，变量名只能是英文字母、数字或者下划线，且不能以数字作为开头。  </p>
</blockquote>
<h2 id="环境变量-1"><a href="#环境变量-1" class="headerlink" title="环境变量"></a>环境变量</h2><p>简单理解了变量的概念，就很容易理解环境变量了。环境变量的作用域比自定义变量的要大，如 Shell 的环境变量作用于自身和它的子进程。在所有的 UNIX 和类 UNIX 系统中，每个进程都有其各自的环境变量设置，且默认情况下，当一个进程被创建时，处理创建过程中明确指定的话，它将继承其父进程的绝大部分环境设置。Shell 程序也作为一个进程运行在操作系统之上，而我们在 Shell 中运行的大部分命令都将以 Shell 的子进程的方式运行。  </p>
<p><img src="http://i.imgur.com/f8Dll3O.png" alt="">  </p>
<p>通常我们会涉及到的变量类型有三种：  </p>
<ol>
<li>当前 Shell 进程私有用户自定义变量，如上面我们创建的 tmp 变量，只在当前 Shell 中有效。  </li>
<li>Shell 本身内建的变量。  </li>
<li>从自定义变量导出的环境变量。  </li>
</ol>
<p>也有三个与上述三种环境变量相关的命令：set，env，export。这三个命令很相似，都是用于打印环境变量信息，区别在于涉及的变量范围不同。详见下表：  </p>
<table>
<thead>
<tr>
<th>命 令</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>set</td>
<td>显示当前 Shell 所有变量，包括其内建环境变量（与 Shell 外观等相关），用户自定义变量及导出的环境变量。</td>
</tr>
<tr>
<td>env</td>
<td>显示与当前用户相关的环境变量，还可以让命令在指定环境中运行。</td>
</tr>
<tr>
<td>export</td>
<td>显示从 Shell 中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量。</td>
</tr>
</tbody>
</table>
<p>使用 vimdiff 工具比较一下它们之间的差别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ temp=shiyanlou</div><div class="line">$ export temp_env=shiyanlou</div><div class="line">$ env|sort&gt;env.txt</div><div class="line">$ export|sort&gt;export.txt</div><div class="line">$ set|sort&gt;set.txt</div><div class="line">  </div><div class="line">$ vimdiff env.txt eport.txt set.txt</div></pre></td></tr></table></figure></p>
<p>注意：为了与普通变量区分，通常我们习惯将环境变量名设为大写。  </p>
<p><strong>永久生效</strong></p>
<p>但是问题来了，当你关机后，或者关闭当前的 shell 之后，环境变量就没了啊。怎么才能让环境变量永久生效呢？  </p>
<p>按变量的生存周期来划分，Linux 变量可分为两类：  </p>
<ol>
<li>永久的：需要修改配置文件，变量永久生效；  </li>
<li>临时的：使用 export 命令行声明即可，变量在关闭 shell 时失效。  </li>
</ol>
<p>两个重要文件 /etc/bashrc（有的 Linux 没有这个文件） 和 /etc/profile ，它们分别存放的是 shell 变量和环境变量。  </p>
<p>还有要注意区别的是每个用户目录下的一个隐藏文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># .profile 可以用 ls -a 查看</div><div class="line">cd /home/shiyanlou</div><div class="line">ls -a</div></pre></td></tr></table></figure></p>
<p>这个 .profile 只对当前用户永久生效。而写在 /etc/profile 里面的是对所有用户永久生效，所以如果想要添加一个永久生效的环境变量，只需要打开 /etc/profile，在最后加上你想添加的环境变量就好啦。</p>
<h2 id="命令的查找路径与顺序"><a href="#命令的查找路径与顺序" class="headerlink" title="命令的查找路径与顺序"></a>命令的查找路径与顺序</h2><p>PATH 里面保存了 Shell 中执行的命令的搜索路径。</p>
<p>Shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">for ((i=0; i&lt;10; i++));do</div><div class="line">    echo &quot;hello shell&quot;</div><div class="line">done</div><div class="line">  </div><div class="line">exit 0</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">chomd 755 hello_shell.sh</div><div class="line">  </div><div class="line">./hello_sh.sh</div></pre></td></tr></table></figure>
<p>C<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">  </div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    prinf(&quot;hello world!\n&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -o hello_world hello_world.c</div></pre></td></tr></table></figure>
<p>gcc 生成二进制文件默认具有可执行权限，不需要修改  </p>
<h2 id="添加自定义路径到“-PATH-”环境变量"><a href="#添加自定义路径到“-PATH-”环境变量" class="headerlink" title="添加自定义路径到“ PATH ”环境变量"></a>添加自定义路径到“ PATH ”环境变量</h2><p>PATH 里面的路径是以 : 作为分割符的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PATH=$PATH:/home/shiyanlou/mybin</div></pre></td></tr></table></figure></p>
<p>给 PATH 环境变量追加了一个路径，它也只是在当前 Shell 有效，一旦退出终端，再打开就失效了。</p>
<p>在每个用户的 home 目录中有一个 Shell 每次启动时会默认执行一个配置脚本，以初始化环境，包括添加一些用户自定义环境变量等等。zsh 的配置文件是 .zshrc，相应 Bash 的配置文件为 .bashrc 。它们在 etc 下还都有一个或多个全局的配置文件，不过我们一般只修改用户目录下的配置文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &quot;PATH=$PATH:/home/shiyanlou/mybin&quot; &gt;&gt; .zshrc</div></pre></td></tr></table></figure></p>
<p><code>&gt;&gt;</code> 表示将标准输出以追加的方式重定向到一个文件中，注意前面用到的 <code>&gt;</code> 是以覆盖的方式重定向到一个文件中，使用的时候一定要注意分辨。在指定文件不存在的情况下都会创建新的文件。</p>
<h2 id="修改和删除已有变量"><a href="#修改和删除已有变量" class="headerlink" title="修改和删除已有变量"></a>修改和删除已有变量</h2><p><strong>变量修改</strong><br>|   变量设置方式   |   说明   |<br>| —- | —- |<br>|   ${变量名#匹配字串}   |   从头向后开始匹配，删除符合匹配字串的最短数据   |<br>|   ${变量名##匹配字串}   |   从头向后开始匹配，删除符合匹配字串的最长数据   |<br>|   ${变量名%匹配字串}   |   从尾向前开始匹配，删除符合匹配字串的最短数据   |<br>|   ${变量名%%匹配字串}   |   从尾向前开始匹配，删除符合匹配字串的最长数据   |<br>|   ${变量名/旧的字串/新的字串}   |   将符合旧字串的第一个字串替换为新的字串   |<br>|   ${变量名//旧的字串/新的字串}   |   将符合旧字串的全部字串替换为新的字串   |</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ path=$PATH</div><div class="line">$ echo $path</div><div class="line">$ path=$&#123;path%/home/shiyanlou/mybin&#125;</div><div class="line"># 或使用通配符,*表示任意多个任意字符</div><div class="line">$ path=$&#123;path%*/mybin&#125;</div></pre></td></tr></table></figure>
<p><strong>变量删除</strong></p>
<p>可以使用 unset 命令删除一个环境变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ unset temp</div></pre></td></tr></table></figure></p>
<h2 id="如何让环境变量立即生效"><a href="#如何让环境变量立即生效" class="headerlink" title="如何让环境变量立即生效"></a>如何让环境变量立即生效</h2><p>前面我们在 Shell 中修改了一个配置脚本文件之后（比如 zsh 的配置文件 home 目录下的 .zshrc），每次都要退出终端重新打开甚至重启主机之后其才能生效，很是麻烦，我们可以使用 source 命令来让其立即生效，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ source .zshrc</div></pre></td></tr></table></figure></p>
<p>source 命令还有一个别名就是 .，注意与表示当前路径的那个点区分开，虽然形式一样，但作用和使用方式一样，上面的命令如果替换成 . 的方式就该是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ . ./.zshrc</div></pre></td></tr></table></figure></p>
<p>注意第一个点后面有一个空格，而且后面的文件必须指定完整的绝对或相对路径名，source 则不需要。</p>
<h1 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h1><p>与搜索相关的命令常用的有 whereis，locate，which 和 find 。  </p>
<p><strong>whereis 简单快速</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$whereis who</div></pre></td></tr></table></figure></p>
<p>这个搜索很快，因为它并没有从硬盘中依次查找，而是直接从数据库中查询。whereis 只能搜索二进制文件(-b)，man 帮助文件(-m)和源代码文件(-s)。如果想要获得更全面的搜索结果可以使用 locate 命令。  </p>
<p><strong>locate 快而全</strong><br>通过“ /var/lib/mlocate/mlocate.db ”数据库查找，不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行 updatedb 命令更新一次，所以有时候你刚添加的文件，它可能会找不到，需要手动执行一次 updatedb 命令。  </p>
<p>它可以用来查找指定目录下的不同文件类型，如查找 /etc 下所有以 sh 开头的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">locate /etc/sh</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意，它不只是在 /etc 目录下查找，还会自动递归子目录进行查找。  </p>
</blockquote>
<p>查找 /usr/share/ 下所有 jpg 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">locate /usr/share/\*.jpg</div></pre></td></tr></table></figure></p>
<p>如果想只统计数目可以加上 -c 参数，-i 参数可以忽略大小写进行查找，whereis 的 -b、-m、-s 同样可以使用。  </p>
<p><strong>which 小而精</strong><br>which 本身是 Shell 内建的一个命令，我们通常使用 which 来确定是否安装了某个指定的软件，因为它只从 PATH 环境变量指定的路径中去搜索命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">which man</div></pre></td></tr></table></figure></p>
<p><strong>find 精而细</strong><br>find 应该是这几个命令中最强大的了，它不但可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索。  </p>
<p>这条命令表示去 /etc/ 目录下面 ，搜索名字叫做 interfaces 的文件或者目录。这是 find 命令最常见的格式，千万记住 find 的第一个参数是要搜索的地方：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo find /etc/ -name interfaces</div></pre></td></tr></table></figure></p>
<p>注意 find 命令的路径是作为第一个参数的， 基本命令格式为 find [path] [option] [action] 。  </p>
<p>与时间相关的命令参数：<br>参数    说明<br>-atime    最后访问时间<br>-ctime    最后修改文件内容的时间<br>-mtime    最后修改文件属性的时间<br>下面以 -mtime 参数举例：</p>
<p>-mtime n：n 为数字，表示为在 n 天之前的“一天之内”修改过的文件<br>-mtime +n：列出在 n 天之前（不包含 n 天本身）被修改过的文件<br>-mtime -n：列出在 n 天之内（包含 n 天本身）被修改过的文件<br>-newer file：file 为一个已存在的文件，列出比 file 还要新的文件名  </p>
<p><img src="http://i.imgur.com/fhih7gR.png" alt="">  </p>
<p>列出 home 目录中，当天（24 小时之内）有改动的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ find ~ -mtime 0</div></pre></td></tr></table></figure></p>
<p>列出用户家目录下比 Code 文件夹新的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ find ~ -newer /home/shiyanlou/Code</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;环境变量&quot;&gt;&lt;a href=&quot;#环境变量&quot; class=&quot;headerlink&quot; title=&quot;环境变量&quot;&gt;&lt;/a&gt;环境变量&lt;/h1&gt;&lt;h2 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Linux/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux基础" scheme="http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>04_Linux 文件打包与压缩</title>
    <link href="http://yoursite.com/2017/07/07/Linux/Base/04_%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8E%E5%8E%8B%E7%BC%A9(zip,rar,tar)/"/>
    <id>http://yoursite.com/2017/07/07/Linux/Base/04_文件打包与压缩(zip,rar,tar)/</id>
    <published>2017-07-07T12:59:47.000Z</published>
    <updated>2017-07-07T12:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件打包与压缩"><a href="#文件打包与压缩" class="headerlink" title="文件打包与压缩"></a>文件打包与压缩</h1><p>在 Windows 上最常见的不外乎这三种<code>*.zip，*.rar，*.7z</code>后缀的压缩文件，<br>而在 Linux 上面常见常用的除了以上三种外，还有<code>*.gz，*.xz，*.bz2，*.tar，*.tar.gz，*.tar.xz，*.tar.bz2</code>，简单介绍如下：</p>
<table>
<thead>
<tr>
<th>文件后缀名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*.zip</td>
<td>zip 程序打包压缩的文件</td>
</tr>
<tr>
<td>*.rar</td>
<td>rar 程序压缩的文件</td>
</tr>
<tr>
<td>*.7z</td>
<td>7zip 程序压缩的文件</td>
</tr>
<tr>
<td>*.tar</td>
<td>tar 程序打包，未压缩的文件</td>
</tr>
<tr>
<td>*.gz</td>
<td>gzip 程序（GNU zip）压缩的文件</td>
</tr>
<tr>
<td>*.xz</td>
<td>xz程序压缩的文件</td>
</tr>
<tr>
<td>*.bz2</td>
<td>bzip2 程序压缩的文件</td>
</tr>
<tr>
<td>*.tar.gz</td>
<td>tar 打包，gzip 程序压缩的文件</td>
</tr>
<tr>
<td>*.tar.xz</td>
<td>tar 打包，xz 程序压缩的文件</td>
</tr>
<tr>
<td>*tar.bz2</td>
<td>tar 打包，bzip2 程序压缩的文件</td>
</tr>
<tr>
<td>*.tar.7z</td>
<td>tar 打包，7z 程序压缩的文件</td>
</tr>
</tbody>
</table>
<h1 id="zip-压缩打包程序"><a href="#zip-压缩打包程序" class="headerlink" title="zip 压缩打包程序"></a>zip 压缩打包程序</h1><ul>
<li>使用 zip 打包文件夹：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ zip -r -q -o shiyanlou.zip /home/shiyanlou</div><div class="line">$ du -h shiyanlou.zip</div><div class="line">$ file shiyanlou.zip</div></pre></td></tr></table></figure>
</li>
</ul>
<p>第一行命令中，-r 参数表示递归打包包含子目录的全部内容，-q 参数表示为安静模式，即不向屏幕输出信息，-o，表示输出文件，需在其后紧跟打包输出文件名<br>后面使用 du 命令查看打包后文件的大小  </p>
<ul>
<li>设置压缩级别为 9 和 1（9 最大，1 最小），重新打包<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ zip -r -9 -q -o shiyanlou_9.zip /home/shiyanlou -x ~/*.zip</div><div class="line">$ zip -r -1 -q -o shiyanlou_1.zip /home/shiyanlou -x ~/*.zip</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这里添加了一个参数用于设置压缩级别 -[1-9]，1 表示最快压缩但体积大，9 表示体积最小但耗时最久。最后那个 -x 是为了排除我们上一次创建的 zip 文件，否则又会被打包进这一次的压缩文件中  </p>
<blockquote>
<p>注意：这里只能使用绝对路径，否则不起作用。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">du -h -d 0 *.zip ~ | sort</div></pre></td></tr></table></figure>
<p>通过 man 手册可知：  </p>
<ul>
<li>h， –human-readable  </li>
<li>d， –max-depth（所查看文件的深度）  </li>
</ul>
<ul>
<li>创建加密 zip 包<br>使用 -e 参数可以创建加密压缩包：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">zip -r -e -o shiyanlou_encryption.zip /home/shiyanlou</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>注意： 关于 zip 命令，因为 Windows 系统与 Linux/Unix 在文本文件格式上的一些兼容问题，比如换行符（为不可见字符），在 Windows 为 CR+LF（Carriage-Return+Line-Feed：回车加换行），而在 Linux/Unix 上为 LF（换行），所以如果在不加处理的情况下，<strong>在 Linux 上编辑的文本，在 Windows 系统上打开可能看起来是没有换行的</strong>。如果你想让你在 Linux 创建的 zip 压缩文件在 Windows 上解压后没有任何问题，那么你还需要对命令做一些修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">zip -r -l -o shiyanlou.zip /home/shiyanlou</div></pre></td></tr></table></figure></p>
</blockquote>
<p>需要加上 -l 参数将 LF 转换为 CR+LF 来达到以上目的。  </p>
<h1 id="使用-unzip-命令解压缩-zip-文件"><a href="#使用-unzip-命令解压缩-zip-文件" class="headerlink" title="使用 unzip 命令解压缩 zip 文件"></a>使用 unzip 命令解压缩 zip 文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unzip shiyanlou.zip</div></pre></td></tr></table></figure>
<p>使用安静模式，将文件解压到指定目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unzip -q shiyanlou.zip -d ziptest</div></pre></td></tr></table></figure></p>
<p>上述指定目录不存在，将会自动创建。如果你不想解压只想查看压缩包的内容你可以使用 -l 参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unzip -l shiyanlou.zip</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意： 使用 unzip 解压文件时我们同样应该注意兼容问题，不过这里我们关心的不再是上面的问题，而是中文编码的问题，通常 Windows 系统上面创建的压缩文件，如果有有包含中文的文档或以中文作为文件名的文件时默认会采用 GBK 或其它编码，而 Linux 上面默认使用的是 UTF-8 编码，如果不加任何处理，直接解压的话可能会出现中文乱码的问题（有时候它会自动帮你处理），为了解决这个问题，我们可以在解压时指定编码类型。</p>
</blockquote>
<p>使用 -O（英文字母，大写 o）参数指定编码类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unzip -O GBK 中文压缩文件.zip</div></pre></td></tr></table></figure></p>
<h1 id="rar-打包压缩命令"><a href="#rar-打包压缩命令" class="headerlink" title="rar 打包压缩命令"></a>rar 打包压缩命令</h1><p>rar 也是 Windows 上常用的一种压缩文件格式，在 Linux 上可以使用 rar 和 unrar 工具分别创建和解压 rar 压缩包  </p>
<ul>
<li><p>安装 rar 和 unrar 工具：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get update</div><div class="line">$ sudo apt-get install rar unrar</div></pre></td></tr></table></figure>
</li>
<li><p>从指定文件或目录创建压缩包或添加文件到压缩包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ rm *.zip</div><div class="line">$ rar a shiyanlou.rar .</div></pre></td></tr></table></figure>
</li>
</ul>
<p>上面的命令使用 a 参数添加一个目录 ～ 到一个归档文件中，如果该文件不存在就会自动创建。  </p>
<blockquote>
<p>注意：rar 的命令参数没有 -，如果加上会报错。</p>
</blockquote>
<p>从指定压缩包文件中删除某个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rar d shiyanlou.rar .zshrc</div></pre></td></tr></table></figure></p>
<p>查看不解压文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rar l shiyanlou.rar</div></pre></td></tr></table></figure></p>
<p>使用 unrar 解压 rar 文件<br>全路径解压：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ unrar x shiyanlou.rar</div></pre></td></tr></table></figure></p>
<p>去掉路径解压：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mkdir tmp</div><div class="line">$ unrar e shiyanlou.rar tmp/</div></pre></td></tr></table></figure></p>
<p>rar 命令参数非常多，上面只涉及了一些基本操作。  </p>
<h1 id="tar-打包工具"><a href="#tar-打包工具" class="headerlink" title="tar 打包工具"></a>tar 打包工具</h1><p>在 Linux 上面更常用的是 tar 工具，tar 原本只是一个打包工具，只是同时还是实现了对 7z、gzip、xz、bzip2 等工具的支持，这些压缩工具本身只能实现对文件或目录（单独压缩目录中的文件）的压缩，没有实现对文件的打包压缩，所以我们也无需再单独去学习其他几个工具，tar 的解压和压缩都是同一个命令，只需参数不同，使用比较方便。  </p>
<p>先掌握 tar 命令一些基本的使用方式，即不进行压缩只是进行打包（创建归档文件）和解包的操作。</p>
<p>创建一个 tar 包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -cf shiyanlou.tar ~</div></pre></td></tr></table></figure></p>
<p>上面命令中，-c 表示创建一个 tar 包文件，-f 用于指定创建的文件名，注意文件名必须紧跟在 -f 参数之后，比如不能写成 tar -fc shiyanlou.tar，可以写成 tar -f shiyanlou.tar -c ~。你还可以加上 -v 参数以可视的的方式输出打包的文件。上面会自动去掉表示绝对路径的 /，你也可以使用 -P 保留绝对路径符  </p>
<ul>
<li><p>解包一个文件（-x 参数）到指定路径的<strong>已存在</strong>目录（-C 参数）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mkdir tardir</div><div class="line">$ tar -xf shiyanlou.tar -C tardir</div></pre></td></tr></table></figure>
</li>
<li><p>只查看不解包文件 -t 参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -tf shiyanlou.tar</div></pre></td></tr></table></figure>
</li>
<li><p>保留文件属性和跟随链接（符号链接或软链接），有时候我们使用 tar 备份文件当你在其他主机还原时希望保留文件的属性（-p 参数）和备份链接指向的源文件而不是链接本身（-h 参数）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -cphf etc.tar /etc</div></pre></td></tr></table></figure>
</li>
</ul>
<p>对于创建不同的压缩格式的文件，对于 tar 来说是相当简单的，需要的只是换一个参数，这里我们就以使用 gzip 工具创建 *.tar.gz 文件为例来说明。  </p>
<ul>
<li><p>我们只需要在创建 tar 文件的基础上添加 -z 参数，使用 gzip 来压缩文件：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -czf shiyanlou.tar.gz ~</div></pre></td></tr></table></figure>
</li>
<li><p>解压 *.tar.gz 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -xzf shiyanlou.tar.gz</div></pre></td></tr></table></figure>
</li>
</ul>
<p>现在我们要使用其它的压缩工具创建或解压相应文件只需要更改一个参数即可：  </p>
<table>
<thead>
<tr>
<th>压缩文件格式</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>*.tar.gz</td>
<td>-z</td>
</tr>
<tr>
<td>*.tar.xz</td>
<td>-J</td>
</tr>
<tr>
<td>*tar.bz2</td>
<td>-j</td>
</tr>
</tbody>
</table>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>常用命令：</p>
<ul>
<li><p>zip：<br>  打包 ：zip something.zip something （目录请加 -r 参数）<br>  解包：unzip something<br>  指定路径：-d 参数  </p>
</li>
<li><p>tar：<br>  打包：tar -zcvf something.tar something<br>  解包：tar -zxvf something.tar<br>  指定路径：-C 参数  </p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;文件打包与压缩&quot;&gt;&lt;a href=&quot;#文件打包与压缩&quot; class=&quot;headerlink&quot; title=&quot;文件打包与压缩&quot;&gt;&lt;/a&gt;文件打包与压缩&lt;/h1&gt;&lt;p&gt;在 Windows 上最常见的不外乎这三种&lt;code&gt;*.zip，*.rar，*.7z&lt;/code&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Linux/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux基础" scheme="http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>06_Linux 内建命令与外部命令</title>
    <link href="http://yoursite.com/2017/07/07/Linux/Base/06_Linux%E4%B8%8B%E7%9A%84%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4(help,man,info)/"/>
    <id>http://yoursite.com/2017/07/07/Linux/Base/06_Linux下的帮助命令(help,man,info)/</id>
    <published>2017-07-07T12:59:47.000Z</published>
    <updated>2017-07-07T12:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内建命令与外部命令"><a href="#内建命令与外部命令" class="headerlink" title="内建命令与外部命令"></a>内建命令与外部命令</h1><p>什么是内建命令，什么是外部命令呢？这和帮助命令又有什么关系呢？  </p>
<p>因为有一些查看帮助的工具在内建命令与外建命令上是有区别对待的。  </p>
<p>内建命令实际上是 shell 程序的一部分，其中包含的是一些比较简单的 Linux 系统命令，这些命令是写在bash源码的builtins里面的，并由 shell 程序识别并在 shell 程序内部完成运行，通常在 Linux 系统加载运行时 shell 就被加载并驻留在系统内存中。而且解析内部命令 shell 不需要创建子进程，因此其执行速度比外部命令快。比如：history、cd、exit 等等。  </p>
<p>外部命令是 Linux 系统中的实用程序部分，因为实用程序的功能通常都比较强大，所以其包含的程序量也会很大，在系统加载时并不随系统一起被加载到内存中，而是在需要时才将其调用内存。虽然其不包含在 shell 中，但是其命令执行过程是由 shell 程序控制的。外部命令是在 Bash 之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin等等。比如：ls、vi等。  </p>
<p>简单来说就是一个是天生自带的天赋技能，一个是后天得来附加技能。我们可以使用　type 命令来区分命令是内建的还是外部的。例如这两个得出的结果是不同的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">type exit</div><div class="line">  </div><div class="line">type service</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#得到这样的结果说明是内建命令，正如上文所说内建命令都是在 bash 源码中的 builtins 的.def中</div><div class="line">xxx is a shell builtin</div><div class="line">#得到这样的结果说明是外部命令，正如上文所说，外部命令在/usr/bin or /usr/sbin等等中</div><div class="line">xxx is /usr/sbin/xxx</div><div class="line">#若是得到alias的结果，说明该指令为命令别名所设定的名称；</div><div class="line">xxx is an alias for xx --xxx</div></pre></td></tr></table></figure>
<h1 id="帮助命令的使用"><a href="#帮助命令的使用" class="headerlink" title="帮助命令的使用"></a>帮助命令的使用</h1><ol>
<li>help 命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">help cd</div></pre></td></tr></table></figure>
</li>
</ol>
<p>help 命令是用于显示 shell 内建命令的简要帮助信息。帮助信息中显示有该命令的简要说明以及一些参数的使用以及说明，一定记住 help 命令只能用于显示内建命令的帮助信息</p>
<p>如果是外部命令，外部命令基本上都有一个参数–help<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls --help</div></pre></td></tr></table></figure></p>
<ol>
<li>man 命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">man ls</div></pre></td></tr></table></figure>
</li>
</ol>
<p>得到的内容比用 help 更多更详细，而且　man　没有内建与外部命令的区分，因为 man 工具是显示系统手册页中的内容，也就是一本电子版的字典，这些内容大多数都是对命令的解释信息，还有一些相关的描述。通过查看系统文档中的 man 也可以得到程序的更多相关信息和 Linux 的更多特性。  </p>
<ol>
<li>info 命令</li>
</ol>
<p>要是你觉得man显示的信息都还不够，满足不了你的需求，那试试这个命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#一般的 bash 会自带的有。</div><div class="line">info ls</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;内建命令与外部命令&quot;&gt;&lt;a href=&quot;#内建命令与外部命令&quot; class=&quot;headerlink&quot; title=&quot;内建命令与外部命令&quot;&gt;&lt;/a&gt;内建命令与外部命令&lt;/h1&gt;&lt;p&gt;什么是内建命令，什么是外部命令呢？这和帮助命令又有什么关系呢？  &lt;/p&gt;
&lt;p&gt;因
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Linux/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Linux基础" scheme="http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
