<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mortalLiao</title>
  <subtitle>Keep learning</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-16T10:52:56.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>mortalLiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>01_数据库设计——三大范式</title>
    <link href="http://yoursite.com/2018/05/16/Database/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/01.%E6%95%B0%E6%8D%AE%E5%BA%93_%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/05/16/Database/关系型数据库/01.数据库_三大范式/</id>
    <published>2018-05-16T10:52:56.000Z</published>
    <updated>2018-05-16T10:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库设计——三大范式"><a href="#数据库设计——三大范式" class="headerlink" title="数据库设计——三大范式"></a>数据库设计——三大范式</h1><h2 id="数据库设计范式"><a href="#数据库设计范式" class="headerlink" title="数据库设计范式"></a>数据库设计范式</h2><h3 id="什么是范式："><a href="#什么是范式：" class="headerlink" title="什么是范式："></a>什么是范式：</h3><p>简言之就是，数据库设计对数据的存储性能，还有开发人员对数据的操作都有莫大的关系。所以建立科学的，规范的的数据库是需要满足一些规范的来优化数据数据存储方式。在关系型数据库中这些规范就可以称为范式。</p>
<h3 id="什么是三大范式："><a href="#什么是三大范式：" class="headerlink" title="什么是三大范式："></a>什么是三大范式：</h3><ul>
<li><p>第一范式：<br>当关系模式R的所有属性都不能在分解为更基本的数据单位时，称R是满足第一范式的，简记为1NF。满足第一范式是关系模式规范化的最低要求，否则，将有很多基本操作在这样的关系模式中实现不了。</p>
</li>
<li><p>第二范式：<br>如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式，简记为2NF。</p>
</li>
<li><p>第三范式：<br>设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，简记为3NF.</p>
</li>
</ul>
<p>注：关系实质上是一张二维表，其中每一行是一个元组，每一列是一个属性</p>
<h2 id="理解三大范式"><a href="#理解三大范式" class="headerlink" title="理解三大范式"></a>理解三大范式</h2><h3 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h3><ol>
<li>每一列属性都是不可再分的属性值，确保每一列的原子性</li>
<li>两列的属性相近或相似或一样，尽量合并属性一样的列，确保不产生冗余数据。</li>
</ol>
<p>举例：<br><img src="https://i.imgur.com/fvOnHv6.jpg" alt="">  </p>
<p><img src="https://i.imgur.com/DvChYBQ.jpg" alt="">  </p>
<p>如果需求知道那个省那个市并按其分类，那么显然第一个表格是不容易满足需求的，也不符合第一范式。</p>
<h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><p>每一行的数据只能与其中一列相关，即一行数据只做一件事。只要数据列中出现数据重复，就要把表拆分开来。  </p>
<p>举例：<br><img src="https://i.imgur.com/kEaPtzL.jpg" alt="">  </p>
<p>一个人同时订几个房间，就会出来一个订单号多条数据，这样子联系人都是重复的，就会造成数据冗余。我们应该把他拆开来。</p>
<p><img src="https://i.imgur.com/SwTWl8T.jpg" alt="">  </p>
<p><img src="https://i.imgur.com/nlB5wh1.jpg" alt="">  </p>
<p>这样便实现啦一条数据做一件事，不掺杂复杂的关系逻辑。同时对表数据的更新维护也更易操作。</p>
<h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><p>数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。像：a–&gt;b–&gt;c  属性之间含有这样的关系，是不符合第三范式的。  </p>
<p>比如Student表（学号，姓名，年龄，性别，所在院校，院校地址，院校电话）</p>
<p>这样一个表结构，就存在上述关系。 学号–&gt; 所在院校 –&gt; (院校地址，院校电话)</p>
<p>这样的表结构，我们应该拆开来，如下。</p>
<p>（学号，姓名，年龄，性别，所在院校）–（所在院校，院校地址，院校电话）</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据库设计——三大范式&quot;&gt;&lt;a href=&quot;#数据库设计——三大范式&quot; class=&quot;headerlink&quot; title=&quot;数据库设计——三大范式&quot;&gt;&lt;/a&gt;数据库设计——三大范式&lt;/h1&gt;&lt;h2 id=&quot;数据库设计范式&quot;&gt;&lt;a href=&quot;#数据库设计范式&quot; c
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="关系型数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="关系型数据库" scheme="http://yoursite.com/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>02_数据库_四大特性ACID</title>
    <link href="http://yoursite.com/2018/05/16/Database/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/02.%E6%95%B0%E6%8D%AE%E5%BA%93_%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7ACID/"/>
    <id>http://yoursite.com/2018/05/16/Database/关系型数据库/02.数据库_四大特性ACID/</id>
    <published>2018-05-16T10:52:56.000Z</published>
    <updated>2018-05-16T10:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><p>ACID，指在数据库管理系统（DBMS）中事务所具有的四个特性：<br><strong>原子性（Atomicity）</strong>、<br><strong>一致性（Consistency）</strong>、<br><strong>隔离性（Isolation）</strong>、<br><strong>持久性（Durability）</strong>。</p>
<p>在数据库系统中，<strong>一个事务是指由一系列数据库操作组成的一个完整的逻辑过程</strong>。例如银行转帐，从原账户扣除金额，以及向目标账户添加金额，这两个数据库操作的总和构成一个完整的逻辑过程，不可拆分。这个过程被称为一个事务，具有ACID特性。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。<br>事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。</p>
<p>事务将数据库从一个一致性状态带入另一个一致性状态。 比如说，在一个银行事务（在描述关系数据库事务的特性时，基本上都是用银行事务来作为描述对象的）中，需要从存储账户扣除款项，然后在支付账户中增加款项。 如果在这个中转的过程发生了失败，那么绝对不能让数据库只执行其中一个账户的操作，因为这样会导致数据处于不一致的状态（这样的话，银行的账目上，借贷就不平衡了）。</p>
<p>如果数据库系统运行中发生故障，有些事物尚未完成就被迫中断了，系统就将此事务中对数据库的所有已经完成的操作全部撤销，滚回到事务开始时的一致状态。</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>两个事务的执行是互不干扰的，一个事务不可能看到其他事务运行时，中间某一时刻的数据。  </p>
<p>这个特性是说，直到事务结束时（commit/rollback），其他事务（或者会话）对此事务所操作的数据都不可见（但并不是说其他会话的读取会被阻塞）。 比如说，一个用户正在修改hr.employees表，但是没有提交，那么其他用户在这个修改没有提交之前是看不到这个修改的。  </p>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p>
<p>指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。</p>
<p>被提交的更改会永久地保存到数据库中（并不是说以后就不可以修改）。 事务提交之后，数据库必须通过“恢复机制”来确保事务更改的数据不会丢失。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ACID&quot;&gt;&lt;a href=&quot;#ACID&quot; class=&quot;headerlink&quot; title=&quot;ACID&quot;&gt;&lt;/a&gt;ACID&lt;/h2&gt;&lt;p&gt;ACID，指在数据库管理系统（DBMS）中事务所具有的四个特性：&lt;br&gt;&lt;strong&gt;原子性（Atomicity）&lt;/st
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="关系型数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="关系型数据库" scheme="http://yoursite.com/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>04_数据库_七个spring事务传播特性</title>
    <link href="http://yoursite.com/2018/05/16/Database/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/04.%E6%95%B0%E6%8D%AE%E5%BA%93_%E4%B8%83%E4%B8%AAspring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2018/05/16/Database/关系型数据库/04.数据库_七个spring事务传播特性/</id>
    <published>2018-05-16T10:52:56.000Z</published>
    <updated>2018-05-16T10:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="七个spring事务传播特性"><a href="#七个spring事务传播特性" class="headerlink" title="七个spring事务传播特性"></a>七个spring事务传播特性</h2><p>事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为：</p>
<p>1.propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。</p>
<p>2.propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。</p>
<p>3.propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。</p>
<p>4.propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。</p>
<p>5.propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p>
<p>6.propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。</p>
<p>7.propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;七个spring事务传播特性&quot;&gt;&lt;a href=&quot;#七个spring事务传播特性&quot; class=&quot;headerlink&quot; title=&quot;七个spring事务传播特性&quot;&gt;&lt;/a&gt;七个spring事务传播特性&lt;/h2&gt;&lt;p&gt;事务传播行为就是多个事务方法相互调用时，事务
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="关系型数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="关系型数据库" scheme="http://yoursite.com/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>03_数据库_四大隔离级别</title>
    <link href="http://yoursite.com/2018/05/16/Database/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/03.%E6%95%B0%E6%8D%AE%E5%BA%93_%E5%9B%9B%E5%A4%A7%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://yoursite.com/2018/05/16/Database/关系型数据库/03.数据库_四大隔离级别/</id>
    <published>2018-05-16T10:52:56.000Z</published>
    <updated>2018-05-16T10:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h2><ul>
<li><p><strong>read uncommited(读未提交)</strong>：<br>是最低的事务隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。可防止丢失更新。<br>实现原理：读数据时候不加锁，写数据时候加行级共享锁，提交时释放锁(防止丢失更新)。</p>
</li>
<li><p><strong>read commited(读已提交)</strong>：<br>保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。可以防止脏读问题。<br>实现原理：事务读取数据（读到数据的时候）加行级共享锁，读完释放；事务写数据时候（写操作发生的瞬间）加行级排他锁，事务结束释放。</p>
</li>
<li><p><strong>repeatable read(重复读)</strong>：<br>这种事务隔离级别可以防止脏读，不可重复读。但是可能会出现幻象读。<br>实现原理：和读提交数据不同的是，事务读取数据在读操作开始的瞬间就加上行级共享锁，而且在事务结束的时候才释放。事务写数据时候（写操作发生的瞬间）加行级排他锁，事务结束释放。</p>
</li>
<li><p><strong>serializable(序列化)</strong>：<br>这是花费最高代价但最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读之外，还避免了幻象读。<br>实现原理：在读操作时，加表级共享锁，事务结束时释放；写操作时候，加表级排他锁，事务结束时释放 </p>
</li>
</ul>
<h3 id="Read-uncommitted-读未提交"><a href="#Read-uncommitted-读未提交" class="headerlink" title="Read uncommitted 读未提交"></a>Read uncommitted 读未提交</h3><p>举例：<br>公司发工资了，领导把5000元打到singo的账号上，但是该事务并未提交，而singo正好去查看账户，发现工资已经到账，是5000元整，非常高兴。可是不幸的是，领导发现发给singo的工资金额不对，是2000元，于是迅速回滚了事务，修改金额后，将事务提交，最后singo实际的工资只有2000元，singo空欢喜一场。  </p>
<p>出现上述情况，即我们所说的脏读，两个并发的事务，“事务A：领导给singo发工资”、“事务B：singo查询工资账户”，事务B读取了事务A尚未提交的数据。  </p>
<p>当隔离级别设置为Read uncommitted时，就可能出现脏读，如何避免脏读，请看下一个隔离级别。</p>
<h3 id="Read-committed-读提交"><a href="#Read-committed-读提交" class="headerlink" title="Read committed 读提交"></a>Read committed 读提交</h3><p>singo拿着工资卡去消费，系统读取到卡里确实有2000元，而此时她的老婆也正好在网上转账，把singo工资卡的2000元转到另一账户，并在singo之前提交了事务，当singo扣款时，系统检查到singo的工资卡已经没有钱，扣款失败，singo十分纳闷，明明卡里有钱，为何……</p>
<p>出现上述情况，即我们所说的不可重复读，两个并发的事务，“事务A：singo消费”、“事务B：singo的老婆网上转账”，事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。</p>
<p>当隔离级别设置为Read committed时，避免了脏读，但是可能会造成不可重复读。</p>
<p><strong>大多数数据库的默认级别就是Read committed，比如Sql Server , Oracle。</strong>如何解决不可重复读这一问题，请看下一个隔离级别。</p>
<h3 id="Repeatable-read-重复读"><a href="#Repeatable-read-重复读" class="headerlink" title="Repeatable read 重复读"></a>Repeatable read 重复读</h3><p>当隔离级别设置为Repeatable read时，可以避免不可重复读。当singo拿着工资卡去消费时，一旦系统开始读取工资卡信息（即事务开始），singo的老婆就不可能对该记录进行修改，也就是singo的老婆不能在此时转账。  </p>
<p>虽然Repeatable read避免了不可重复读，但还有可能出现幻读。  </p>
<p>singo的老婆工作在银行部门，她时常通过银行内部系统查看singo的信用卡消费记录。有一天，她正在查询到singo当月信用卡的总消费金额（select sum(amount) from transaction where month = 本月）为80元，而singo此时正好在外面胡吃海塞后在收银台买单，消费1000元，即新增了一条1000元的消费记录（insert transaction … ），并提交了事务，随后singo的老婆将singo当月信用卡消费的明细打印到A4纸上，却发现消费总额为1080元，singo的老婆很诧异，以为出现了幻觉，幻读就这样产生了。  </p>
<p><strong>MySQL的默认隔离级别就是Repeatable read。</strong></p>
<h3 id="Serializable-序列化"><a href="#Serializable-序列化" class="headerlink" title="Serializable 序列化"></a>Serializable 序列化</h3><p>Serializable是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。</p>
<h2 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h2><p>脏读: 指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据， 那么另外一 个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。</p>
<p>不可重复读: 指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。 那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</p>
<p>幻觉读: 指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及 到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</p>
<h2 id="mysql-oracle-sql-server中的默认事务隔离级别查看-更改"><a href="#mysql-oracle-sql-server中的默认事务隔离级别查看-更改" class="headerlink" title="mysql,oracle,sql server中的默认事务隔离级别查看,更改"></a>mysql,oracle,sql server中的默认事务隔离级别查看,更改</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>mysql默认的事务处理级别是’REPEATABLE-READ’,也就是可重复读  </p>
<p>1.查看当前会话隔离级别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select @@tx_isolation;</div></pre></td></tr></table></figure></p>
<p>2.查看系统当前隔离级别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select @@global.tx_isolation;</div></pre></td></tr></table></figure></p>
<p>3.设置当前会话隔离级别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set session transaction isolatin level repeatable read;</div></pre></td></tr></table></figure></p>
<p>4.设置系统当前隔离级别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set global transaction isolation level repeatable read;</div></pre></td></tr></table></figure></p>
<h3 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h3><p>oracle数据库支持READ COMMITTED 和 SERIALIZABLE这两种事务隔离级别。  </p>
<p>默认系统事务隔离级别是READ COMMITTED,也就是读已提交  </p>
<p>查看系统默认事务隔离级别,也是当前会话隔离级别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">--首先创建一个事务</div><div class="line">declare</div><div class="line">     trans_id Varchar2(100);</div><div class="line">  begin</div><div class="line">     trans_id := dbms_transaction.local_transaction_id( TRUE );</div><div class="line">  end; </div><div class="line">--查看事务隔离级别</div><div class="line"></div><div class="line">SELECT s.sid, s.serial#,</div><div class="line"></div><div class="line">　　CASE BITAND(t.flag, POWER(2, 28))</div><div class="line">　　　　WHEN 0 THEN &apos;READ COMMITTED&apos;</div><div class="line">　　　　ELSE &apos;SERIALIZABLE&apos;</div><div class="line">　　END AS isolation_level</div><div class="line">FROM v$transaction t</div><div class="line">JOIN v$session s ON t.addr = s.taddr AND s.sid = sys_context(&apos;USERENV&apos;, &apos;SID&apos;);</div></pre></td></tr></table></figure></p>
<h3 id="SQL-Server"><a href="#SQL-Server" class="headerlink" title="SQL Server"></a>SQL Server</h3><p>默认系统事务隔离级别是read committed,也就是读已提交</p>
<ol>
<li><p>查看系统当前隔离级别  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DBCC USEROPTIONS </div><div class="line">isolation level 这一项的 Value 既是当前的隔离级别设置值</div></pre></td></tr></table></figure>
</li>
<li><p>设置系统当前隔离级别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SET TRANSACTION ISOLATION LEVEL Read UnCommitted;</div><div class="line">其中Read UnCommitted为需要设置的值</div></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;四种隔离级别&quot;&gt;&lt;a href=&quot;#四种隔离级别&quot; class=&quot;headerlink&quot; title=&quot;四种隔离级别&quot;&gt;&lt;/a&gt;四种隔离级别&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;read uncommited(读未提交)&lt;/strong&gt;：&lt;br&gt;是最
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="关系型数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="关系型数据库" scheme="http://yoursite.com/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>03_Git环境设置</title>
    <link href="http://yoursite.com/2018/05/02/VCS/Git/03_Git%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/05/02/VCS/Git/03_Git环境设置/</id>
    <published>2018-05-02T08:44:07.000Z</published>
    <updated>2018-05-02T08:44:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git环境设置"><a href="#Git环境设置" class="headerlink" title="Git环境设置"></a>Git环境设置</h1><h2 id="Git客户端安装"><a href="#Git客户端安装" class="headerlink" title="Git客户端安装"></a>Git客户端安装</h2><p>sudo apt-get install git-core  </p>
<h1 id="自定义Git环境"><a href="#自定义Git环境" class="headerlink" title="自定义Git环境"></a>自定义Git环境</h1><h2 id="设置用户名"><a href="#设置用户名" class="headerlink" title="设置用户名"></a>设置用户名</h2><p>git config –global user.name “mortal”  </p>
<h2 id="设置电子邮件ID"><a href="#设置电子邮件ID" class="headerlink" title="设置电子邮件ID"></a>设置电子邮件ID</h2><p>git config –global user.email “mortalliaoyujian@163.com”  </p>
<h2 id="避免PULLING提交合并"><a href="#避免PULLING提交合并" class="headerlink" title="避免PULLING提交合并"></a>避免PULLING提交合并</h2><p>git config –global branch.autosetuprebase always  </p>
<h2 id="颜色高亮"><a href="#颜色高亮" class="headerlink" title="颜色高亮"></a>颜色高亮</h2><p>使颜色突出显示在控制台的Git。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git config --global color.ui true</div><div class="line">  </div><div class="line">$ git config --global color.status auto</div><div class="line">  </div><div class="line">$ git config --global color.branch auto</div></pre></td></tr></table></figure></p>
<h2 id="设置默认编辑器"><a href="#设置默认编辑器" class="headerlink" title="设置默认编辑器"></a>设置默认编辑器</h2><p>$ git config –global core.editor vim  </p>
<h2 id="设置默认的合并工具"><a href="#设置默认的合并工具" class="headerlink" title="设置默认的合并工具"></a>设置默认的合并工具</h2><p>Git不会提供一个默认的合并工具整合到工作树冲突的更改。我们可以设置默认的合并工具，通过启用以下设置。  </p>
<p>$ git config –global merge.tool vimdiff  </p>
<h2 id="列出GIT设置"><a href="#列出GIT设置" class="headerlink" title="列出GIT设置"></a>列出GIT设置</h2><p>$ git config –list  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Git环境设置&quot;&gt;&lt;a href=&quot;#Git环境设置&quot; class=&quot;headerlink&quot; title=&quot;Git环境设置&quot;&gt;&lt;/a&gt;Git环境设置&lt;/h1&gt;&lt;h2 id=&quot;Git客户端安装&quot;&gt;&lt;a href=&quot;#Git客户端安装&quot; class=&quot;headerli
    
    </summary>
    
      <category term="VCS" scheme="http://yoursite.com/categories/VCS/"/>
    
      <category term="Git" scheme="http://yoursite.com/categories/VCS/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>06_Git标签&amp;补丁操作</title>
    <link href="http://yoursite.com/2018/05/02/VCS/Git/06_Git%E6%A0%87%E7%AD%BE&amp;%E8%A1%A5%E4%B8%81%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/05/02/VCS/Git/06_Git标签&amp;补丁操作/</id>
    <published>2018-05-02T08:44:07.000Z</published>
    <updated>2018-05-02T08:44:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-标签操作"><a href="#Git-标签操作" class="headerlink" title="Git 标签操作"></a>Git 标签操作</h1><p>有意义的名称到一个特定的版本库中的标签操作。  </p>
<h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><p>标记当前HEAD使用git tag命令。  </p>
<p>提供的标记名称前加上-a选项，使用-m选项，并提供标签信息。  </p>
<p><strong>git tag -a ‘Release_1_0’ -m ‘Tagged basic string’</strong>  </p>
<p><strong>git push origin tag Release_1_0</strong>  </p>
<h2 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h2><p>通过使用Git tag命令 使用-l选项 查看所有可用标签。</p>
<p>git pull  </p>
<p><strong>git tag -l</strong>  </p>
<p>使用Git的show命令后跟标记名称的有关标签查看更多细节。</p>
<p><strong>git show Release_1_0</strong>  </p>
<h2 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h2><p>git tag  </p>
<p><strong>git tag -d Release_1_0</strong>  </p>
<p>git push origin :Release_1_0  </p>
<h1 id="Git-补丁操作"><a href="#Git-补丁操作" class="headerlink" title="Git 补丁操作"></a>Git 补丁操作</h1><p>补丁是文本文件，其内容是相似于Git diff，但随着代码，它也有元数据有关提交，如提交ID，日期，提交信息等，我们可以创建补丁提交和其他人可以将它们应用到自己的资料库。</p>
<p>git status -s  </p>
<p>git add string_operations.c  </p>
<p>git commit -m “Added my_strcat function”  </p>
<p>git format-patch -1  </p>
<p>Git提供两个命令来应用补丁调幅分别为： git am 和 git apply .<br>git apply命令修改本地文件时，而无需创建提交，<br>git am命令修改文件，会一并创建提交。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Git-标签操作&quot;&gt;&lt;a href=&quot;#Git-标签操作&quot; class=&quot;headerlink&quot; title=&quot;Git 标签操作&quot;&gt;&lt;/a&gt;Git 标签操作&lt;/h1&gt;&lt;p&gt;有意义的名称到一个特定的版本库中的标签操作。  &lt;/p&gt;
&lt;h2 id=&quot;创建标签&quot;&gt;&lt;a 
    
    </summary>
    
      <category term="VCS" scheme="http://yoursite.com/categories/VCS/"/>
    
      <category term="Git" scheme="http://yoursite.com/categories/VCS/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>05_Git操作</title>
    <link href="http://yoursite.com/2018/05/02/VCS/Git/05_Git%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/05/02/VCS/Git/05_Git操作/</id>
    <published>2018-05-02T08:44:07.000Z</published>
    <updated>2018-05-02T08:44:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git-操作"><a href="#git-操作" class="headerlink" title="git 操作"></a>git 操作</h1><h2 id="git-克隆操作"><a href="#git-克隆操作" class="headerlink" title="git 克隆操作"></a>git 克隆操作</h2><p>git clone  </p>
<h2 id="git-提交更改"><a href="#git-提交更改" class="headerlink" title="git 提交更改"></a>git 提交更改</h2><p>git status -s  </p>
<p>git add XXX.XXX  </p>
<p>git commit -m ‘some message’  </p>
<p>git log  </p>
<h2 id="git-审查更改"><a href="#git-审查更改" class="headerlink" title="git 审查更改"></a>git 审查更改</h2><p>git log  </p>
<p>git show SHA-1.ID  </p>
<p>git diff  </p>
<h2 id="git-推送操作"><a href="#git-推送操作" class="headerlink" title="git 推送操作"></a>git 推送操作</h2><p>git push origin master  </p>
<h2 id="git-取最新变化"><a href="#git-取最新变化" class="headerlink" title="git 取最新变化"></a>git 取最新变化</h2><p>git pull  </p>
<h2 id="git-藏匿操作"><a href="#git-藏匿操作" class="headerlink" title="git 藏匿操作"></a>git 藏匿操作</h2><p>不能提交部分代码，也不能扔掉变化。所以，需要一些临时空间，在那里可以存储部分修改，以便以后再提交。  </p>
<p>在Git中，藏匿操作需要修改的跟踪文件和阶段的变化，并将其保存在栈上未完成的更改，可以在任何时候重新。<br><strong>git stash</strong>  </p>
<p>现在可以安全地切换分支和做其他工作。使用 git stash list 命令看到的藏匿的变化列表。<br><strong>git stash list</strong>  </p>
<p>只要执行git stash pop 命令，它会从堆栈中删除的变化，并把它放在当前工作目录。<br><strong>git stash pop</strong>  </p>
<h2 id="git-移动-重命名-操作"><a href="#git-移动-重命名-操作" class="headerlink" title="git 移动(重命名)操作"></a>git 移动(重命名)操作</h2><p>(move )操作移动目录或文件从一个位置到另一个。<br><strong>git mv string.c src/  </strong>  </p>
<p>要进行这些永久性更改，以便其他开发人员可以看到这一点，必须修改的目录结构推到远程存储库。<br>git commit -m “Modified directory structure”  </p>
<p>git push origin master  </p>
<h2 id="git-删除操作"><a href="#git-删除操作" class="headerlink" title="git 删除操作"></a>git 删除操作</h2><p><strong>git rm string.c</strong>  </p>
<p>git commit -m “Removed executable binary”  </p>
<h2 id="git-修正错误"><a href="#git-修正错误" class="headerlink" title="git 修正错误"></a>git 修正错误</h2><h3 id="恢复未提交的更改"><a href="#恢复未提交的更改" class="headerlink" title="恢复未提交的更改"></a>恢复未提交的更改</h3><p>git checkout modified.file</p>
<p>即是是工作目录中删除了的文件  </p>
<h3 id="删除临时区域变化"><a href="#删除临时区域变化" class="headerlink" title="删除临时区域变化"></a>删除临时区域变化</h3><p>在Git是一个HEAD指针始终指向最新提交。<br>如果想撤销变更分阶段区域，那么可以使用git checkout命令，但checkout命令，必须提供额外的参数HEAD指针。<br>额外提交指针参数指示的git checkout命令，重置工作树，还能够去除分阶段。  </p>
<p>git add modified.file  </p>
<p>git checkout HEAD – modified.file  </p>
<h3 id="将HEAD指针与Git复位"><a href="#将HEAD指针与Git复位" class="headerlink" title="将HEAD指针与Git复位"></a>将HEAD指针与Git复位</h3><h4 id="SOFT"><a href="#SOFT" class="headerlink" title="SOFT"></a>SOFT</h4><p>每个分支都有HEAD 指针指向最新提交。如果我们使用git  –soft复位命令选项，随后提交ID，然后将只有头指针复位，不破坏任何东西。  </p>
<p>.git/refs/heads/master 文件存储的提交ID 的HEAD 指针。可以通过使用git log -1 命令验证它<br>cat .git/refs/heads/master  </p>
<p>现在查看最新提交的ID，这将配合上述提交ID。<br>git log -2  </p>
<p>重设HEAD 指针。<br><strong>git reset –soft HEAD</strong>~  </p>
<h4 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h4><p>Git的复位 – mixed选项从分段区域尚未提交还原更改。它仅恢复变化形成暂存区。实际所做的更改到工作副本的文件不受影响。默认的Git的复位相当于git的复位 – mixed。  </p>
<h4 id="HARD"><a href="#HARD" class="headerlink" title="HARD"></a>HARD</h4><p>如果使用 - hard选项用 Git复位命令，它会清除暂存区域，它会重设HEAD 指针，以最后一次提交的具体提交ID，也删除本地文件的变化。  </p>
<p>检查提交的ID：  </p>
<p>git log -1  </p>
<p>修改文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ head -2 string_operations.c</div><div class="line">/* This line be removed by git reset operation */</div><div class="line">#include &lt;stdio.h&gt;</div></pre></td></tr></table></figure></p>
<p>git status -s  </p>
<p>将修改后的文件添加到分期区域，并验证git的状态运行  </p>
<p>git add string_operations.c  </p>
<p>git status  </p>
<p>git的状态，显示该文件实在临时区域，现在重置HEAD 用 –hard选项  </p>
<p><strong>git reset –hard SHA-1.ID</strong>  </p>
<p>git服务命令成功，这将从分段区恢复文件，以及删除本地文件所做的更改  </p>
<p>git状态显示，从分段区恢复文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ head -2 string_operations.c</div><div class="line">#include &lt;stdio.h&gt;</div></pre></td></tr></table></figure></p>
<p>Head 命令还显示，复位操作删除局部变化。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;git-操作&quot;&gt;&lt;a href=&quot;#git-操作&quot; class=&quot;headerlink&quot; title=&quot;git 操作&quot;&gt;&lt;/a&gt;git 操作&lt;/h1&gt;&lt;h2 id=&quot;git-克隆操作&quot;&gt;&lt;a href=&quot;#git-克隆操作&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="VCS" scheme="http://yoursite.com/categories/VCS/"/>
    
      <category term="Git" scheme="http://yoursite.com/categories/VCS/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>01_Git了解</title>
    <link href="http://yoursite.com/2018/05/02/VCS/Git/01_Git%E4%BA%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/05/02/VCS/Git/01_Git了解/</id>
    <published>2018-05-02T08:44:07.000Z</published>
    <updated>2018-05-02T08:44:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git三种状态"><a href="#Git三种状态" class="headerlink" title="Git三种状态"></a>Git三种状态</h1><p> Git 有三种状态，你的文件可能处于其中之一：已提交(committed)、已修改(modified)和已暂存(staged)。  </p>
<p><img src="http://i.imgur.com/i9rgs8D.png" alt="">  </p>
<p>已提交表示数据已经安全的保存在本地数据库中。 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。  </p>
<h1 id="工作目录、暂存区域以及-Git-仓库"><a href="#工作目录、暂存区域以及-Git-仓库" class="headerlink" title="工作目录、暂存区域以及 Git 仓库."></a>工作目录、暂存区域以及 Git 仓库.</h1><p>Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。  </p>
<p>工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。  </p>
<p>暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索引’’，不过一般说法还是叫暂存区域  </p>
<p>基本的 Git 工作流程如下：  </p>
<ol>
<li>在工作目录中修改文件。</li>
<li>暂存文件，将文件的快照放入暂存区域。</li>
<li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</li>
</ol>
<p>如果 Git 目录中保存着的特定版本文件，就属于已提交状态。<br>如果作了修改并已放入暂存区域，就属于已暂存状态。<br>如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。  </p>
<h1 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h1><p>Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：</p>
<ul>
<li><p>/etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 –system 选项的 git config 时，它会从此文件读写配置变量。</p>
</li>
<li><p>~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 可以传递 –global选项让 Git 读写此文件。</p>
</li>
<li><p>当前使用仓库的 Git 目录中的 config 文件(就是 .git/config)：针对该仓库。</p>
</li>
</ul>
<p>每一个级别覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。  </p>
<h2 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h2><p>当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name &quot;Daniu Su&quot;</div><div class="line">$ git config --global user.email daniu.su@example.com</div></pre></td></tr></table></figure>
<p>如果使用了 –global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 –global 选项的命令来配置。  </p>
<h2 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git config --global core.editor emacs</div></pre></td></tr></table></figure>
<h2 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h2><p>如果想要检查你的配置，可以使用 git config –list 命令来列出所有 Git 当时能找到的配置。  </p>
<p>你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置(例如：/etc/gitconfig 与 ~/.gitconfig)。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git config --list</div><div class="line">user.name=Daniu Su</div><div class="line">user.email=daniu.su@example.com</div><div class="line">color.status=auto</div><div class="line">color.branch=auto</div><div class="line">color.interactive=auto</div><div class="line">color.diff=auto</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>可以通过输入 git config <key>： 来检查 Git 的某一项配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config user.name</div><div class="line">Daniu Su</div></pre></td></tr></table></figure></key></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Git三种状态&quot;&gt;&lt;a href=&quot;#Git三种状态&quot; class=&quot;headerlink&quot; title=&quot;Git三种状态&quot;&gt;&lt;/a&gt;Git三种状态&lt;/h1&gt;&lt;p&gt; Git 有三种状态，你的文件可能处于其中之一：已提交(committed)、已修改(modifie
    
    </summary>
    
      <category term="VCS" scheme="http://yoursite.com/categories/VCS/"/>
    
      <category term="Git" scheme="http://yoursite.com/categories/VCS/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>07_Git分支管理</title>
    <link href="http://yoursite.com/2018/05/02/VCS/Git/07_Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/05/02/VCS/Git/07_Git分支管理/</id>
    <published>2018-05-02T08:44:07.000Z</published>
    <updated>2018-05-02T08:44:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git管理分支"><a href="#Git管理分支" class="headerlink" title="Git管理分支"></a>Git管理分支</h1><p>分支操作可以创造另一条线的发展</p>
<h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><p>使用Git分支<branch name=""> 命令创建新的分支。<br>从现有的，我们可以创建一个新的分支。我们可以使用特定的提交或标签作为一个起点。如果没有提供任何具体的提交ID，然后分支将HEAD 创建作为一个起点  </branch></p>
<p><strong>git branch new_branch </strong>  </p>
<p><strong>git branch</strong><br><code>*</code> master<br>new_branch  </p>
<h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><p>使用git checkout命令到分支之间切换。  </p>
<p><strong>git checkout new_branch</strong>  </p>
<p>git branch<br>master<br><code>*</code> new_branch  </p>
<h2 id="创建和切换分支的快捷方式"><a href="#创建和切换分支的快捷方式" class="headerlink" title="创建和切换分支的快捷方式"></a>创建和切换分支的快捷方式</h2><p>Git提供checkout命令 -b选项，此操作将创建新的分支，并立即切换到新的分支。  </p>
<p><strong>git checkout -b test_branch</strong>  </p>
<p>git branch<br>master<br>new_branch<br><code>*</code> test_branch  </p>
<h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><p>一个分支可以用git branch命令的-D选项被删除。但在此之前，切换到其他分支。  </p>
<p>git branch<br>master<br>new_branch<br><code>*</code> test_branch  </p>
<p>git checkout master  </p>
<p>git branch -D test_branch  </p>
<p>git branch<br><code>*</code> master<br>new_branch  </p>
<h2 id="重命名分支"><a href="#重命名分支" class="headerlink" title="重命名分支"></a>重命名分支</h2><p>通过使用-m选项，其次是旧分支名称和新分支名称变更分支名称。  </p>
<p>git branch<br><code>*</code> master<br>new_branch  </p>
<p>git branch -m new_branch wchar_support  </p>
<p>git branch<br><code>*</code> master<br>wchar_support  </p>
<h2 id="合并两个分支"><a href="#合并两个分支" class="headerlink" title="合并两个分支"></a>合并两个分支</h2><p>git branch<br><code>*</code> master<br>wchar_support  </p>
<p>git push origin wchar_support  </p>
<h2 id="重订分支"><a href="#重订分支" class="headerlink" title="重订分支"></a>重订分支</h2><p>Git 的 rebase命令的一个分支合并的命令，但不同的是，它修改提交的顺序。  </p>
<p>Git merge命令，试图把从其他分支提交当前的本地分支的HEAD上。例如 本地的分支已经提交A-&gt; B-&gt; C-&gt; D和合并分支已提交A-&gt; B-&gt; X&gt; Y，则Git合并将当前转换像这样的本地分行A-&gt; B-&gt; C-&gt; D-&gt; X-&gt; Y  </p>
<p>Git 的rebase命令试图找到当前的本地分支和合并分支之间的共同祖先。然后把修改提交的顺序，在当前的本地分支提交中的本地分支。例如，如果当地的分支已提交A-&gt; B-&gt; C-&gt; D和合并分支已提交A-&gt; B-&gt; X-&gt; Y，Git衍合的类似A-&gt; B转换成当前的本地分支A−&gt;B−&gt;X−&gt;Y−&gt;C−&gt;D  </p>
<p>当多个开发人员在一个单一的远程资源库的工作，你不能在远程仓库提交修改订单。在这种情况下，可以使用变基操作把本地提交的远程仓库之上的提交，可以推送这些变化。  </p>
<h1 id="Git-冲突处理"><a href="#Git-冲突处理" class="headerlink" title="Git 冲突处理"></a>Git 冲突处理</h1><h1 id="Git-不同的平台"><a href="#Git-不同的平台" class="headerlink" title="Git 不同的平台"></a>Git 不同的平台</h1><p>GNU/ Linux 和 Mac OS使用换行符（LF）或新行作为行结束字符，而Windows 使用换行和回车（LFCR）的组合来表示行结束字符。  </p>
<p>为了避免不必要的提交，因为这些行结束的差异，Git客户端配置写在同一行结束 Git 仓库。  </p>
<p>对于Windows系统中，我们可以配置的Git客户端换行符转换为CRLF格式，同时检查了，并把它们转换回LF格式提交操作过程中  </p>
<p>git config –global core.autocrlf true  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Git管理分支&quot;&gt;&lt;a href=&quot;#Git管理分支&quot; class=&quot;headerlink&quot; title=&quot;Git管理分支&quot;&gt;&lt;/a&gt;Git管理分支&lt;/h1&gt;&lt;p&gt;分支操作可以创造另一条线的发展&lt;/p&gt;
&lt;h2 id=&quot;创建分支&quot;&gt;&lt;a href=&quot;#创建分支&quot; 
    
    </summary>
    
      <category term="VCS" scheme="http://yoursite.com/categories/VCS/"/>
    
      <category term="Git" scheme="http://yoursite.com/categories/VCS/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>02_获取Git仓库</title>
    <link href="http://yoursite.com/2018/05/02/VCS/Git/02_%E8%8E%B7%E5%8F%96Git%E4%BB%93%E5%BA%93/"/>
    <id>http://yoursite.com/2018/05/02/VCS/Git/02_获取Git仓库/</id>
    <published>2018-05-02T08:44:07.000Z</published>
    <updated>2018-05-02T08:44:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="获取Git仓库"><a href="#获取Git仓库" class="headerlink" title="获取Git仓库"></a>获取Git仓库</h1><p>初始化一个仓库(repository)、开始或停止跟踪(track)文件、暂存(stage)或提交(commit)更改  </p>
<p>有两种取得 Git 项目仓库的方法。 第一种是在现有项目或目录下导入所有文件到 Git 中； 第二种是从一个服务器克隆一个现有的 Git 仓库。  </p>
<h2 id="在现有目录中初始化仓库"><a href="#在现有目录中初始化仓库" class="headerlink" title="在现有目录中初始化仓库"></a>在现有目录中初始化仓库</h2><p>如果你打算使用 Git 来对现有的项目进行管理<br><strong>$ git init</strong></p>
<p>该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。<br>但是，在这个时候，仅仅是做了一个初始化的操作，项目里的文件还没有被跟踪。  </p>
<p>可通过 git add 命令来实现对指定文件的跟踪，然后执行 git commit 提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git add *.c</div><div class="line">$ git add LICENSE</div><div class="line">$ git commit -m &apos;initial project version&apos;</div></pre></td></tr></table></figure></p>
<h2 id="克隆已有的仓库"><a href="#克隆已有的仓库" class="headerlink" title="克隆已有的仓库"></a>克隆已有的仓库</h2><p><strong>git clone [url]</strong>  </p>
<p>初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。</p>
<h1 id="记录更新到仓库"><a href="#记录更新到仓库" class="headerlink" title="记录更新到仓库"></a>记录更新到仓库</h1><p>工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。  </p>
<p>已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。  </p>
<p> 工作目录中除了已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。  </p>
<p><img src="http://i.imgur.com/99CDDQ5.png" alt="">  </p>
<h1 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h1><p><strong>git status</strong>  </p>
<p>git status -s 命令或 git status –short 命令，将得到一种更为简短的格式输出  </p>
<h1 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h1><p><strong>git add</strong>  </p>
<p>git add 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。  </p>
<h1 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h1><p>实际上 Git 只暂存了运行 git add 命令时的版本，而不是运行 git commit 时，在工作目录中的当前版本。 所以，运行了 git add 之后又作了修订的文件，需要重新运行 git add 把最新版本重新暂存起来  </p>
<h1 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h1><p>创建一个名为 .gitignore 的文件，列出要忽略的文件模式。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 以&apos;#&apos;开始的行，被视为注释.</div><div class="line"># 忽略掉所有文件名是 foo.txt的文件.</div><div class="line">foo.txt</div><div class="line"># 忽略所有生成的 html文件,</div><div class="line">*.html</div><div class="line"># foo.html是手工维护的，所以例外.</div><div class="line">!foo.html</div><div class="line"># 忽略所有.o和 .a文件.</div><div class="line">*.[oa]</div></pre></td></tr></table></figure>
<p>文件 .gitignore 的格式规范如下：  </p>
<ul>
<li>所有空行或者以＃ 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配。</li>
<li>匹配模式可以以(/)开头防止递归。</li>
<li>匹配模式可以以(/)结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号(!)取反。</li>
</ul>
<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号(<code>*</code>)匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符(这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c)；问号(?)只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配(比如[0-9] 表示匹配所有0到9的数字)。 使用两个星号(<em>) 表示匹配任意中间目录，比如a/*</em>/z 可以匹配 a/z, a/b/z或 a/b/c/z</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># no .a files</div><div class="line">*.a</div><div class="line">  </div><div class="line"># but do track lib.a, even though you&apos;re ignoring .a files above</div><div class="line">!lib.a</div><div class="line">  </div><div class="line"># only ignore the TODO file in the current directory, not subdir/TODO</div><div class="line">/TODO</div><div class="line">  </div><div class="line"># ignore all files in the build/ directory</div><div class="line">build/</div><div class="line">  </div><div class="line"># ignore doc/notes.txt, but not doc/server/arch.txt</div><div class="line">doc/*.txt</div><div class="line">  </div><div class="line"># ignore all .pdf files in the doc/ directory</div><div class="line">doc/**/*.pdf</div></pre></td></tr></table></figure>
<h1 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h1><p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 git diff<br><strong>git diff</strong>  </p>
<p>注意，git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。  </p>
<p>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。  </p>
<p>若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff –cached 命令。<br><strong>git diff –cached</strong>  </p>
<h1 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h1><p><strong>$ git commit</strong>  </p>
<h1 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h1><p><strong>git commit -a</strong>  </p>
<h1 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h1><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除(确切地说，是从暂存区域移除)，然后提交。  </p>
<p>可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。  </p>
<p>下一次提交时，该文件就不再纳入版本管理了。 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项-f(译注：即 force 的首字母)。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。  </p>
<p>另外一种情况是，想把文件从 Git 仓库中删除(亦即从暂存区域移除)，但仍然希望保留在当前工作目录中。 换句话说，想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 –cached 选项：  </p>
<p><strong>$ git rm –cached README</strong>  </p>
<p>git rm 命令后面可以列出文件或者目录的名字，也可以使用 glob 模式。 比方说：<br>$ git rm log/*.log  </p>
<p>注意到星号 * 之前的反斜杠 \， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。 此命令删除log/ 目录下扩展名为 .log 的所有文件。 类似的比如：</p>
<p>$ git rm *~</p>
<p>该命令为删除以 ~ 结尾的所有文件。</p>
<h1 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h1><p>不像其它的 VCS 系统，Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。  </p>
<p>在 Git 中对文件改名：  </p>
<p><strong>$ git mv file_from file_to</strong>  </p>
<p>其实，运行 git mv 就相当于运行了下面三条命令：  </p>
<p>$ mv README.md README<br>$ git rm README.md<br>$ git add README  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;获取Git仓库&quot;&gt;&lt;a href=&quot;#获取Git仓库&quot; class=&quot;headerlink&quot; title=&quot;获取Git仓库&quot;&gt;&lt;/a&gt;获取Git仓库&lt;/h1&gt;&lt;p&gt;初始化一个仓库(repository)、开始或停止跟踪(track)文件、暂存(stage)或提交(
    
    </summary>
    
      <category term="VCS" scheme="http://yoursite.com/categories/VCS/"/>
    
      <category term="Git" scheme="http://yoursite.com/categories/VCS/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>04_Git创建操作</title>
    <link href="http://yoursite.com/2018/05/02/VCS/Git/04_Git%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/05/02/VCS/Git/04_Git创建操作/</id>
    <published>2018-05-02T08:44:07.000Z</published>
    <updated>2018-05-02T08:44:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git创建操作"><a href="#Git创建操作" class="headerlink" title="Git创建操作"></a>Git创建操作</h1><p>作为Git服务器。需要一个的Git服务器允许团队协作。</p>
<h2 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># add new group</div><div class="line">[root@CentOS ~]# groupadd dev</div><div class="line">  </div><div class="line"># add new user</div><div class="line">[root@CentOS ~]# useradd -G devs -d /home/gituser -m -s /bin/bash gituser</div><div class="line">  </div><div class="line"># change password</div><div class="line">[root@CentOS ~]# passwd gituser</div></pre></td></tr></table></figure>
<h2 id="创建一个裸库"><a href="#创建一个裸库" class="headerlink" title="创建一个裸库"></a>创建一个裸库</h2><p>初始化一个新的资料库使用init命令后面加上 -bare选项。它初始化没有工作目录库。按照惯例裸库必须命名为 .git。  </p>
<h2 id="生成公共-私有RSA密钥对"><a href="#生成公共-私有RSA密钥对" class="headerlink" title="生成公共/私有RSA密钥对"></a>生成公共/私有RSA密钥对</h2><p>遍历Git服务器端的配置过程中，使用ssh-keygen实用程序生成公共/私有RSA密钥对，使用这些键进行用户认证。  </p>
<p>打开一个终端并输入以下命令，直接按回车为每个输入。成功完成后，它会创建主目录 .ssh目录内。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[tom@CentOS ~]$ pwd</div><div class="line">/home/tom</div><div class="line">  </div><div class="line">[tom@CentOS ~]$ ssh-keygen</div></pre></td></tr></table></figure>
<p>ssh-keygen 已经产生了两个键，第一个是私有的（即id_rsa），另一个是公共（即id_rsa.pub文件）。  </p>
<h2 id="添加键-authorized-keys"><a href="#添加键-authorized-keys" class="headerlink" title="添加键 authorized_keys"></a>添加键 authorized_keys</h2><p>假设有两个开发项目即Tom 和Jerry工作。两个用户生成公钥。让我们来看看如何使用这些密钥进行身份验证。  </p>
<p>Tom 添加他的公钥服务器使用 ssh-copy-id这个命令下面给出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[tom@CentOS ~]$ pwd</div><div class="line">/home/tom</div><div class="line">  </div><div class="line">[tom@CentOS ~]$ ssh-copy-id -i ~/.ssh/id_rsa.pub gituser@git.server.com</div></pre></td></tr></table></figure></p>
<p>上面的命令会产生以下结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">gituser@git.server.com&apos;s password:</div><div class="line">Now try logging into the machine, with &quot;ssh &apos;gituser@git.server.com&apos;&quot;, and check in:</div><div class="line">.ssh/authorized_keys</div><div class="line">to make sure we haven&apos;t added extra keys that you weren&apos;t expecting.</div></pre></td></tr></table></figure></p>
<p>同样，Jerry 也增加了他的公共密钥服务器使用 ssh-copy-id 这个命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[jerry@CentOS ~]$ pwd</div><div class="line">/home/jerry</div><div class="line">  </div><div class="line">[jerry@CentOS ~]$ ssh-copy-id -i ~/.ssh/id_rsa gituser@git.server.com</div></pre></td></tr></table></figure></p>
<p>上面的命令会产生以下结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">gituser@git.server.com&apos;s password:</div><div class="line">Now try logging into the machine, with &quot;ssh &apos;gituser@git.server.com&apos;&quot;, and check in:</div><div class="line">.ssh/authorized_keys</div><div class="line">to make sure we haven&apos;t added extra keys that you weren&apos;t expecting.</div></pre></td></tr></table></figure></p>
<h2 id="推修改到版本库"><a href="#推修改到版本库" class="headerlink" title="推修改到版本库"></a>推修改到版本库</h2><p>Git的init命令创建 .git 目录来存储元数据的存储库。每次读取配置从 .git/config 文件.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[tom@CentOS tom_repo]$ git init</div><div class="line">Initialized empty Git repository in /home/tom/tom_repo/.git/</div><div class="line">  </div><div class="line">[tom@CentOS tom_repo]$ echo &apos;TODO: Add contents for README&apos; &gt; README</div><div class="line">  </div><div class="line">[tom@CentOS tom_repo]$ git status -s</div><div class="line">?? README</div><div class="line">  </div><div class="line">[tom@CentOS tom_repo]$ git add .</div><div class="line">  </div><div class="line">[tom@CentOS tom_repo]$ git status -s</div><div class="line">A README</div><div class="line">  </div><div class="line">[tom@CentOS tom_repo]$ git commit -m &apos;Initial commit&apos;</div></pre></td></tr></table></figure></p>
<p>执行git 的日志命令，检查日志消息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[tom@CentOS tom_repo]$ git log</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Git创建操作&quot;&gt;&lt;a href=&quot;#Git创建操作&quot; class=&quot;headerlink&quot; title=&quot;Git创建操作&quot;&gt;&lt;/a&gt;Git创建操作&lt;/h1&gt;&lt;p&gt;作为Git服务器。需要一个的Git服务器允许团队协作。&lt;/p&gt;
&lt;h2 id=&quot;创建新用户&quot;&gt;&lt;a 
    
    </summary>
    
      <category term="VCS" scheme="http://yoursite.com/categories/VCS/"/>
    
      <category term="Git" scheme="http://yoursite.com/categories/VCS/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>02_Java容器篇_String</title>
    <link href="http://yoursite.com/2018/04/14/Backend/Java/container/02_Java%E5%AE%B9%E5%99%A8%E7%AF%87_String/"/>
    <id>http://yoursite.com/2018/04/14/Backend/Java/container/02_Java容器篇_String/</id>
    <published>2018-04-14T14:28:13.000Z</published>
    <updated>2018-04-14T14:28:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>java分为基本类型与引用类型，字符串作为最常用的引用类型，肯定是重要的 </p>
<p>而String中是char数组，在我看来也是容器，所以放在容器</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>String s = new String(“hello”)和String s = “hello”;的区别?</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>String s = new String(“hello”)会创建2（1）个对象，<br>String s = “hello”创建1（0）个对象。 </p>
<blockquote>
<p>注：当字符串常量池中有对象hello时括号内成立！</p>
</blockquote>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>==与equals()的区别：</p>
<ul>
<li>==:比较引用类型比较的是地址值是否相同</li>
<li>equals:比较引用类型默认也是比较地址值是否相同，而String类重写了equals()方法，比较的是内容是否相同。</li>
</ul>
<h2 id="Demo1"><a href="#Demo1" class="headerlink" title="Demo1"></a>Demo1</h2><p><img src="https://i.imgur.com/N5TL10G.jpg" alt="">  </p>
<h2 id="内存图"><a href="#内存图" class="headerlink" title="内存图"></a>内存图</h2><p><img src="https://i.imgur.com/7c8wAsJ.png" alt="">  </p>
<h2 id="Demo2"><a href="#Demo2" class="headerlink" title="Demo2"></a>Demo2</h2><p><img src="https://i.imgur.com/Ox88sBk.jpg" alt="">  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>String s = new String(“hello”)会创建2（1）个对象，<br> String s = “hello”创建1（0）个对象。 <blockquote>
<p>注：当字符串常量池中有对象hello时括号内成立！</p>
</blockquote>
</li>
<li>字符串如果是变量相加，先开空间，在拼接。<br> 字符串如果是常量相加，是先加，然后在常量池找，如果有就直接返回，否则，就创建。</li>
</ol>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>这里仅列举几个较为重要的部分</p>
<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><p><img src="https://i.imgur.com/84onwHC.jpg" alt="">  </p>
<p>字符串的hash算法为：<br>str.charAt(0) <em> 31^(n-1) + str.charAt(1) </em> 31^(n-2) + … + str.charAt(n-1)</p>
<p>返回的是一个int类型的数据,而int的最大值是2147483647<br>可见hashcode不是用来生成唯一键的，而是让某个数量级的无顺序的对象，能够用最快的速度找到，而且不占用太多的内存空间。   </p>
<p>像数据库那样不允许重复的，不适合用hashcode。<br>每个hashcode 等同于一个小屋，里面可以放多个对象，他们的hashcode相同。而唯一键，代表每个人都分配了一个小屋，全部是单间。<br><img src="https://i.imgur.com/rpPk3Lo.jpg" alt="">  </p>
<p>4个知识点：  </p>
<ol>
<li><p>java中所有的对象都有一个父类Object,而Object类都有hashCode方法，也就是说java中所有的类均会有hashCode方法</p>
</li>
<li><p>Object类的hashCode方法是native的，即是通用C语言来写的，String类重写了hashCode方法</p>
</li>
<li><p>String类的hashCode算法是固定的，根据算法就可以看到是可能会存在相同hashCode的</p>
</li>
<li><p>两个String的hashCode相同并不代表着equals比较时会相等，两者之间是没有必然关系</p>
</li>
</ol>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><p><img src="https://i.imgur.com/wjHtnbU.jpg" alt="">  </p>
<p>先是地址值比较，地址值相同直接返回true,<br>然后如果传入的不是字符串的话，均返回false,<br>如果是字符串，再比较长度，接下来就是拿字符串里的char数组一个个的比较了</p>
<p>可见String的equals和hashCode没有任何关系，当然如果hashCode不同，肯定是不同的字符串，hashCode相同，不一定是相同内容的字符串，必要不充分</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java分为基本类型与引用类型，字符串作为最常用的引用类型，肯定是重要的 &lt;/p&gt;
&lt;p&gt;而String中是char数组，在我看来也是容器，所以放在容器&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;
    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/"/>
    
      <category term="容器" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="Java容器" scheme="http://yoursite.com/tags/Java%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>03_Docker_镜像使用</title>
    <link href="http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/03_Docker_%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/03_Docker_镜像使用/</id>
    <published>2017-11-27T06:15:50.000Z</published>
    <updated>2017-11-27T06:15:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-镜像使用"><a href="#Docker-镜像使用" class="headerlink" title="Docker 镜像使用"></a>Docker 镜像使用</h1><p>当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。  </p>
<h2 id="列出镜像列表"><a href="#列出镜像列表" class="headerlink" title="列出镜像列表"></a>列出镜像列表</h2><p>使用 <strong>docker images</strong> 来列出本地主机上的镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker images           </div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div></pre></td></tr></table></figure></p>
<p>各个选项说明:  </p>
<ul>
<li>REPOSTITORY：表示镜像的仓库源</li>
<li>TAG：镜像的标签</li>
<li>IMAGE ID：镜像ID</li>
<li>CREATED：镜像创建时间</li>
<li>SIZE：镜像大小</li>
</ul>
<p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如ubuntu仓库源里，有15.10、14.04等多个不同的版本，我们使用 REPOSTITORY:TAG 来定义不同的镜像。  </p>
<p>如果不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。</p>
<h2 id="获取一个新的镜像"><a href="#获取一个新的镜像" class="headerlink" title="获取一个新的镜像"></a>获取一个新的镜像</h2><p>当在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果想预先下载这个镜像，可以使用 <strong>docker pull</strong> 命令来下载它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Crunoob@runoob:~$ docker pull ubuntu:13.10</div></pre></td></tr></table></figure></p>
<p>下载完成后，可以直接使用这个镜像来运行容器。</p>
<h2 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h2><p>可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： <a href="https://hub.docker.com/" target="_blank" rel="external">https://hub.docker.com/</a><br>也可以使用 <strong>docker search</strong> 命令来搜索镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$  docker search nginx</div></pre></td></tr></table></figure></p>
<ul>
<li>NAME:镜像仓库源的名称</li>
<li>DESCRIPTION:镜像的描述</li>
<li>OFFICIAL:是否docker官方发布</li>
</ul>
<h2 id="拖取镜像"><a href="#拖取镜像" class="headerlink" title="拖取镜像"></a>拖取镜像</h2><p>使用命令 docker pull 来下载镜像。</p>
<h1 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h1><p>当从docker镜像仓库中下载的镜像不能满足需求时，可以通过以下两种方式对镜像进行更改。  </p>
<ol>
<li>从已经创建的容器中更新镜像，并且提交这个镜像  </li>
<li>使用 Dockerfile 指令来创建一个新的镜像  </li>
</ol>
<h2 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h2><p>更新镜像之前，我们需要使用镜像来创建一个容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker run -i -t ubuntu:15.10 /bin/bash</div><div class="line">root@e218edb10161:/#</div></pre></td></tr></table></figure></p>
<p>在运行的容器内使用 apt-get update 命令进行更新。<br>在完成操作之后，输入 exit命令来退出这个容器。  </p>
<p>此时ID为e218edb10161的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit来提交容器副本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2</div><div class="line">sha256:70bf1840fd7c0d2d8ef0a42a817eb29f854c1af8f7c59fc03ac7bdee9545aff8</div></pre></td></tr></table></figure></p>
<p>各个参数说明：  </p>
<ul>
<li>m:提交的描述信息</li>
<li>a:指定镜像作者</li>
<li>e218edb10161：容器ID</li>
<li>runoob/ubuntu:v2:指定要创建的目标镜像名</li>
</ul>
<p>使用 docker images 命令来查看我们的新镜像 runoob/ubuntu:v2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker images</div></pre></td></tr></table></figure></p>
<p>使用新镜像 runoob/ubuntu 来启动一个容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -i -t runoob/ubuntu:v2 /bin/bash</div></pre></td></tr></table></figure></p>
<h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>使用命令 <strong>docker build</strong> ， 从零开始来创建一个新的镜像。为此，需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建新的镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ cat Dockerfile </div><div class="line">FROM    centos:6.7</div><div class="line">MAINTAINER      Fisher &quot;fisher@sudops.com&quot;</div><div class="line"></div><div class="line">RUN     /bin/echo &apos;root:123456&apos; |chpasswd</div><div class="line">RUN     useradd runoob</div><div class="line">RUN     /bin/echo &apos;runoob:123456&apos; |chpasswd</div><div class="line">RUN     /bin/echo -e &quot;LANG=\&quot;en_US.UTF-8\&quot;&quot; &gt;/etc/default/local</div><div class="line">EXPOSE  22</div><div class="line">EXPOSE  80</div><div class="line">CMD     /usr/sbin/sshd -D</div></pre></td></tr></table></figure></p>
<p>每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。<br>第一条FROM，指定使用哪个镜像源<br>RUN 指令告诉docker 在镜像内执行命令，安装了什么。<br>然后，我们使用 Dockerfile 文件，通过 docker build 命令来构建一个镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker build -t runoob/centos:6.7 .</div><div class="line">Sending build context to Docker daemon 17.92 kB</div><div class="line">Step 1 : FROM centos:6.7</div><div class="line"> ---&amp;gt; d95b5ca17cc3</div><div class="line">Step 2 : MAINTAINER Fisher &quot;fisher@sudops.com&quot;</div><div class="line"> ---&amp;gt; Using cache</div><div class="line"> ---&amp;gt; 0c92299c6f03</div><div class="line">Step 3 : RUN /bin/echo &apos;root:123456&apos; |chpasswd</div><div class="line"> ---&amp;gt; Using cache</div><div class="line"> ---&amp;gt; 0397ce2fbd0a</div><div class="line">Step 4 : RUN useradd runoob</div><div class="line">......</div></pre></td></tr></table></figure></p>
<p>参数说明：  </p>
<ul>
<li>t ：指定要创建的目标镜像名  </li>
<li>. ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径  </li>
</ul>
<p>使用docker images 查看创建的镜像已经在列表中存在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker images</div></pre></td></tr></table></figure></p>
<p>可以使用新的镜像来创建容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker run -t -i runoob/centos:6.7  /bin/bash</div><div class="line">[root@41c28d18b5fb /]# id runoob</div><div class="line">uid=500(runoob) gid=500(runoob) groups=500(runoob)</div></pre></td></tr></table></figure></p>
<h2 id="设置镜像标签"><a href="#设置镜像标签" class="headerlink" title="设置镜像标签"></a>设置镜像标签</h2><p>可以使用 <strong>docker tag</strong> 命令，为镜像添加一个新的标签。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker tag 860c279d2fec runoob/centos:dev</div></pre></td></tr></table></figure></p>
<p>docker tag 镜像ID，这里是 860c279d2fec ,用户名称、镜像源名(repository name)和新的标签名(tag)。  </p>
<p>使用 docker images 命令可以看到，ID为860c279d2fec的镜像多一个标签。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker images</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">runoob/centos       6.7                 860c279d2fec        5 hours ago         190.6 MB</div><div class="line">runoob/centos       dev                 860c279d2fec        5 hours ago         190.6 MB</div></pre></td></tr></table></figure></p>
<h2 id="Docker-容器镜像删除"><a href="#Docker-容器镜像删除" class="headerlink" title="Docker 容器镜像删除"></a>Docker 容器镜像删除</h2><h3 id="停止所有的container，这样才能够删除其中的images："><a href="#停止所有的container，这样才能够删除其中的images：" class="headerlink" title="停止所有的container，这样才能够删除其中的images："></a>停止所有的container，这样才能够删除其中的images：</h3><p>docker stop $(docker ps -a -q)</p>
<p>如果想要删除所有container的话再加一个指令：<br>docker rm $(docker ps -a -q)</p>
<h3 id="查看当前有哪些images"><a href="#查看当前有哪些images" class="headerlink" title="查看当前有哪些images"></a>查看当前有哪些images</h3><p>docker images</p>
<h3 id="删除images，通过image的id来指定删除镜像"><a href="#删除images，通过image的id来指定删除镜像" class="headerlink" title="删除images，通过image的id来指定删除镜像"></a>删除images，通过image的id来指定删除镜像</h3><p>docker rmi <image id=""></image></p>
<p>想要删除untagged images，也就是那些id为<none>的image的话可以用<br>docker rmi $(docker images | grep “^<none>“ | awk “{print $3}”)</none></none></p>
<p>要删除全部image的话<br>docker rmi $(docker images -q)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-镜像使用&quot;&gt;&lt;a href=&quot;#Docker-镜像使用&quot; class=&quot;headerlink&quot; title=&quot;Docker 镜像使用&quot;&gt;&lt;/a&gt;Docker 镜像使用&lt;/h1&gt;&lt;p&gt;当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从
    
    </summary>
    
      <category term="Cloud&amp;BigData" scheme="http://yoursite.com/categories/Cloud-BigData/"/>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Cloud-BigData/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>04_Docker_容器连接</title>
    <link href="http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/04_Docker_%E5%AE%B9%E5%99%A8%E8%BF%9E%E6%8E%A5/"/>
    <id>http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/04_Docker_容器连接/</id>
    <published>2017-11-27T06:15:50.000Z</published>
    <updated>2017-11-27T06:15:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络端口映射"><a href="#网络端口映射" class="headerlink" title="网络端口映射"></a>网络端口映射</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run -d -P training/webapp python app.py</div><div class="line">fce072cc88cee71b1cdceb57c2821d054a4a59f67da6b416fceb5593f059fc6d</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 5000:5000 training/webapp python app.py</div><div class="line">33e4523d30aaf0258915c368e66e03b49535de0ef20317d3f639d40222ba6bc0</div></pre></td></tr></table></figure>
<ul>
<li>-P :是容器内部端口随机映射到主机的高端口。</li>
<li>-p : 是容器内部端口绑定到指定的主机端口。</li>
</ul>
<p>使用 docker ps 来看到端口5000绑定主机端口32768。</p>
<p>可以指定容器绑定的网络地址，比如绑定127.0.0.1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 127.0.0.1:5001:5002 training/webapp python app.py</div><div class="line">95c6ceef88ca3e71eaf303c2833fd6701d8d1b2572b5613b5a932dfdfe8a857c</div></pre></td></tr></table></figure></p>
<p>默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 /udp。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</div><div class="line">6779686f06f6204579c1d655dd8b2b31e8e809b245a97b2d3a8e35abe9dcd22a</div></pre></td></tr></table></figure></p>
<p><strong>docker port</strong> 命令可以让我们快捷地查看端口的绑定情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker port adoring_stonebraker 5002</div></pre></td></tr></table></figure></p>
<h2 id="Docker容器连接"><a href="#Docker容器连接" class="headerlink" title="Docker容器连接"></a>Docker容器连接</h2><p>端口映射并不是唯一把 docker 连接到另一个容器的方法。<br>docker有一个连接系统允许将多个容器连接在一起，共享连接信息。<br>docker连接会创建一个父子关系，其中父容器可以看到子容器的信息。  </p>
<h3 id="容器命名"><a href="#容器命名" class="headerlink" title="容器命名"></a>容器命名</h3><p>当我们创建一个容器的时候，docker会自动对它进行命名。另外，我们也可以使用–name标识来命名容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run -d -P --name runoob training/webapp python app.py</div><div class="line">43780a6eabaaf14e590b6e849235c75f3012995403f97749775e38436db9a441</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;网络端口映射&quot;&gt;&lt;a href=&quot;#网络端口映射&quot; class=&quot;headerlink&quot; title=&quot;网络端口映射&quot;&gt;&lt;/a&gt;网络端口映射&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
    
    </summary>
    
      <category term="Cloud&amp;BigData" scheme="http://yoursite.com/categories/Cloud-BigData/"/>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Cloud-BigData/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>05_Docker_命令大全</title>
    <link href="http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/05_Docker_%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/05_Docker_命令大全/</id>
    <published>2017-11-27T06:15:50.000Z</published>
    <updated>2017-11-27T06:15:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="info-version"><a href="#info-version" class="headerlink" title="info | version"></a>info | version</h2><h3 id="info"><a href="#info" class="headerlink" title="info"></a>info</h3><p>docker info : 显示 Docker 系统信息，包括镜像和容器数。。  </p>
<h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>docker version :显示 Docker 版本信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker version [OPTIONS]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-f :指定返回值的模板文件。</li>
</ul>
<h2 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h2><h3 id="login-logout"><a href="#login-logout" class="headerlink" title="login/logout"></a>login/logout</h3><p>docker login : 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub<br>docker logout : 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker login [OPTIONS] [SERVER]</div><div class="line">docker logout [OPTIONS] [SERVER]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-u :登陆的用户名</li>
<li>-p :登陆的密码</li>
</ul>
<p>登陆到Docker Hub<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker login -u 用户名 -p 密码</div></pre></td></tr></table></figure></p>
<p>登出Docker Hub<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker logout</div></pre></td></tr></table></figure></p>
<h3 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h3><p>docker pull : 从镜像仓库中拉取或者更新指定镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull [OPTIONS] NAME[:TAG|@DIGEST]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-a :拉取所有 tagged 镜像</li>
<li>–disable-content-trust :忽略镜像的校验,默认开启</li>
</ul>
<p>从Docker Hub下载java最新版镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull java</div></pre></td></tr></table></figure></p>
<p>从Docker Hub下载REPOSITORY为java的所有镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull -a java</div></pre></td></tr></table></figure></p>
<h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p>docker push : 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker push [OPTIONS] NAME[:TAG]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>–disable-content-trust :忽略镜像的校验,默认开启</li>
</ul>
<p>上传本地镜像myapache:v1到镜像仓库中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker push myapache:v1</div></pre></td></tr></table></figure></p>
<h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>docker search : 从Docker Hub查找镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker search [OPTIONS] TERM</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>–automated :只列出 automated build类型的镜像；</li>
<li>–no-trunc :显示完整的镜像描述；</li>
<li>-s :列出收藏数不小于指定值的镜像。</li>
</ul>
<p>从Docker Hub查找所有镜像名包含java，并且收藏数大于10的镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker search -s 10 java</div></pre></td></tr></table></figure></p>
<h2 id="本地镜像管理"><a href="#本地镜像管理" class="headerlink" title="本地镜像管理"></a>本地镜像管理</h2><h3 id="images"><a href="#images" class="headerlink" title="images"></a>images</h3><p>docker images : 列出本地镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker images [OPTIONS] [REPOSITORY[:TAG]]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</li>
<li>–digests :显示镜像的摘要信息；</li>
<li>-f :显示满足条件的镜像；</li>
<li>–format :指定返回值的模板文件；</li>
<li>–no-trunc :显示完整的镜像信息；</li>
<li>-q :只显示镜像ID。</li>
</ul>
<p>列出本地镜像中REPOSITORY为ubuntu的镜像列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker images  ubuntu</div></pre></td></tr></table></figure></p>
<h3 id="rmi"><a href="#rmi" class="headerlink" title="rmi"></a>rmi</h3><p>docker rmi : 删除本地一个或多少镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-f :强制删除；</li>
<li>–no-prune :不移除该镜像的过程镜像，默认移除；</li>
</ul>
<p>强制删除本地镜像runoob/ubuntu:v4。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rmi -f runoob/ubuntu:v4</div></pre></td></tr></table></figure></p>
<h3 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h3><p>docker tag : 标记本地镜像，将其归入某一仓库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]</div></pre></td></tr></table></figure></p>
<p>将镜像ubuntu:15.10标记为 runoob/ubuntu:v3 镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker tag ubuntu:15.10 runoob/ubuntu:v3</div></pre></td></tr></table></figure></p>
<h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>docker build : 使用Dockerfile创建镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build [OPTIONS] PATH | URL | -</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：  </p>
<ul>
<li>–build-arg=[] :设置镜像创建时的变量；</li>
<li>–cpu-shares :设置 cpu 使用权重；</li>
<li>–cpu-period :限制 CPU CFS周期；</li>
<li>–cpu-quota :限制 CPU CFS配额；</li>
<li>–cpuset-cpus :指定使用的CPU id；</li>
<li>–cpuset-mems :指定使用的内存 id；</li>
<li>–disable-content-trust :忽略校验，默认开启；</li>
<li>-f :指定要使用的Dockerfile路径；</li>
<li>–force-rm :设置镜像过程中删除中间容器；</li>
<li>–isolation :使用容器隔离技术；</li>
<li>–label=[] :设置镜像使用的元数据；</li>
<li>-m :设置内存最大值；</li>
<li>–memory-swap :设置Swap的最大值为内存+swap，”-1”表示不限swap；</li>
<li>–no-cache :创建镜像的过程不使用缓存；</li>
<li>–pull :尝试去更新镜像的新版本；</li>
<li>-q :安静模式，成功后只输出镜像ID；</li>
<li>–rm :设置镜像成功后删除中间容器；</li>
<li>–shm-size :设置/dev/shm的大小，默认值是64M；</li>
<li>–ulimit :Ulimit配置。</li>
</ul>
<p>使用当前目录的Dockerfile创建镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build -t runoob/ubuntu:v1 .</div></pre></td></tr></table></figure></p>
<p>使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build github.com/creack/docker-firefox</div></pre></td></tr></table></figure></p>
<h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>docker history : 查看指定镜像的创建历史。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker history [OPTIONS] IMAGE</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：  </p>
<ul>
<li>-H :以可读的格式打印镜像大小和日期，默认为true；</li>
<li>–no-trunc :显示完整的提交记录；</li>
<li>-q :仅列出提交记录ID。</li>
</ul>
<p>查看本地镜像runoob/ubuntu:v3的创建历史。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker history runoob/ubuntu:v3</div></pre></td></tr></table></figure></p>
<h3 id="save"><a href="#save" class="headerlink" title="save"></a>save</h3><p>docker save : 将指定镜像保存成 tar 归档文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker save [OPTIONS] IMAGE [IMAGE...]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-o :输出到的文件。</li>
</ul>
<p>将镜像runoob/ubuntu:v3 生成my_ubuntu_v3.tar文档<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3</div></pre></td></tr></table></figure></p>
<p>docker 容器导入导出有两种方法：  </p>
<p>一种是使用 save 和 load 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker save ubuntu:load&gt;/root/ubuntu.tar</div><div class="line">docker load&lt;ubuntu.tar</div></pre></td></tr></table></figure></p>
<p>一种是使用 export 和 import 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker export 98ca36&gt; ubuntu.tar</div><div class="line">cat ubuntu.tar | sudo docker import - ubuntu:import</div></pre></td></tr></table></figure></p>
<p>注意两种方法不可混用。</p>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>docker import : 从归档文件中创建镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：  </p>
<ul>
<li>-c :应用docker 指令创建镜像；</li>
<li>-m :提交时的说明文字；</li>
</ul>
<p>从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为runoob/ubuntu:v4<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker import  my_ubuntu_v3.tar runoob/ubuntu:v4</div></pre></td></tr></table></figure></p>
<h2 id="容器生命周期管理"><a href="#容器生命周期管理" class="headerlink" title="容器生命周期管理"></a>容器生命周期管理</h2><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>docker run ：创建一个新的容器并运行一个命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</li>
<li>-d: 后台运行容器，并返回容器ID；</li>
<li>-i: 以交互模式运行容器，通常与 -t 同时使用；</li>
<li>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li>
<li>–name=”nginx-lb”: 为容器指定一个名称；</li>
<li>–dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；</li>
<li>–dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；</li>
<li>-h “mars”: 指定容器的hostname；</li>
<li>-e username=”ritchie”: 设置环境变量；</li>
<li>–env-file=[]: 从指定文件读入环境变量；</li>
<li>–cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行；</li>
<li>-m :设置容器使用内存最大值；</li>
<li>–net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</li>
<li>–link=[]: 添加链接到另一个容器；</li>
<li>–expose=[]: 开放一个端口或一组端口；</li>
</ul>
<p>使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --name mynginx -d nginx:latest</div></pre></td></tr></table></figure></p>
<p>使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -P -d nginx:latest</div></pre></td></tr></table></figure></p>
<p>使用镜像nginx:latest以后台模式启动一个容器,将容器的80端口映射到主机的80端口,主机的目录/data映射到容器的/data。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -p 80:80 -v /data:/data -d nginx:latest</div></pre></td></tr></table></figure></p>
<p>使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -it nginx:latest /bin/bash</div></pre></td></tr></table></figure></p>
<h3 id="start-stop-restart"><a href="#start-stop-restart" class="headerlink" title="start/stop/restart"></a>start/stop/restart</h3><p>docker start :启动一个或多少已经被停止的容器<br>docker stop :停止一个运行中的容器<br>docker restart :重启容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker start [OPTIONS] CONTAINER [CONTAINER...]</div><div class="line">docker stop [OPTIONS] CONTAINER [CONTAINER...]</div><div class="line">docker restart [OPTIONS] CONTAINER [CONTAINER...]</div></pre></td></tr></table></figure></p>
<p>启动已被停止的容器myrunoob<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker start myrunoob</div></pre></td></tr></table></figure></p>
<p>停止运行中的容器myrunoob<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker stop myrunoob</div></pre></td></tr></table></figure></p>
<p>重启容器myrunoob<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker restart myrunoob</div></pre></td></tr></table></figure></p>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>docker kill :杀掉一个运行中的容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker kill [OPTIONS] CONTAINER [CONTAINER...]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-s :向容器发送一个信号</li>
</ul>
<p>杀掉运行中的容器mynginx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker kill -s KILL mynginx</div></pre></td></tr></table></figure></p>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>docker rm ：删除一个或多少容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm [OPTIONS] CONTAINER [CONTAINER...]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-f :通过SIGKILL信号强制删除一个运行中的容器</li>
<li>-l :移除容器间的网络连接，而非容器本身</li>
<li>-v :-v 删除与容器关联的卷</li>
</ul>
<p>强制删除容器db01、db02<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm -f db01、db02</div></pre></td></tr></table></figure></p>
<p>移除容器nginx01对容器db01的连接，连接名db<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm -l db</div></pre></td></tr></table></figure></p>
<p>删除容器nginx01,并删除容器挂载的数据卷<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm -v nginx01</div></pre></td></tr></table></figure></p>
<h3 id="pause-unpause"><a href="#pause-unpause" class="headerlink" title="pause/unpause"></a>pause/unpause</h3><p>docker pause :暂停容器中所有的进程。<br>docker unpause :恢复容器中所有的进程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker pause [OPTIONS] CONTAINER [CONTAINER...]</div><div class="line">docker unpause [OPTIONS] CONTAINER [CONTAINER...]</div></pre></td></tr></table></figure></p>
<p>暂停数据库容器db01提供服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pause db01</div></pre></td></tr></table></figure></p>
<p>恢复数据库容器db01提供服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker unpause db01</div></pre></td></tr></table></figure></p>
<h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><p>docker create ：创建一个新的容器但不启动它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</div></pre></td></tr></table></figure></p>
<p>用法同 docker run</p>
<p>使用docker镜像nginx:latest创建一个容器,并将容器命名为myrunoob<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker create  --name myrunoob  nginx:latest</div></pre></td></tr></table></figure></p>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>docker exec ：在运行的容器中执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-d :分离模式: 在后台运行</li>
<li>-i :即使没有附加也保持STDIN 打开</li>
<li>-t :分配一个伪终端</li>
</ul>
<p>在容器mynginx中以交互模式执行容器内/root/runoob.sh脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker exec -it mynginx /bin/sh /root/runoob.sh</div></pre></td></tr></table></figure></p>
<p>在容器mynginx中开启一个交互模式的终端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker exec -i -t  mynginx /bin/bash</div></pre></td></tr></table></figure></p>
<h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>docker ps : 列出容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker ps [OPTIONS]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-a :显示所有的容器，包括未运行的。</li>
<li>-f :根据条件过滤显示的内容。</li>
<li>–format :指定返回值的模板文件。</li>
<li>-l :显示最近创建的容器。</li>
<li>-n :列出最近创建的n个容器。</li>
<li>–no-trunc :不截断输出。</li>
<li>-q :静默模式，只显示容器编号。</li>
<li>-s :显示总的文件大小。</li>
</ul>
<p>列出所有在运行的容器信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker ps</div></pre></td></tr></table></figure></p>
<p>列出最近创建的5个容器信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker ps -n 5</div></pre></td></tr></table></figure></p>
<p>列出所有创建的容器ID。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker ps -a -q</div></pre></td></tr></table></figure></p>
<h3 id="inspect"><a href="#inspect" class="headerlink" title="inspect"></a>inspect</h3><p>docker inspect : 获取容器/镜像的元数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker inspect [OPTIONS] NAME|ID [NAME|ID...]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：  </p>
<ul>
<li>-f :指定返回值的模板文件。</li>
<li>-s :显示总的文件大小。</li>
<li>–type :为指定类型返回JSON。</li>
</ul>
<p>获取镜像mysql:5.6的元信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker inspect mysql:5.6</div></pre></td></tr></table></figure></p>
<p>获取正在运行的容器mymysql的 IP。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker inspect --format=&apos;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&apos; mymysql  </div><div class="line">172.17.0.3</div></pre></td></tr></table></figure></p>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>docker top :查看容器中运行的进程信息，支持 ps 命令参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker top [OPTIONS] CONTAINER [ps OPTIONS]</div></pre></td></tr></table></figure></p>
<p>容器运行时不一定有/bin/bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程。  </p>
<p>查看容器mymysql的进程信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker top mymysql</div></pre></td></tr></table></figure></p>
<p>查看所有运行容器的进程信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for i in  `docker ps |grep Up|awk &apos;&#123;print $1&#125;&apos;`;do echo \ &amp;&amp;docker top $i; done</div></pre></td></tr></table></figure></p>
<h3 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h3><p>docker attach :连接到正在运行中的容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker attach [OPTIONS] CONTAINER</div></pre></td></tr></table></figure></p>
<p>要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。<br>官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上–sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。  </p>
<p>容器mynginx将访问日志指到标准输出，连接到容器查看访问信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker attach --sig-proxy=false mynginx</div></pre></td></tr></table></figure></p>
<h3 id="events"><a href="#events" class="headerlink" title="events"></a>events</h3><p>docker events : 从服务器获取实时事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker events [OPTIONS]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-f ：根据条件过滤事件；</li>
<li>–since ：从指定的时间戳后显示所有事件;</li>
<li>–until ：流水时间显示到指定的时间为止；</li>
</ul>
<p>显示docker 2016年7月1日后的所有事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker events  --since=&quot;1467302400&quot;</div></pre></td></tr></table></figure></p>
<p>显示docker 镜像为mysql:5.6 2016年7月1日后的相关事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker events -f &quot;image&quot;=&quot;mysql:5.6&quot; --since=&quot;1467302400&quot;</div></pre></td></tr></table></figure></p>
<p>如果指定的时间是到秒级的，需要将时间转成时间戳。如果时间为日期的话，可以直接使用，如–since=”2016-07-01”。  </p>
<h3 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h3><p>docker logs : 获取容器的日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker logs [OPTIONS] CONTAINER</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-f : 跟踪日志输出</li>
<li>–since :显示某个开始时间的所有日志</li>
<li>-t : 显示时间戳</li>
<li>–tail :仅列出最新N条容器日志</li>
</ul>
<p>跟踪查看容器mynginx的日志输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker logs -f mynginx</div></pre></td></tr></table></figure></p>
<p>查看容器mynginx从2016年7月1日后的最新10条日志。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker logs --since=&quot;2016-07-01&quot; --tail=10 mynginx</div></pre></td></tr></table></figure></p>
<h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><p>docker wait : 阻塞运行直到容器停止，然后打印出它的退出代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker wait [OPTIONS] CONTAINER [CONTAINER...]</div></pre></td></tr></table></figure></p>
<h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><p>docker export :将文件系统作为一个tar归档文件导出到STDOUT。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker export [OPTIONS] CONTAINER</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-o :将输入内容写到文件。</li>
</ul>
<p>将id为a404c6c174a2的容器按日期保存为tar文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker export -o mysql-`date +%Y%m%d`.tar a404c6c174a2</div></pre></td></tr></table></figure></p>
<h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><p>docker port :列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]]</div></pre></td></tr></table></figure></p>
<p>查看容器mynginx的端口映射情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker port mymysql</div></pre></td></tr></table></figure></p>
<h2 id="容器rootfs命令"><a href="#容器rootfs命令" class="headerlink" title="容器rootfs命令"></a>容器rootfs命令</h2><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><p>docker commit :从容器创建一个新的镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-a :提交的镜像作者；</li>
<li>-c :使用Dockerfile指令来创建镜像；</li>
<li>-m :提交时的说明文字；</li>
<li>-p :在commit时，将容器暂停。</li>
</ul>
<p>将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker commit -a &quot;runoob.com&quot; -m &quot;my apache&quot; a404c6c174a2  mymysql:v1</div></pre></td></tr></table></figure></p>
<h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>docker cp :用于容器与主机之间的数据拷贝。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</div><div class="line">docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</div></pre></td></tr></table></figure></p>
<p>OPTIONS说明：</p>
<ul>
<li>-L :保持源目标中的链接</li>
</ul>
<p>将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker cp /www/runoob 96f7f14e99ab:/www/</div></pre></td></tr></table></figure></p>
<p>将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker cp /www/runoob 96f7f14e99ab:/www</div></pre></td></tr></table></figure></p>
<p>将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker cp  96f7f14e99ab:/www /tmp/</div></pre></td></tr></table></figure></p>
<h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>docker diff : 检查容器里文件结构的更改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker diff [OPTIONS] CONTAINER</div></pre></td></tr></table></figure></p>
<p>查看容器mymysql的文件结构更改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker diff mymysql</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;info-version&quot;&gt;&lt;a href=&quot;#info-version&quot; class=&quot;headerlink&quot; title=&quot;info | version&quot;&gt;&lt;/a&gt;info | version&lt;/h2&gt;&lt;h3 id=&quot;info&quot;&gt;&lt;a href=&quot;#info&quot;
    
    </summary>
    
      <category term="Cloud&amp;BigData" scheme="http://yoursite.com/categories/Cloud-BigData/"/>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Cloud-BigData/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>01_Docker_Hello_World</title>
    <link href="http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/01_Docker_Hello_World/"/>
    <id>http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/01_Docker_Hello_World/</id>
    <published>2017-11-27T06:15:50.000Z</published>
    <updated>2017-11-27T06:15:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-Hello-World"><a href="#Docker-Hello-World" class="headerlink" title="Docker Hello World"></a>Docker Hello World</h1><p>Docker 允许你在容器内运行应用程序， 使用 docker run 命令来在容器内运行一个应用程序。<br>输出Hello world</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker run ubuntu:15.10 /bin/echo &quot;Hello world&quot;</div><div class="line">Hello world</div></pre></td></tr></table></figure>
<p>各个参数解析：</p>
<ul>
<li>docker: Docker 的二进制执行文件。</li>
<li>run:与前面的 docker 组合来运行一个容器。</li>
<li>ubuntu:15.10指定要运行的镜像，Docker首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。</li>
<li>/bin/echo “Hello world”: 在启动的容器里执行的命令</li>
</ul>
<h1 id="运行交互式的容器"><a href="#运行交互式的容器" class="headerlink" title="运行交互式的容器"></a>运行交互式的容器</h1><p>通过docker的两个参数 -i -t，让docker运行的容器实现”对话”的能力</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker run -i -t ubuntu:15.10 /bin/bash</div><div class="line">root@dc0050c79503:/#</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run –i -t –-name nginx_test[这个名字可以随便起] 904d6c400333[IMAGE ID] /bin/bash</div></pre></td></tr></table></figure>
<p>各个参数解析：</p>
<ul>
<li>t:在新容器内指定一个伪终端或终端。</li>
<li>i:允许你对容器内的标准输入 (STDIN) 进行交互。</li>
</ul>
<p>此时已进入一个 ubuntu15.10系统的容器<br>尝试在容器中运行命令 cat /proc/version和ls分别查看当前系统的版本信息和当前目录下的文件列表<br><img src="https://i.imgur.com/oiv1hkR.png" alt=""><br>可以通过运行exit命令或者使用CTRL+D来退出容器。</p>
<h1 id="启动容器（后台模式）"><a href="#启动容器（后台模式）" class="headerlink" title="启动容器（后台模式）"></a>启动容器（后台模式）</h1><p>使用以下命令创建一个以进程方式运行的容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker run -d ubuntu:15.10 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</div><div class="line">2b1b7a428627c51ab8810d541d759f072b4fc75487eed05812646b8534a2fe63</div></pre></td></tr></table></figure></p>
<p>在输出中，我们没有看到期望的”hello world”，而是一串长字符<br>2b1b7a428627c51ab8810d541d759f072b4fc75487eed05812646b8534a2fe63<br>这个长字符串叫做容器ID，对每个容器来说都是唯一的，我们可以通过容器ID来查看对应的容器发生了什么。<br>首先，我们需要确认容器有在运行，可以通过 <strong>docker ps</strong> 来查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker ps</div></pre></td></tr></table></figure></p>
<p>CONTAINER ID:容器ID<br>NAMES:自动分配的容器名称</p>
<p>在容器内使用 <strong>docker logs</strong> 命令，查看容器内的标准输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker logs 2b1b7a428627</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker logs amazing_cori</div></pre></td></tr></table></figure></p>
<h1 id="git-bash连接"><a href="#git-bash连接" class="headerlink" title="git-bash连接"></a>git-bash连接</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine ssh default</div></pre></td></tr></table></figure>
<h1 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h1><p>使用 <strong>docker stop</strong> 命令来停止容器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker stop 2b1b7a428627</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker logs amazing_cori</div></pre></td></tr></table></figure></p>
<p>通过docker ps查看，容器已经停止工作:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker ps</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-Hello-World&quot;&gt;&lt;a href=&quot;#Docker-Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Docker Hello World&quot;&gt;&lt;/a&gt;Docker Hello World&lt;/h1&gt;&lt;p&gt;Docker
    
    </summary>
    
      <category term="Cloud&amp;BigData" scheme="http://yoursite.com/categories/Cloud-BigData/"/>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Cloud-BigData/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>02_Docker_容器使用</title>
    <link href="http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/02_Docker_%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/11/27/Cloud&amp;BigData/Docker/02_Docker_容器使用/</id>
    <published>2017-11-27T06:15:50.000Z</published>
    <updated>2017-11-27T06:15:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-容器使用"><a href="#Docker-容器使用" class="headerlink" title="Docker 容器使用"></a>Docker 容器使用</h1><h2 id="Docker-客户端"><a href="#Docker-客户端" class="headerlink" title="Docker 客户端"></a>Docker 客户端</h2><p>可以直接输入 docker 命令来查看到 Docker 客户端的所有命令选项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~# docker</div></pre></td></tr></table></figure></p>
<p><img src="https://i.imgur.com/sjan9rZ.png" alt="">  </p>
<p>可以通过命令 <strong>docker command –help</strong> 更深入的了解指定的 Docker 命令使用方法。<br>例如要查看 docker stats 指令的具体使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~# docker stats --help</div></pre></td></tr></table></figure></p>
<p><img src="https://i.imgur.com/BA4GSFY.png" alt="">  </p>
<h2 id="运行一个web应用"><a href="#运行一个web应用" class="headerlink" title="运行一个web应用"></a>运行一个web应用</h2><p>使用 docker 构建一个 web 应用程序。<br>在docker容器中运行一个 Python Flask 应用来运行一个web应用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~# docker run -d -P training/webapp python app.py</div></pre></td></tr></table></figure></p>
<p>参数说明:</p>
<ul>
<li>d:让容器在后台运行。</li>
<li>P:将容器内部使用的网络端口映射到我们使用的主机上。</li>
</ul>
<h2 id="查看-WEB-应用容器"><a href="#查看-WEB-应用容器" class="headerlink" title="查看 WEB 应用容器"></a>查看 WEB 应用容器</h2><p>使用 <strong>docker ps</strong> 来查看我们正在运行的容器<br>使用 <strong>docker inspect</strong> 命令可以查看更详细的关于某一个容器的信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker ps</div></pre></td></tr></table></figure></p>
<p>多了端口信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PORTS</div><div class="line">0.0.0.0:32769-&gt;5000/tcp</div></pre></td></tr></table></figure></p>
<p>Docker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 32769 上。</p>
<p>也可以指定 -p 标识来绑定指定端口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker run -d -p 5000:5000 training/webapp python app.py</div></pre></td></tr></table></figure></p>
<p>docker ps查看正在运行的容器<br>容器内部的 5000 端口映射到我们本地主机的 5000 端口上。  </p>
<h2 id="网络端口的快捷方式"><a href="#网络端口的快捷方式" class="headerlink" title="网络端口的快捷方式"></a>网络端口的快捷方式</h2><p>通过 <strong>docker ps</strong> 命令可以查看到容器的端口映射<br>docker还提供了另一个快捷方式： <strong>docker port</strong> ,使用 docker port 可以查看指定 （ID或者名字）容器的某个确定端口映射到宿主机的端口号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker port 7a38a1ad55c6</div><div class="line">5000/tcp -&gt; 0.0.0.0:5000</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker port determined_swanson</div><div class="line">5000/tcp -&gt; 0.0.0.0:5000</div></pre></td></tr></table></figure></p>
<h2 id="查看WEB应用程序日志"><a href="#查看WEB应用程序日志" class="headerlink" title="查看WEB应用程序日志"></a>查看WEB应用程序日志</h2><p><strong>docker logs [ID或者名字]</strong> 可以查看容器内部的标准输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker logs -f 7a38a1ad55c6</div><div class="line"> * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</div><div class="line">192.168.239.1 - - [09/May/2016 16:30:37] &quot;GET / HTTP/1.1&quot; 200 -</div><div class="line">192.168.239.1 - - [09/May/2016 16:30:37] &quot;GET /favicon.ico HTTP/1.1&quot; 404 -</div></pre></td></tr></table></figure>
<p>-f:让 dokcer logs 像使用 tail -f 一样来输出容器内部的标准输出。<br>从上面，可以看到应用程序使用的是 5000 端口并且能够查看到应用程序的访问日志。  </p>
<h2 id="查看WEB应用程序容器的进程"><a href="#查看WEB应用程序容器的进程" class="headerlink" title="查看WEB应用程序容器的进程"></a>查看WEB应用程序容器的进程</h2><p>使用 <strong>docker top</strong> 来查看容器内部运行的进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker top determined_swanson</div></pre></td></tr></table></figure></p>
<h2 id="检查WEB应用程序"><a href="#检查WEB应用程序" class="headerlink" title="检查WEB应用程序"></a>检查WEB应用程序</h2><p>使用 <strong>docker inspect</strong> 来查看Docker的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker inspect determined_swanson</div><div class="line">[</div><div class="line">    &#123;</div><div class="line">        &quot;Id&quot;: &quot;7a38a1ad55c6914b360b565819604733db751d86afd2575236a70a2519527361&quot;,</div><div class="line">        &quot;Created&quot;: &quot;2016-05-09T16:20:45.427996598Z&quot;,</div><div class="line">        &quot;Path&quot;: &quot;python&quot;,</div><div class="line">        &quot;Args&quot;: [</div><div class="line">            &quot;app.py&quot;</div><div class="line">        ],</div><div class="line">        &quot;State&quot;: &#123;</div><div class="line">            &quot;Status&quot;: &quot;running&quot;,</div><div class="line">......</div></pre></td></tr></table></figure></p>
<h2 id="停止WEB应用容器"><a href="#停止WEB应用容器" class="headerlink" title="停止WEB应用容器"></a>停止WEB应用容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker stop determined_swanson   </div><div class="line">determined_swanson</div></pre></td></tr></table></figure>
<h2 id="重启WEB应用容器"><a href="#重启WEB应用容器" class="headerlink" title="重启WEB应用容器"></a>重启WEB应用容器</h2><p>已经停止的容器，可以使用命令 docker start 来启动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker start determined_swanson</div><div class="line">determined_swanson</div></pre></td></tr></table></figure></p>
<p>docker ps -l 查询最后一次创建的容器  </p>
<p>正在运行的容器，我们可以使用 docker restart 命令来重启  </p>
<h2 id="移除WEB应用容器"><a href="#移除WEB应用容器" class="headerlink" title="移除WEB应用容器"></a>移除WEB应用容器</h2><p>可以使用 <strong>docker rm</strong> 命令来删除不需要的容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker rm determined_swanson  </div><div class="line">determined_swanson</div></pre></td></tr></table></figure></p>
<p>删除容器时，容器必须是停止状态，否则会报如下错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runoob@runoob:~$ docker rm determined_swanson</div><div class="line">Error response from daemon: You cannot remove a running container 7a38a1ad55c6914b360b565819604733db751d86afd2575236a70a2519527361. Stop the container before attempting removal or use -f</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-容器使用&quot;&gt;&lt;a href=&quot;#Docker-容器使用&quot; class=&quot;headerlink&quot; title=&quot;Docker 容器使用&quot;&gt;&lt;/a&gt;Docker 容器使用&lt;/h1&gt;&lt;h2 id=&quot;Docker-客户端&quot;&gt;&lt;a href=&quot;#Docker-
    
    </summary>
    
      <category term="Cloud&amp;BigData" scheme="http://yoursite.com/categories/Cloud-BigData/"/>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Cloud-BigData/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>02_Java并发篇_线程状态_Java内存模型</title>
    <link href="http://yoursite.com/2017/07/29/Backend/Java/concurrency/02_Java%E5%B9%B6%E5%8F%91%E7%AF%87_%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81_Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2017/07/29/Backend/Java/concurrency/02_Java并发篇_线程状态_Java内存模型/</id>
    <published>2017-07-29T12:57:13.000Z</published>
    <updated>2017-07-29T12:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><p>Java中，线程的状态有以下6类：NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED。  </p>
<p><img src="http://i.imgur.com/6UG5qH5.png" alt="">  </p>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>Java内存模型把Java虚拟机内部划分为线程栈和堆。  </p>
<p>每一个运行在Java虚拟机里的线程都拥有自己的线程栈。  </p>
<p>一个线程仅能访问自己的线程栈。一个线程创建的本地变量对其它线程不可见，仅自己可见。  </p>
<p>即使两个线程执行同样的代码，这两个线程任然在在自己的线程栈中的代码来创建本地变量。因此，每个线程拥有每个本地变量的独有版本。  </p>
<p>所有原始类型的本地变量都存放在线程栈上，因此对其它线程不可见。一个线程可能向另一个线程传递一个原始类型变量的拷贝，但是它不能共享这个原始类型变量自身。  </p>
<p>堆上包含在Java程序中创建的所有对象，无论是哪一个对象创建的。这包括原始类型的对象版本。如果一个对象被创建然后赋值给一个局部变量，或者用来作为另一个对象的成员变量，这个对象任然是存放在堆上。  </p>
<p><img src="http://i.imgur.com/KkNgaH3.png" alt="">  </p>
<p>一个本地变量可能是原始类型，在这种情况下，它总是“呆在”线程栈上。  </p>
<p>一个本地变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。  </p>
<p>一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量任然存放在线程栈上，即使这些方法所属的对象存放在堆上。  </p>
<p><strong>一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。</strong>  </p>
<p><strong>静态成员变量跟随着类定义一起也存放在堆上。</strong></p>
<p>存放在堆上的对象可以被所有持有对这个对象引用的线程访问。<br>当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。<br>如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个本地变量的私有拷贝。<br><img src="http://i.imgur.com/P8Qadbg.png" alt="">  </p>
<h1 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a>硬件内存架构</h1><p><img src="http://i.imgur.com/N1SOkpH.png" alt="">  </p>
<p>每个CPU都包含一系列的寄存器，它们是CPU内内存的基础。CPU在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为CPU访问寄存器的速度远大于主存。  </p>
<p>每个CPU可能还有一个CPU缓存层。实际上，绝大多数的现代CPU都有一定大小的缓存层。  </p>
<p>共享对象被初始化在主存中。跑在CPU上的一个线程将这个共享对象读到CPU缓存中。然后修改了这个对象。只要CPU缓存没有被刷新会主存，对象修改后的版本对跑在其它CPU上的线程都是不可见的。这种方式可能导致每个线程拥有这个共享对象的私有拷贝，每个拷贝停留在不同的CPU缓存中。  </p>
<p>跑在左边CPU的线程拷贝这个共享对象到它的CPU缓存中，然后将count变量的值修改为2。这个修改对跑在右边CPU上的其它线程是不可见的，因为修改后的count的值还没有被刷新回主存中去。<br><img src="http://i.imgur.com/aIckfGe.png" alt=""><br>解决这个问题你可以使用Java中的volatile关键字。volatile关键字可以保证直接从主存中读取一个变量，如果这个变量被修改后，总是会被写回到主存中去。  </p>
<h2 id="Race-Conditions"><a href="#Race-Conditions" class="headerlink" title="Race Conditions"></a>Race Conditions</h2><p>如果两个或者更多的线程共享一个对象，多个线程在这个共享对象上更新变量，就有可能发生race conditions。</p>
<p>如果线程A读一个共享对象的变量count到它的CPU缓存中。线程B也做了同样的事情，但是往一个不同的CPU缓存中。现在线程A将count加1，线程B也做了同样的事情。现在count已经被增在了两个，每个CPU缓存中一次。</p>
<p>如果这些增加操作被顺序的执行，变量count应该被增加两次，然后原值+2被写回到主存中去。</p>
<p>然而，两次增加都是在没有适当的同步下并发执行的。无论是线程A还是线程B将count修改后的版本写回到主存中取，修改后的值仅会被原值大1，尽管增加了两次。</p>
<p><img src="http://i.imgur.com/zfLpW4r.png" alt="">  </p>
<p>解决这个问题可以使用Java同步块。<br><strong>一个同步块可以保证在同一时刻仅有一个线程可以进入代码的临界区。</strong><br>同步块还可以保证代码块中所有被访问的变量将会从主存中读入，当线程退出同步代码块时，所有被更新的变量都会被刷新回主存中去，不管这个变量是否被声明为volatile。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线程的状态&quot;&gt;&lt;a href=&quot;#线程的状态&quot; class=&quot;headerlink&quot; title=&quot;线程的状态&quot;&gt;&lt;/a&gt;线程的状态&lt;/h1&gt;&lt;p&gt;Java中，线程的状态有以下6类：NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WA
    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/"/>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>10_Java容器篇_ThreadLocal</title>
    <link href="http://yoursite.com/2017/07/29/Backend/Java/container/10_Java%E5%AE%B9%E5%99%A8%E7%AF%87_ThreadLocal/"/>
    <id>http://yoursite.com/2017/07/29/Backend/Java/container/10_Java容器篇_ThreadLocal/</id>
    <published>2017-07-29T12:57:13.000Z</published>
    <updated>2017-07-29T12:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p>
<h1 id="ThreadLocal类提供的方法："><a href="#ThreadLocal类提供的方法：" class="headerlink" title="ThreadLocal类提供的方法："></a>ThreadLocal类提供的方法：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public T get() &#123; &#125;</div><div class="line">public void set(T value) &#123; &#125;</div><div class="line">public void remove() &#123; &#125;</div><div class="line">protected T initialValue() &#123; &#125;</div></pre></td></tr></table></figure>
<p>get()方法是用来获取ThreadLocal在当前线程中保存的变量副本，<br>set()用来设置当前线程中变量的副本，<br>remove()用来移除当前线程中变量的副本，<br>initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法  </p>
<h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><p><img src="http://i.imgur.com/A9nfw1e.jpg" alt="">  </p>
<p>第一句是取得当前线程，然后通过getMap(t)方法获取到一个map，map的类型为ThreadLocalMap。然后接着下面获取到<key,value>键值对，注意这里获取键值对传进去的是  this，而不是当前线程t。  </key,value></p>
<p>如果获取成功，则返回value值。  </p>
<p>如果map为空，则调用setInitialValue方法返回value。  </p>
<p>getMap()<br><img src="http://i.imgur.com/OyctcgA.jpg" alt="">  </p>
<p>在getMap中，是调用当期线程t，返回当前线程t中的一个成员变量threadLocals。<br><img src="http://i.imgur.com/qPnpfOa.jpg" alt="">  </p>
<p>实际上就是一个ThreadLocalMap，这个类型是ThreadLocal类的一个内部类:<br><img src="http://i.imgur.com/2g2gaS2.jpg" alt=""><br>ThreadLocalMap的Entry继承了WeakReference，并且使用ThreadLocal作为键值。  </p>
<h2 id="setInitialValue"><a href="#setInitialValue" class="headerlink" title="setInitialValue()"></a>setInitialValue()</h2><p><img src="http://i.imgur.com/6ROXpdf.jpg" alt=""><br>如果map不为空，就设置键值对，为空，再创建Map<br><img src="http://i.imgur.com/gf3RhcN.jpg" alt="">  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。  </p>
<p>初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。  </p>
<p>然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。  </p>
<p>1）实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的；</p>
<p>2）为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个类型不同的threadLocal变量；</p>
<p>3）在进行get之前，必须先set，否则会报空指针异常；  </p>
<p>如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法。  </p>
<p>如果没有先set的话，即在map中查找不到对应的存储，则会通过调用setInitialValue方法返回i，而在setInitialValue方法中，有一个语句是T value = initialValue()， 而默认情况下，initialValue方法返回的是null</p>
<p><img src="http://i.imgur.com/7QdrQ0S.jpg" alt="">  </p>
<h1 id="ThreadLocal的应用场景"><a href="#ThreadLocal的应用场景" class="headerlink" title="ThreadLocal的应用场景"></a>ThreadLocal的应用场景</h1><p>最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ThreadLocal&quot;&gt;&lt;a href=&quot;#ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal&quot;&gt;&lt;/a&gt;ThreadLocal&lt;/h1&gt;&lt;p&gt;ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线
    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/"/>
    
      <category term="容器" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="Java容器" scheme="http://yoursite.com/tags/Java%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>01_Java并发篇_前言</title>
    <link href="http://yoursite.com/2017/07/29/Backend/Java/concurrency/01_Java%E5%B9%B6%E5%8F%91%E7%AF%87_%E5%89%8D%E8%A8%80/"/>
    <id>http://yoursite.com/2017/07/29/Backend/Java/concurrency/01_Java并发篇_前言/</id>
    <published>2017-07-29T12:57:13.000Z</published>
    <updated>2017-07-29T12:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>并发很重要的，前言中记录事件与体会</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并发很重要的，前言中记录事件与体会&lt;/p&gt;

    
    </summary>
    
      <category term="后端开发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/"/>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://yoursite.com/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
